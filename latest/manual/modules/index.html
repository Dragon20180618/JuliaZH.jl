<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>模块 · Julia中文文档</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-89508993-1', 'auto');
ga('send', 'pageview');
</script><link rel="canonical" href="https://juliacn.github.io/JuliaZH.jl/latest/manual/modules/index.html"/><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../../assets/julia-manual.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../../index.html"><img class="logo" src="../../assets/logo.png" alt="Julia中文文档 logo"/></a><h1>Julia中文文档</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">主页</a></li><li><span class="toctext">手册</span><ul><li><a class="toctext" href="../getting-started/">入门</a></li><li><a class="toctext" href="../variables/">变量</a></li><li><a class="toctext" href="../integers-and-floating-point-numbers/">整数和浮点数</a></li><li><a class="toctext" href="../mathematical-operations/">数学运算和初等函数</a></li><li><a class="toctext" href="../complex-and-rational-numbers/">复数和分数</a></li><li><a class="toctext" href="../strings/">字符串</a></li><li><a class="toctext" href="../functions/">函数</a></li><li><a class="toctext" href="../control-flow/">流程控制</a></li><li><a class="toctext" href="../variables-and-scoping/">变量作用域</a></li><li><a class="toctext" href="../types/">类型</a></li><li><a class="toctext" href="../methods/">方法</a></li><li><a class="toctext" href="../constructors/">构造函数</a></li><li><a class="toctext" href="../conversion-and-promotion/">类型转换和类型提升</a></li><li><a class="toctext" href="../interfaces/">接口</a></li><li class="current"><a class="toctext" href>模块</a><ul class="internal"><li><a class="toctext" href="#模块用法摘要-1">模块用法摘要</a></li></ul></li><li><a class="toctext" href="../documentation/">文档</a></li><li><a class="toctext" href="../metaprogramming/">Metaprogramming</a></li><li><a class="toctext" href="../arrays/">多维数组</a></li><li><a class="toctext" href="../missing/">缺失值</a></li><li><a class="toctext" href="../networking-and-streams/">网络和流</a></li><li><a class="toctext" href="../parallel-computing/">并行计算</a></li><li><a class="toctext" href="../running-external-programs/">运行外部程序</a></li><li><a class="toctext" href="../calling-c-and-fortran-code/">调用 C 和 Fortran 代码</a></li><li><a class="toctext" href="../handling-operating-system-variation/">处理操作系统差异</a></li><li><a class="toctext" href="../environment-variables/">环境变量</a></li><li><a class="toctext" href="../embedding/">嵌入 Julia</a></li><li><a class="toctext" href="../code-loading/">代码加载</a></li><li><a class="toctext" href="../profile/">分析</a></li><li><a class="toctext" href="../stacktraces/">堆栈跟踪</a></li><li><a class="toctext" href="../performance-tips/">性能建议</a></li><li><a class="toctext" href="../workflow-tips/">工作流程建议</a></li><li><a class="toctext" href="../style-guide/">代码风格指南</a></li><li><a class="toctext" href="../faq/">常见问题</a></li><li><a class="toctext" href="../noteworthy-differences/">与其他语言的显著差异</a></li><li><a class="toctext" href="../unicode-input/">Unicode 输入表</a></li></ul></li><li><span class="toctext">Base</span><ul><li><a class="toctext" href="../../base/base/">基本功能</a></li><li><a class="toctext" href="../../base/collections/">集合和数据结构</a></li><li><a class="toctext" href="../../base/math/">数学相关</a></li><li><a class="toctext" href="../../base/numbers/">Numbers</a></li><li><a class="toctext" href="../../base/strings/">字符串</a></li><li><a class="toctext" href="../../base/arrays/">Arrays</a></li><li><a class="toctext" href="../../base/parallel/">Tasks</a></li><li><a class="toctext" href="../../base/multi-threading/">多线程</a></li><li><a class="toctext" href="../../base/constants/">常量</a></li><li><a class="toctext" href="../../base/file/">文件系统</a></li><li><a class="toctext" href="../../base/io-network/">I/O 与网络</a></li><li><a class="toctext" href="../../base/punctuation/">标点符号</a></li><li><a class="toctext" href="../../base/sort/">排序及相关函数</a></li><li><a class="toctext" href="../../base/iterators/">迭代相关</a></li><li><a class="toctext" href="../../base/c/">C 接口</a></li><li><a class="toctext" href="../../base/libc/">C 标准库</a></li><li><a class="toctext" href="../../base/stacktraces/">StackTraces</a></li><li><a class="toctext" href="../../base/simd-types/">SIMD 支持</a></li></ul></li><li><span class="toctext">Standard Library</span><ul><li><a class="toctext" href="../../stdlib/Base64/">Base64</a></li><li><a class="toctext" href="../../stdlib/CRC32c/">CRC32c</a></li><li><a class="toctext" href="../../stdlib/Dates/">Dates</a></li><li><a class="toctext" href="../../stdlib/DelimitedFiles/">Delimited Files</a></li><li><a class="toctext" href="../../stdlib/Distributed/">Distributed Computing</a></li><li><a class="toctext" href="../../stdlib/FileWatching/">File Events</a></li><li><a class="toctext" href="../../stdlib/InteractiveUtils/">Interactive Utilities</a></li><li><a class="toctext" href="../../stdlib/LibGit2/">LibGit2</a></li><li><a class="toctext" href="../../stdlib/Libdl/">Dynamic Linker</a></li><li><a class="toctext" href="../../stdlib/LinearAlgebra/">Linear Algebra</a></li><li><a class="toctext" href="../../stdlib/Logging/">Logging</a></li><li><a class="toctext" href="../../stdlib/Markdown/">Markdown</a></li><li><a class="toctext" href="../../stdlib/Mmap/">Memory-mapped I/O</a></li><li><a class="toctext" href="../../stdlib/Pkg/">Pkg</a></li><li><a class="toctext" href="../../stdlib/Printf/">Printf</a></li><li><a class="toctext" href="../../stdlib/Profile/">Profiling</a></li><li><a class="toctext" href="../../stdlib/REPL/">The Julia REPL</a></li><li><a class="toctext" href="../../stdlib/Random/">Random Numbers</a></li><li><a class="toctext" href="../../stdlib/SHA/">SHA</a></li><li><a class="toctext" href="../../stdlib/Serialization/">Serialization</a></li><li><a class="toctext" href="../../stdlib/SharedArrays/">Shared Arrays</a></li><li><a class="toctext" href="../../stdlib/Sockets/">Sockets</a></li><li><a class="toctext" href="../../stdlib/SparseArrays/">Sparse Arrays</a></li><li><a class="toctext" href="../../stdlib/Statistics/">Statistics</a></li><li><a class="toctext" href="../../stdlib/Test/">Unit Testing</a></li><li><a class="toctext" href="../../stdlib/UUIDs/">UUIDs</a></li><li><a class="toctext" href="../../stdlib/Unicode/">Unicode</a></li></ul></li><li><span class="toctext">Developer Documentation</span><ul><li><a class="toctext" href="../../devdocs/reflection/">反射 与 自我检查</a></li><li><span class="toctext">Documentation of Julia&#39;s Internals</span><ul><li><a class="toctext" href="../../devdocs/init/">Julia 运行时的初始化</a></li><li><a class="toctext" href="../../devdocs/ast/">Julia 的 AST</a></li><li><a class="toctext" href="../../devdocs/types/">More about types</a></li><li><a class="toctext" href="../../devdocs/object/">Memory layout of Julia Objects</a></li><li><a class="toctext" href="../../devdocs/eval/">Eval of Julia code</a></li><li><a class="toctext" href="../../devdocs/callconv/">Calling Conventions</a></li><li><a class="toctext" href="../../devdocs/compiler/">High-level Overview of the Native-Code Generation Process</a></li><li><a class="toctext" href="../../devdocs/functions/">Julia的相关函数</a></li><li><a class="toctext" href="../../devdocs/cartesian/">Base.Cartesian</a></li><li><a class="toctext" href="../../devdocs/meta/">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="toctext" href="../../devdocs/subarrays/">SubArrays</a></li><li><a class="toctext" href="../../devdocs/isbitsunionarrays/">isbits Union Optimizations</a></li><li><a class="toctext" href="../../devdocs/sysimg/">System Image Building</a></li><li><a class="toctext" href="../../devdocs/llvm/">Working with LLVM</a></li><li><a class="toctext" href="../../devdocs/stdio/">printf() and stdio in the Julia runtime</a></li><li><a class="toctext" href="../../devdocs/boundscheck/">边界检查</a></li><li><a class="toctext" href="../../devdocs/locks/">Proper maintenance and care of multi-threading locks</a></li><li><a class="toctext" href="../../devdocs/offset-arrays/">Arrays with custom indices</a></li><li><a class="toctext" href="../../devdocs/require/">Module loading</a></li><li><a class="toctext" href="../../devdocs/inference/">Inference</a></li></ul></li><li><span class="toctext">Developing/debugging Julia&#39;s C code</span><ul><li><a class="toctext" href="../../devdocs/backtraces/">Reporting and analyzing crashes (segfaults)</a></li><li><a class="toctext" href="../../devdocs/debuggingtips/">gdb 调试提示</a></li><li><a class="toctext" href="../../devdocs/valgrind/">Using Valgrind with Julia</a></li><li><a class="toctext" href="../../devdocs/sanitizers/">Sanitizer support</a></li></ul></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>手册</li><li><a href>模块</a></li></ul><a class="edit-page" href="https://github.com/JuliaCN/JuliaZH.jl/blob/master/doc/src/manual/modules.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>模块</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="modules-1" href="#modules-1">模块</a></h1><p>Julia 中的模块（module）是单独的变量工作空间，即它们引入了新的全局作用域。 它们在语法上以 <code>module Name ... end</code> 界定。 模块允许你创建顶层定义（也称为全局变量），而无需担心在你的代码与其他人的代码一起使用时产生名字冲突。 在模块中，你可以控制其他模块中的哪些名称可用（通过导入），并指定哪些你的名称是公开的（通过导出）。</p><p>下面的示例演示了模块的主要功能。它不需要运行，只是为了说明目的：</p><pre><code class="language-julia">module MyModule
using Lib

using BigLib: thing1, thing2

import Base.show

export MyType, foo

struct MyType
    x
end

bar(x) = 2x
foo(a::MyType) = bar(a.x) + 1

show(io::IO, a::MyType) = print(io, &quot;MyType $(a.x)&quot;)
end</code></pre><p>注意，模块中的代码样式不需要缩进，否则的话，会导致整个文件缩进。</p><p>上面的模块定义了一个 <code>MyType</code> 类型，以及两个函数，其中，函数 <code>foo</code> 和类型 <code>MyType</code> 被导出了，因而可以被导入到其它模块，而函数 <code>bar</code> 是模块 <code>MyModule</code> 的私有函数。</p><p><code>using Lib</code> 意味着一个名称为 <code>Lib</code> 的模块会在需要的时候用于解释变量名。当一个全局变量在当前模块中没有定义时，系统就会从 <code>Lib</code> 中导出的变量中搜索该变量，如果找到了的话，就导入进来。也就是说，当前模块中，所有使用该全局变量的地方都会解释为 <code>Lib</code> 中对应的变量。</p><p>代码 <code>using BigLib: thing1, thing2</code> 显式地将标识符 <code>thing1</code> 和 <code>thing2</code> 从模块 <code>BigLib</code> 中引入到当前作用域。 如果这两个变量是函数的话，那么是允许给他们增加实现方法的，毕竟代码里写的是 &quot;using&quot; （使用）它们，而不是扩展它们。</p><p><code>import</code> 关键字所支持的语法与 <code>using</code> 一致，不过一次只作用于一个名字。此外它并不会像 <code>using</code> 那样将模块添加到搜索空间中，与 <code>using</code> 不同的，<code>import</code> 引入的函数可以为其增加新的方法。</p><p>前面的 <code>MyModule</code> 模块中，我们希望给 <code>show</code> 函数增加一个方法，于是需要写成 <code>import Base.show</code>，这里如果写成 <code>using</code> 的话，就不能给 <code>show</code> 函数增加一个实现了。</p><p>一旦一个变量通过 <code>using</code> 或 <code>import</code> 引入，当前模块就不能创建同名的变量了。而且导入的变量是只读的，给全局变量赋值只能影响当前模块的变量，否则会报错。</p><h2><a class="nav-anchor" id="模块用法摘要-1" href="#模块用法摘要-1">模块用法摘要</a></h2><p>要导入一个模块，可以用 <code>using</code> 或 <code>import</code> 关键字。为了更好地理解它们的区别，看看下面的例子：</p><pre><code class="language-julia">module MyModule

export x, y

x() = &quot;x&quot;
y() = &quot;y&quot;
p() = &quot;p&quot;

end</code></pre><p>这个模块用关键字 <code>export</code> 导出了 <code>x</code> 和 <code>y</code> 函数，此外还有一个没有被导出的函数 <code>p</code>。想要将该模块及其内部的函数导入当前模块有以下方法：</p><table><tr><th><code>import</code> 命令</th><th>将哪些变量导入了当前作用域？</th><th>Available for method extension</th></tr><tr><td><code>using MyModule</code></td><td>All <code>export</code>ed names (<code>x</code> and <code>y</code>), <code>MyModule.x</code>, <code>MyModule.y</code> and <code>MyModule.p</code></td><td><code>MyModule.x</code>, <code>MyModule.y</code> and <code>MyModule.p</code></td></tr><tr><td><code>using MyModule: x, p</code></td><td><code>x</code> and <code>p</code></td><td></td></tr><tr><td><code>import MyModule</code></td><td><code>MyModule.x</code>, <code>MyModule.y</code> and <code>MyModule.p</code></td><td><code>MyModule.x</code>, <code>MyModule.y</code> and <code>MyModule.p</code></td></tr><tr><td><code>import MyModule.x, MyModule.p</code></td><td><code>x</code> and <code>p</code></td><td><code>x</code> and <code>p</code></td></tr><tr><td><code>import MyModule: x, p</code></td><td><code>x</code> and <code>p</code></td><td><code>x</code> and <code>p</code></td></tr></table><h3><a class="nav-anchor" id="模块和文件-1" href="#模块和文件-1">模块和文件</a></h3><p>模块与文件和文件名无关；模块只与模块表达式有关。一个模块可以有多个文件，一个文件也可以有多个模块。</p><pre><code class="language-julia">module Foo

include(&quot;file1.jl&quot;)
include(&quot;file2.jl&quot;)

end</code></pre><p>在不同的模块中引入同一段代码，提供了一种类似 mixin 的行为。这可以用于给定不同的base执行同一段代码，例如，在测试的时候，可以运行一些相对 <strong>安全</strong> 的操作符。</p><pre><code class="language-julia">module Normal
include(&quot;mycode.jl&quot;)
end

module Testing
include(&quot;safe_operators.jl&quot;)
include(&quot;mycode.jl&quot;)
end</code></pre><h3><a class="nav-anchor" id="标准模块-1" href="#标准模块-1">标准模块</a></h3><p>有三个非常重要的标准模块： Main, Core 和 Base</p><p>Main 是最顶层的模块，Julia 启动后会将 Main 设置为当前模块。 在提示符下定义的变量会进入到 Main，执行 <code>varinfo()</code> 会列出 Main 中的变量。</p><p>Core 包含所有语言内置的标识符（语言的核心部分，不是库），每个模块都默认声明了 <code>using Core</code>（否则的话啥也做不了）。</p><p>Base 模块包含了一些基本的功能 ( 即源码中 base/ 目录下的内容)。 所有模块都默认包含了 <code>using Base</code> ，因为对大多数库来说，都会用到。</p><h3><a class="nav-anchor" id="默认顶层定义以及裸模块-1" href="#默认顶层定义以及裸模块-1">默认顶层定义以及裸模块</a></h3><p>除了默认包含 <code>using Base</code> 之外，所有模块都还包含 <code>eval</code> 和 <code>include</code> 函数。这两个函数用于将表达式和文件引入到全局作用域中</p><p>如果这些默认的定义都不需要，那么可以用 <code>baremodule</code> 定义裸模块（不过 <code>Core</code> 模块仍然被引入领导，否则啥也写不了）。与标准的模块定义类似，一个裸模块的定义如下：</p><pre><code class="language-none">baremodule Mod

using Base

eval(x) = Core.eval(Mod, x)
include(p) = Base.include(Mod, p)

...

end</code></pre><h3><a class="nav-anchor" id="模块的绝对路径和相对路径-1" href="#模块的绝对路径和相对路径-1">模块的绝对路径和相对路径</a></h3><p>给定语句 <code>using Foo</code>，系统在顶层模块的内部表中查找名为 <code>Foo</code> 的包。 如果模块不存在，系统会尝试 <code>require(:Foo)</code>，这通常会从已安装的包中加载代码。</p><p>但是，某些模块包含子模块，这意味着您有时需要访问非顶层模块。 有两种方法可以做到这一点。 第一种是使用绝对路径，例如 <code>using Base.Sort</code>。 第二种是使用相对路径，这样可以更容易地导入当前模块或其任何封闭模块的子模块：</p><pre><code class="language-none">module Parent

module Utils
...
end

using .Utils

...
end</code></pre><p>这里的模块 <code>Parent</code> 包含一个子模块 <code>Utils</code>，而<code>Parent</code> 中的代码希望 <code>Utils</code> 的内容可见。 这是通过使用句号启动 <code>using</code> 路径来完成的。 添加更多前导句号会移动到模块层次结构中的更上级别。 例如 <code>using ..Utils</code> 会在 <code>Parent</code> 的封闭模块中查找 <code>Utils</code> 而不是 <code>Parent</code> 本身。</p><p>请注意，相对导入修饰符仅在 <code>using</code> 和 <code>import</code> 语句中有效。</p><h3><a class="nav-anchor" id="模块文件路径-1" href="#模块文件路径-1">模块文件路径</a></h3><p>全局变量 <a href="../../base/constants/#Base.LOAD_PATH"><code>LOAD_PATH</code></a> 包含 Julia 在调用 <code>require</code> 时搜索模块的目录。 可以使用<a href="../../base/collections/#Base.push!"><code>push!</code></a> 对它进行扩展：</p><pre><code class="language-julia">push!(LOAD_PATH, &quot;/Path/To/My/Module/&quot;)</code></pre><p>将此语句放在文件 <code>~/.julia/config/startup.jl</code> 中将在每次 Julia 启动时扩展 <a href="../../base/constants/#Base.LOAD_PATH"><code>LOAD_PATH</code></a>。 或者，可以通过定义环境变量<code>JULIA_LOAD_PATH</code> 来扩展模块加载路径。</p><h3><a class="nav-anchor" id="命名空间杂记-1" href="#命名空间杂记-1">命名空间杂记</a></h3><p>如果名称是限定的（例如 <code>Base.sin</code>），那么即使它没有被导出也可以访问它。 这通常在调试时很有用。 还可以通过使用限定名称作为函数名称来添加方法。 但是，如果您希望将方法添加到其他模块中的函数，函数名仅包含符号，例如一个运算符，<code>Base.+</code>，由于出现语法歧义，则必须使用 <code>Base.:+</code> 引用它。 如果运算符的长度不止一个，则必须用括号括起来，例如：<code>Base.:(==)</code>。</p><p>宏名称在导入和导出语句中用 <code>@</code> 编写，例如：<code>import Mod.@mac</code>。 其他模块中的宏可以调用为 <code>Mod.@mac</code> 或 <code>@Mod.mac</code>。</p><p>语法 <code>M.x = y</code> 不能在另一个模块中的全局变量赋值；全局变量的赋值始终是模块内部的。</p><p>将变量名称声明为 <code>global x</code> 可以“保留”名称而无需赋值。这可以防止加载初始化后全局变量的名称冲突。</p><h3><a class="nav-anchor" id="模块初始化和预编译-1" href="#模块初始化和预编译-1">模块初始化和预编译</a></h3><p>因为执行模块中的所有语句通常需要编译大量代码，大型模块可能需要几秒钟才能加载。Julia 会创建模块的预编译缓存以减少这个时间。</p><p>The incremental precompiled module file are created and used automatically when using <code>import</code> or <code>using</code> to load a module.  This will cause it to be automatically compiled the first time it is imported. Alternatively, you can manually call <code>Base.compilecache(modulename)</code>. The resulting cache files will be stored in <code>DEPOT_PATH[1]/compiled/</code>. Subsequently, the module is automatically recompiled upon <code>using</code> or <code>import</code> whenever any of its dependencies change; dependencies are modules it imports, the Julia build, files it includes, or explicit dependencies declared by <code>include_dependency(path)</code> in the module file(s).</p><p>For file dependencies, a change is determined by examining whether the modification time (mtime) of each file loaded by <code>include</code> or added explicitly by <code>include_dependency</code> is unchanged, or equal to the modification time truncated to the nearest second (to accommodate systems that can&#39;t copy mtime with sub-second accuracy). It also takes into account whether the path to the file chosen by the search logic in <code>require</code> matches the path that had created the precompile file.</p><p>It also takes into account the set of dependencies already loaded into the current process and won&#39;t recompile those modules, even if their files change or disappear, in order to avoid creating incompatibilities between the running system and the precompile cache. If you want to have changes to the source reflected in the running system, you should call <code>reload(&quot;Module&quot;)</code> on the module you changed, and any module that depended on it in which you want to see the change reflected.</p><p>If you know that a module is <em>not</em> safe to precompile your module (for example, for one of the reasons described below), you should put <code>__precompile__(false)</code> in the module file (typically placed at the top). This will cause <code>Base.compilecache</code> to throw an error, and will cause <code>using</code> / <code>import</code> to load it directly into the current process and skip the precompile and caching. This also thereby prevents the module from being imported by any other precompiled module.</p><p>You may need to be aware of certain behaviors inherent in the creation of incremental shared libraries which may require care when writing your module. For example, external state is not preserved. To accommodate this, explicitly separate any initialization steps that must occur at <em>runtime</em> from steps that can occur at <em>compile time</em>. For this purpose, Julia allows you to define an <code>__init__()</code> function in your module that executes any initialization steps that must occur at runtime. This function will not be called during compilation (<code>--output-*</code>). Effectively, you can assume it will be run exactly once in the lifetime of the code. You may, of course, call it manually if necessary, but the default is to assume this function deals with computing state for the local machine, which does not need to be – or even should not be – captured in the compiled image. It will be called after the module is loaded into a process, including if it is being loaded into an incremental compile (<code>--output-incremental=yes</code>), but not if it is being loaded into a full-compilation process.</p><p>In particular, if you define a <code>function __init__()</code> in a module, then Julia will call <code>__init__()</code> immediately <em>after</em> the module is loaded (e.g., by <code>import</code>, <code>using</code>, or <code>require</code>) at runtime for the <em>first</em> time (i.e., <code>__init__</code> is only called once, and only after all statements in the module have been executed). Because it is called after the module is fully imported, any submodules or other imported modules have their <code>__init__</code> functions called <em>before</em> the <code>__init__</code> of the enclosing module.</p><p>Two typical uses of <code>__init__</code> are calling runtime initialization functions of external C libraries and initializing global constants that involve pointers returned by external libraries.  For example, suppose that we are calling a C library <code>libfoo</code> that requires us to call a <code>foo_init()</code> initialization function at runtime. Suppose that we also want to define a global constant <code>foo_data_ptr</code> that holds the return value of a <code>void *foo_data()</code> function defined by <code>libfoo</code> – this constant must be initialized at runtime (not at compile time) because the pointer address will change from run to run.  You could accomplish this by defining the following <code>__init__</code> function in your module:</p><pre><code class="language-julia">const foo_data_ptr = Ref{Ptr{Cvoid}}(0)
function __init__()
    ccall((:foo_init, :libfoo), Cvoid, ())
    foo_data_ptr[] = ccall((:foo_data, :libfoo), Ptr{Cvoid}, ())
    nothing
end</code></pre><p>Notice that it is perfectly possible to define a global inside a function like <code>__init__</code>; this is one of the advantages of using a dynamic language. But by making it a constant at global scope, we can ensure that the type is known to the compiler and allow it to generate better optimized code. Obviously, any other globals in your module that depends on <code>foo_data_ptr</code> would also have to be initialized in <code>__init__</code>.</p><p>Constants involving most Julia objects that are not produced by <code>ccall</code> do not need to be placed in <code>__init__</code>: their definitions can be precompiled and loaded from the cached module image. This includes complicated heap-allocated objects like arrays. However, any routine that returns a raw pointer value must be called at runtime for precompilation to work (Ptr objects will turn into null pointers unless they are hidden inside an isbits object). This includes the return values of the Julia functions <code>cfunction</code> and <code>pointer</code>.</p><p>Dictionary and set types, or in general anything that depends on the output of a <code>hash(key)</code> method, are a trickier case.  In the common case where the keys are numbers, strings, symbols, ranges, <code>Expr</code>, or compositions of these types (via arrays, tuples, sets, pairs, etc.) they are safe to precompile.  However, for a few other key types, such as <code>Function</code> or <code>DataType</code> and generic user-defined types where you haven&#39;t defined a <code>hash</code> method, the fallback <code>hash</code> method depends on the memory address of the object (via its <code>objectid</code>) and hence may change from run to run. If you have one of these key types, or if you aren&#39;t sure, to be safe you can initialize this dictionary from within your <code>__init__</code> function. Alternatively, you can use the <code>IdDict</code> dictionary type, which is specially handled by precompilation so that it is safe to initialize at compile-time.</p><p>When using precompilation, it is important to keep a clear sense of the distinction between the compilation phase and the execution phase. In this mode, it will often be much more clearly apparent that Julia is a compiler which allows execution of arbitrary Julia code, not a standalone interpreter that also generates compiled code.</p><p>Other known potential failure scenarios include:</p><ol><li><p>Global counters (for example, for attempting to uniquely identify objects) Consider the following code snippet:</p><pre><code class="language-julia">mutable struct UniquedById
    myid::Int
    let counter = 0
        UniquedById() = new(counter += 1)
    end
end</code></pre><p>while the intent of this code was to give every instance a unique id, the counter value is recorded at the end of compilation. All subsequent usages of this incrementally compiled module will start from that same counter value.</p><p>Note that <code>objectid</code> (which works by hashing the memory pointer) has similar issues (see notes on <code>Dict</code> usage below).</p><p>One alternative is to use a macro to capture <a href="../../base/base/#Base.@__MODULE__"><code>@__MODULE__</code></a> and store it alone with the current <code>counter</code> value, however, it may be better to redesign the code to not depend on this global state.</p></li><li><p>Associative collections (such as <code>Dict</code> and <code>Set</code>) need to be re-hashed in <code>__init__</code>. (In the future, a mechanism may be provided to register an initializer function.)</p></li><li><p>Depending on compile-time side-effects persisting through load-time. Example include: modifying arrays or other variables in other Julia modules; maintaining handles to open files or devices; storing pointers to other system resources (including memory);</p></li><li><p>Creating accidental &quot;copies&quot; of global state from another module, by referencing it directly instead of via its lookup path. For example, (in global scope):</p><pre><code class="language-julia">#mystdout = Base.stdout #= will not work correctly, since this will copy Base.stdout into this module =#
# instead use accessor functions:
getstdout() = Base.stdout #= best option =#
# or move the assignment into the runtime:
__init__() = global mystdout = Base.stdout #= also works =#</code></pre></li></ol><p>Several additional restrictions are placed on the operations that can be done while precompiling code to help the user avoid other wrong-behavior situations:</p><ol><li>Calling <a href="../../base/base/#Base.MainInclude.eval"><code>eval</code></a> to cause a side-effect in another module. This will also cause a warning to be emitted when the incremental precompile flag is set.</li><li><code>global const</code> statements from local scope after <code>__init__()</code> has been started (see issue #12010 for plans to add an error for this)</li><li>Replacing a module is a runtime error while doing an incremental precompile.</li></ol><p>A few other points to be aware of:</p><ol><li>No code reload / cache invalidation is performed after changes are made to the source files themselves, (including by [<code>Pkg.update</code>], and no cleanup is done after [<code>Pkg.rm</code>]</li><li>The memory sharing behavior of a reshaped array is disregarded by precompilation (each view gets its own copy)</li><li>Expecting the filesystem to be unchanged between compile-time and runtime e.g. <a href="../../base/file/#Base.@__FILE__"><code>@__FILE__</code></a>/<code>source_path()</code> to find resources at runtime, or the BinDeps <code>@checked_lib</code> macro. Sometimes this is unavoidable. However, when possible, it can be good practice to copy resources into the module at compile-time so they won&#39;t need to be found at runtime.</li><li><code>WeakRef</code> objects and finalizers are not currently handled properly by the serializer (this will be fixed in an upcoming release).</li><li>It is usually best to avoid capturing references to instances of internal metadata objects such as <code>Method</code>, <code>MethodInstance</code>, <code>MethodTable</code>, <code>TypeMapLevel</code>, <code>TypeMapEntry</code> and fields of those objects, as this can confuse the serializer and may not lead to the outcome you desire. It is not necessarily an error to do this, but you simply need to be prepared that the system will try to copy some of these and to create a single unique instance of others.</li></ol><p>It is sometimes helpful during module development to turn off incremental precompilation. The command line flag <code>--compiled-modules={yes|no}</code> enables you to toggle module precompilation on and off. When Julia is started with <code>--compiled-modules=no</code> the serialized modules in the compile cache are ignored when loading modules and module dependencies. <code>Base.compilecache</code> can still be called manually. The state of this command line flag is passed to <code>Pkg.build</code> to disable automatic precompilation triggering when installing, updating, and explicitly building packages.</p><footer><hr/><a class="previous" href="../interfaces/"><span class="direction">Previous</span><span class="title">接口</span></a><a class="next" href="../documentation/"><span class="direction">Next</span><span class="title">文档</span></a></footer></article></body></html>
