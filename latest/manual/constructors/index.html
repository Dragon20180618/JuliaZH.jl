<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>构造函数 · Julia中文文档</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-89508993-1', 'auto');
ga('send', 'pageview');
</script><link rel="canonical" href="https://juliacn.github.io/JuliaZH.jl/latest/manual/constructors/index.html"/><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../../assets/julia-manual.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../../index.html"><img class="logo" src="../../assets/logo.png" alt="Julia中文文档 logo"/></a><h1>Julia中文文档</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">主页</a></li><li><span class="toctext">手册</span><ul><li><a class="toctext" href="../getting-started/">入门</a></li><li><a class="toctext" href="../variables/">变量</a></li><li><a class="toctext" href="../integers-and-floating-point-numbers/">整数和浮点数</a></li><li><a class="toctext" href="../mathematical-operations/">数学运算和初等函数</a></li><li><a class="toctext" href="../complex-and-rational-numbers/">复数和有理数</a></li><li><a class="toctext" href="../strings/">字符串</a></li><li><a class="toctext" href="../functions/">函数</a></li><li><a class="toctext" href="../control-flow/">流程控制</a></li><li><a class="toctext" href="../variables-and-scoping/">Scope of Variables</a></li><li><a class="toctext" href="../types/">类型</a></li><li><a class="toctext" href="../methods/">方法</a></li><li class="current"><a class="toctext" href>构造函数</a><ul class="internal"><li><a class="toctext" href="#外部构造方法-1">外部构造方法</a></li><li><a class="toctext" href="#内部构造方法-1">内部构造方法</a></li><li><a class="toctext" href="#Incomplete-Initialization-1">Incomplete Initialization</a></li><li><a class="toctext" href="#Parametric-Constructors-1">Parametric Constructors</a></li><li><a class="toctext" href="#Case-Study:-Rational-1">Case Study: Rational</a></li><li><a class="toctext" href="#Outer-only-constructors-1">Outer-only constructors</a></li></ul></li><li><a class="toctext" href="../conversion-and-promotion/">类型转换和类型提升</a></li><li><a class="toctext" href="../interfaces/">Interfaces</a></li><li><a class="toctext" href="../modules/">Modules</a></li><li><a class="toctext" href="../documentation/">文档</a></li><li><a class="toctext" href="../metaprogramming/">元编程</a></li><li><a class="toctext" href="../arrays/">多维数组</a></li><li><a class="toctext" href="../missing/">缺失值</a></li><li><a class="toctext" href="../networking-and-streams/">Networking and Streams</a></li><li><a class="toctext" href="../parallel-computing/">并行计算</a></li><li><a class="toctext" href="../running-external-programs/">运行外部程序</a></li><li><a class="toctext" href="../calling-c-and-fortran-code/">调用 C 和 Fortran 代码</a></li><li><a class="toctext" href="../handling-operating-system-variation/">处理操作系统差异</a></li><li><a class="toctext" href="../environment-variables/">环境变量</a></li><li><a class="toctext" href="../embedding/">嵌入 Julia</a></li><li><a class="toctext" href="../code-loading/">代码加载</a></li><li><a class="toctext" href="../profile/">Profiling</a></li><li><a class="toctext" href="../stacktraces/">Stack Traces</a></li><li><a class="toctext" href="../performance-tips/">性能建议</a></li><li><a class="toctext" href="../workflow-tips/">工作流程建议</a></li><li><a class="toctext" href="../style-guide/">代码风格指南</a></li><li><a class="toctext" href="../faq/">常见问题</a></li><li><a class="toctext" href="../noteworthy-differences/">Noteworthy Differences from other Languages</a></li><li><a class="toctext" href="../unicode-input/">Unicode 输入表</a></li></ul></li><li><span class="toctext">Base</span><ul><li><a class="toctext" href="../../base/base/">Essentials</a></li><li><a class="toctext" href="../../base/collections/">集合和数据结构</a></li><li><a class="toctext" href="../../base/math/">Mathematics</a></li><li><a class="toctext" href="../../base/numbers/">Numbers</a></li><li><a class="toctext" href="../../base/strings/">【字符串】（@id lib-strings）</a></li><li><a class="toctext" href="../../base/arrays/">Arrays</a></li><li><a class="toctext" href="../../base/parallel/">Tasks</a></li><li><a class="toctext" href="../../base/multi-threading/">多线程</a></li><li><a class="toctext" href="../../base/constants/">Constants</a></li><li><a class="toctext" href="../../base/file/">文件系统</a></li><li><a class="toctext" href="../../base/io-network/">I/O and Network</a></li><li><a class="toctext" href="../../base/punctuation/">Punctuation</a></li><li><a class="toctext" href="../../base/sort/">排序及相关函数</a></li><li><a class="toctext" href="../../base/iterators/">Iteration utilities</a></li><li><a class="toctext" href="../../base/c/">C Interface</a></li><li><a class="toctext" href="../../base/libc/">C Standard Library</a></li><li><a class="toctext" href="../../base/stacktraces/">StackTraces</a></li><li><a class="toctext" href="../../base/simd-types/">SIMD Support</a></li></ul></li><li><span class="toctext">Developer Documentation</span><ul><li><a class="toctext" href="../../devdocs/reflection/">Reflection and introspection</a></li><li><span class="toctext">Documentation of Julia&#39;s Internals</span><ul><li><a class="toctext" href="../../devdocs/init/">Initialization of the Julia runtime</a></li><li><a class="toctext" href="../../devdocs/ast/">Julia ASTs</a></li><li><a class="toctext" href="../../devdocs/types/">More about types</a></li><li><a class="toctext" href="../../devdocs/object/">Memory layout of Julia Objects</a></li><li><a class="toctext" href="../../devdocs/eval/">Eval of Julia code</a></li><li><a class="toctext" href="../../devdocs/callconv/">Calling Conventions</a></li><li><a class="toctext" href="../../devdocs/compiler/">High-level Overview of the Native-Code Generation Process</a></li><li><a class="toctext" href="../../devdocs/functions/">Julia Functions</a></li><li><a class="toctext" href="../../devdocs/cartesian/">Base.Cartesian</a></li><li><a class="toctext" href="../../devdocs/meta/">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="toctext" href="../../devdocs/subarrays/">SubArrays</a></li><li><a class="toctext" href="../../devdocs/isbitsunionarrays/">isbits Union Optimizations</a></li><li><a class="toctext" href="../../devdocs/sysimg/">System Image Building</a></li><li><a class="toctext" href="../../devdocs/llvm/">Working with LLVM</a></li><li><a class="toctext" href="../../devdocs/stdio/">printf() and stdio in the Julia runtime</a></li><li><a class="toctext" href="../../devdocs/boundscheck/">Bounds checking</a></li><li><a class="toctext" href="../../devdocs/locks/">Proper maintenance and care of multi-threading locks</a></li><li><a class="toctext" href="../../devdocs/offset-arrays/">Arrays with custom indices</a></li><li><a class="toctext" href="../../devdocs/require/">Module loading</a></li><li><a class="toctext" href="../../devdocs/inference/">Inference</a></li></ul></li><li><span class="toctext">Developing/debugging Julia&#39;s C code</span><ul><li><a class="toctext" href="../../devdocs/backtraces/">Reporting and analyzing crashes (segfaults)</a></li><li><a class="toctext" href="../../devdocs/debuggingtips/">gdb debugging tips</a></li><li><a class="toctext" href="../../devdocs/valgrind/">Using Valgrind with Julia</a></li><li><a class="toctext" href="../../devdocs/sanitizers/">Sanitizer support</a></li></ul></li></ul></li><li><span class="toctext">中文文档开发</span><ul><li><a class="toctext" href="../../juliacn/style-guide/">翻译指南</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>手册</li><li><a href>构造函数</a></li></ul><a class="edit-page" href="https://github.com/JuliaCN/JuliaZH.jl/blob/master/doc/src/manual/constructors.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>构造函数</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="man-constructors-1" href="#man-constructors-1">构造函数</a></h1><p>构造函数 <a href="#footnote-1">[1]</a> 是用来创建新对象 – 确切地说，是创建 <a href="manual/@ref">Composite Type</a> 的实例，的函数。在 Julia 中，类型对象也同时充当构造函数的角色：它们可以被当作函数应用到参数元组上来创建自己的新实例。这一点在介绍复合类型（Composite Types）时已经大致谈过了。例如：</p><pre><code class="language-julia-repl">julia&gt; struct Foo
           bar
           baz
       end

julia&gt; foo = Foo(1, 2)
Foo(1, 2)

julia&gt; foo.bar
1

julia&gt; foo.baz
2</code></pre><p>对很多类型来说，创建新对象时只需要为它们的所有字段绑定上值就足够产生新实例了。然而，在某些情形下，创建复合对象需要更多的功能。有时必须通过检查或改变参数来确保不变性。<a href="https://en.wikipedia.org/wiki/Recursion_omputer_science%29#Recursive_data_structures_.28structural_recursion.29">Recursive data structures</a>， 特别是那些可能引用自身的数据结构，它们需要首先被不完整地构造，然后作为创建对象的单独步骤， 通过编程的方式完成补全，否则它们不能被干净地构造。这时，能够用比字段少的参数或者 不同类型的参数来创建对象就很方便。Julia 的对象构造系统解决了所有这些问题。</p><div class="footnote" id="footnote-1"><a href="#footnote-1"><strong>[1]</strong></a></div><p>命名法：虽然术语“构造函数”通常是指构造一个类型的对象的整个函数，但通常会略微滥用术语将特定的构造方法称为“构造函数”。这种情况下，通常可以从上下文中清楚地看出术语是用于表示“构造方法”而不是“构造函数”，因为它通常用于从所有构造方法中挑出构造函数的特定方法的场合。</p><h2><a class="nav-anchor" id="外部构造方法-1" href="#外部构造方法-1">外部构造方法</a></h2><p>构造函数与 Julia 中的其他任何函数一样，其整体行为由其各个方法的组合行为定义。因此，你可以通过简单地定义新方法来向构造函数添加功能。例如，假设你想为 <code>Foo</code> 对象添加一个构造方法，该方法只接受一个参数并用该参数同时绑定为 <code>bar</code> 和 <code>baz</code>  字段的值。这很简单：</p><pre><code class="language-julia-repl">julia&gt; Foo(x) = Foo(x,x)
Foo

julia&gt; Foo(1)
Foo(1, 1)</code></pre><p>你也可以为 <code>Foo</code> 添加新的零参数构造方法，它为字段 <code>bar</code> 和 <code>baz</code> 提供默认值：</p><pre><code class="language-julia-repl">julia&gt; Foo() = Foo(0)
Foo

julia&gt; Foo()
Foo(0, 0)</code></pre><p>这里零参数构造方法调用的单参数方法，单参数构造方法又调用了自动提供的双参数构造方法。 像这样附加的以普通函数形式声明的构造方法被称为 <em>外部</em> 构造方法，这样称呼的原因马上就会清楚。 外部构造方法只能通过调用其他构造方法来创建新实例，比如自动提供的默认构造方法。</p><h2><a class="nav-anchor" id="内部构造方法-1" href="#内部构造方法-1">内部构造方法</a></h2><p>尽管外部构造方法成功地为构造对象提供了额外的便利，它无法解决另外两个在本章导言里提到的另外 两种用例：确保不变性和允许创建引用自身的对象。因此，我们需要 <em>内部</em> 构造方法。内部构造方法 和外部构造方法很相像，但有两点不同：</p><ol><li>内部构造方法在类型声明内部声明，而不是和普通方法一样在外部。</li><li>内部构造方法能够访问一个特殊的局部存在的函数, 称为 <a href="../../base/base/#new"><code>new</code></a> ，这个函数能够创建该类型的对象。</li></ol><p>例如, 假设你要声明一个保存一对实数的类型,，但要约束第一个数不大于第二个数。你可以像这样声明它 ：</p><pre><code class="language-julia-repl">julia&gt; struct OrderedPair
           x::Real
           y::Real
           OrderedPair(x,y) = x &gt; y ? error(&quot;out of order&quot;) : new(x,y)
       end</code></pre><p>现在 <code>OrderedPair</code> 对象只能在 <code>x &lt;= y</code> 时构造：</p><pre><code class="language-julia-repl">julia&gt; OrderedPair(1, 2)
OrderedPair(1, 2)

julia&gt; OrderedPair(2,1)
ERROR: out of order
Stacktrace:
 [1] error at ./error.jl:33 [inlined]
 [2] OrderedPair(::Int64, ::Int64) at ./none:4
 [3] top-level scope</code></pre><p>如果类型被声明为 <code>mutable</code>，你就能获取并直接修改字段的值来破坏不变性，但不请自来弄乱 对象内部被认为是不好的形式。你 （或者其他人）可以在以后任何时候提供附加的外部构造方法， 但一旦一个类型已经被声明了，就没有办法来添加更多的内部构造方法了。因为外部构造方法只能通过 调用其他的构造方法来构造创建对象，所以最终构造对象的一定是某个内部构造函数。这保证了 声明过的类型的所有对象必须通过调用随类型提供的内部构造方法之一而存在，从而在某种程度上 保证了类型的不变性。</p><p>只要定义了任何一个内部构造方法，就不会再提供默认的构造方法：Julia 假定你已经为自己 提供了所需的所有内部构造方法。默认构造方法等效于一个你自己编写的内部构造函数方法， 该方法将所有对象的字段作为参数（如果相应的字段具有类型，则约束为正确的类型）， 并将它们传递给 <code>new</code>，返回结果对象：</p><pre><code class="language-julia-repl">julia&gt; struct Foo
           bar
           baz
           Foo(bar,baz) = new(bar,baz)
       end
</code></pre><p>这个声明与前面没有显式内部构造方法的 <code>Foo</code> 类型的定义效果相同。 以下两个类型是等价的 – 一个具有默认构造方法，另一个具有显式构造方法：</p><pre><code class="language-julia-repl">julia&gt; struct T1
           x::Int64
       end

julia&gt; struct T2
           x::Int64
           T2(x) = new(x)
       end

julia&gt; T1(1)
T1(1)

julia&gt; T2(1)
T2(1)

julia&gt; T1(1.0)
T1(1)

julia&gt; T2(1.0)
T2(1)</code></pre><p>It is considered good form to provide as few inner constructor methods as possible: only those taking all arguments explicitly and enforcing essential error checking and transformation. Additional convenience constructor methods, supplying default values or auxiliary transformations, should be provided as outer constructors that call the inner constructors to do the heavy lifting. This separation is typically quite natural.</p><h2><a class="nav-anchor" id="Incomplete-Initialization-1" href="#Incomplete-Initialization-1">Incomplete Initialization</a></h2><p>The final problem which has still not been addressed is construction of self-referential objects, or more generally, recursive data structures. Since the fundamental difficulty may not be immediately obvious, let us briefly explain it. Consider the following recursive type declaration:</p><pre><code class="language-julia-repl">julia&gt; mutable struct SelfReferential
           obj::SelfReferential
       end
</code></pre><p>This type may appear innocuous enough, until one considers how to construct an instance of it. If <code>a</code> is an instance of <code>SelfReferential</code>, then a second instance can be created by the call:</p><pre><code class="language-julia-repl">julia&gt; b = SelfReferential(a)</code></pre><p>But how does one construct the first instance when no instance exists to provide as a valid value for its <code>obj</code> field? The only solution is to allow creating an incompletely initialized instance of <code>SelfReferential</code> with an unassigned <code>obj</code> field, and using that incomplete instance as a valid value for the <code>obj</code> field of another instance, such as, for example, itself.</p><p>To allow for the creation of incompletely initialized objects, Julia allows the <a href="../../base/base/#new"><code>new</code></a> function to be called with fewer than the number of fields that the type has, returning an object with the unspecified fields uninitialized. The inner constructor method can then use the incomplete object, finishing its initialization before returning it. Here, for example, we take another crack at defining the <code>SelfReferential</code> type, with a zero-argument inner constructor returning instances having <code>obj</code> fields pointing to themselves:</p><pre><code class="language-julia-repl">julia&gt; mutable struct SelfReferential
           obj::SelfReferential
           SelfReferential() = (x = new(); x.obj = x)
       end
</code></pre><p>We can verify that this constructor works and constructs objects that are, in fact, self-referential:</p><pre><code class="language-julia-repl">julia&gt; x = SelfReferential();

julia&gt; x === x
true

julia&gt; x === x.obj
true

julia&gt; x === x.obj.obj
true</code></pre><p>Although it is generally a good idea to return a fully initialized object from an inner constructor, incompletely initialized objects can be returned:</p><pre><code class="language-julia-repl">julia&gt; mutable struct Incomplete
           xx
           Incomplete() = new()
       end

julia&gt; z = Incomplete();</code></pre><p>While you are allowed to create objects with uninitialized fields, any access to an uninitialized reference is an immediate error:</p><pre><code class="language-julia-repl">julia&gt; z.xx
ERROR: UndefRefError: access to undefined reference</code></pre><p>This avoids the need to continually check for <code>null</code> values. However, not all object fields are references. Julia considers some types to be &quot;plain data&quot;, meaning all of their data is self-contained and does not reference other objects. The plain data types consist of primitive types (e.g. <code>Int</code>) and immutable structs of other plain data types. The initial contents of a plain data type is undefined:</p><pre><code class="language-julia-repl">julia&gt; struct HasPlain
           n::Int
           HasPlain() = new()
       end

julia&gt; HasPlain()
HasPlain(438103441441)</code></pre><p>Arrays of plain data types exhibit the same behavior.</p><p>You can pass incomplete objects to other functions from inner constructors to delegate their completion:</p><pre><code class="language-julia-repl">julia&gt; mutable struct Lazy
           xx
           Lazy(v) = complete_me(new(), v)
       end</code></pre><p>As with incomplete objects returned from constructors, if <code>complete_me</code> or any of its callees try to access the <code>xx</code> field of the <code>Lazy</code> object before it has been initialized, an error will be thrown immediately.</p><h2><a class="nav-anchor" id="Parametric-Constructors-1" href="#Parametric-Constructors-1">Parametric Constructors</a></h2><p>Parametric types add a few wrinkles to the constructor story. Recall from <a href="../types/#Parametric-Types-1">Parametric Types</a> that, by default, instances of parametric composite types can be constructed either with explicitly given type parameters or with type parameters implied by the types of the arguments given to the constructor. Here are some examples:</p><pre><code class="language-julia-repl">julia&gt; struct Point{T&lt;:Real}
           x::T
           y::T
       end

julia&gt; Point(1,2) ## implicit T ##
Point{Int64}(1, 2)

julia&gt; Point(1.0,2.5) ## implicit T ##
Point{Float64}(1.0, 2.5)

julia&gt; Point(1,2.5) ## implicit T ##
ERROR: MethodError: no method matching Point(::Int64, ::Float64)
Closest candidates are:
  Point(::T&lt;:Real, ::T&lt;:Real) where T&lt;:Real at none:2

julia&gt; Point{Int64}(1, 2) ## explicit T ##
Point{Int64}(1, 2)

julia&gt; Point{Int64}(1.0,2.5) ## explicit T ##
ERROR: InexactError: Int64(Int64, 2.5)
Stacktrace:
[...]

julia&gt; Point{Float64}(1.0, 2.5) ## explicit T ##
Point{Float64}(1.0, 2.5)

julia&gt; Point{Float64}(1,2) ## explicit T ##
Point{Float64}(1.0, 2.0)</code></pre><p>As you can see, for constructor calls with explicit type parameters, the arguments are converted to the implied field types: <code>Point{Int64}(1,2)</code> works, but <code>Point{Int64}(1.0,2.5)</code> raises an <a href="../../base/base/#Core.InexactError"><code>InexactError</code></a> when converting <code>2.5</code> to <a href="../../base/numbers/#Core.Int64"><code>Int64</code></a>. When the type is implied by the arguments to the constructor call, as in <code>Point(1,2)</code>, then the types of the arguments must agree – otherwise the <code>T</code> cannot be determined – but any pair of real arguments with matching type may be given to the generic <code>Point</code> constructor.</p><p>What&#39;s really going on here is that <code>Point</code>, <code>Point{Float64}</code> and <code>Point{Int64}</code> are all different constructor functions. In fact, <code>Point{T}</code> is a distinct constructor function for each type <code>T</code>. Without any explicitly provided inner constructors, the declaration of the composite type <code>Point{T&lt;:Real}</code> automatically provides an inner constructor, <code>Point{T}</code>, for each possible type <code>T&lt;:Real</code>, that behaves just like non-parametric default inner constructors do. It also provides a single general outer <code>Point</code> constructor that takes pairs of real arguments, which must be of the same type. This automatic provision of constructors is equivalent to the following explicit declaration:</p><pre><code class="language-julia-repl">julia&gt; struct Point{T&lt;:Real}
           x::T
           y::T
           Point{T}(x,y) where {T&lt;:Real} = new(x,y)
       end

julia&gt; Point(x::T, y::T) where {T&lt;:Real} = Point{T}(x,y);</code></pre><p>Notice that each definition looks like the form of constructor call that it handles. The call <code>Point{Int64}(1,2)</code> will invoke the definition <code>Point{T}(x,y)</code> inside the <code>struct</code> block. The outer constructor declaration, on the other hand, defines a method for the general <code>Point</code> constructor which only applies to pairs of values of the same real type. This declaration makes constructor calls without explicit type parameters, like <code>Point(1,2)</code> and <code>Point(1.0,2.5)</code>, work. Since the method declaration restricts the arguments to being of the same type, calls like <code>Point(1,2.5)</code>, with arguments of different types, result in &quot;no method&quot; errors.</p><p>Suppose we wanted to make the constructor call <code>Point(1,2.5)</code> work by &quot;promoting&quot; the integer value <code>1</code> to the floating-point value <code>1.0</code>. The simplest way to achieve this is to define the following additional outer constructor method:</p><pre><code class="language-julia-repl">julia&gt; Point(x::Int64, y::Float64) = Point(convert(Float64,x),y);</code></pre><p>This method uses the <a href="../../base/base/#Base.convert"><code>convert</code></a> function to explicitly convert <code>x</code> to <a href="../../base/numbers/#Core.Float64"><code>Float64</code></a> and then delegates construction to the general constructor for the case where both arguments are <a href="../../base/numbers/#Core.Float64"><code>Float64</code></a>. With this method definition what was previously a <a href="../../base/base/#Core.MethodError"><code>MethodError</code></a> now successfully creates a point of type <code>Point{Float64}</code>:</p><pre><code class="language-julia-repl">julia&gt; Point(1,2.5)
Point{Float64}(1.0, 2.5)

julia&gt; typeof(ans)
Point{Float64}</code></pre><p>However, other similar calls still don&#39;t work:</p><pre><code class="language-julia-repl">julia&gt; Point(1.5,2)
ERROR: MethodError: no method matching Point(::Float64, ::Int64)
Closest candidates are:
  Point(::T&lt;:Real, !Matched::T&lt;:Real) where T&lt;:Real at none:1</code></pre><p>For a more general way to make all such calls work sensibly, see <a href="../conversion-and-promotion/#conversion-and-promotion-1">Conversion and Promotion</a>. At the risk of spoiling the suspense, we can reveal here that all it takes is the following outer method definition to make all calls to the general <code>Point</code> constructor work as one would expect:</p><pre><code class="language-julia-repl">julia&gt; Point(x::Real, y::Real) = Point(promote(x,y)...);</code></pre><p>The <code>promote</code> function converts all its arguments to a common type – in this case <a href="../../base/numbers/#Core.Float64"><code>Float64</code></a>. With this method definition, the <code>Point</code> constructor promotes its arguments the same way that numeric operators like <a href="../../base/math/#Base.:+"><code>+</code></a> do, and works for all kinds of real numbers:</p><pre><code class="language-julia-repl">julia&gt; Point(1.5,2)
Point{Float64}(1.5, 2.0)

julia&gt; Point(1,1//2)
Point{Rational{Int64}}(1//1, 1//2)

julia&gt; Point(1.0,1//2)
Point{Float64}(1.0, 0.5)</code></pre><p>Thus, while the implicit type parameter constructors provided by default in Julia are fairly strict, it is possible to make them behave in a more relaxed but sensible manner quite easily. Moreover, since constructors can leverage all of the power of the type system, methods, and multiple dispatch, defining sophisticated behavior is typically quite simple.</p><h2><a class="nav-anchor" id="Case-Study:-Rational-1" href="#Case-Study:-Rational-1">Case Study: Rational</a></h2><p>Perhaps the best way to tie all these pieces together is to present a real world example of a parametric composite type and its constructor methods. To that end, we implement our own rational number type <code>OurRational</code>, similar to Julia&#39;s built-in <a href="../../base/numbers/#Base.Rational"><code>Rational</code></a> type, defined in <a href="https://github.com/JuliaLang/julia/blob/master/base/rational.jl"><code>rational.jl</code></a>:</p><pre><code class="language-julia-repl">julia&gt; struct OurRational{T&lt;:Integer} &lt;: Real
           num::T
           den::T
           function OurRational{T}(num::T, den::T) where T&lt;:Integer
               if num == 0 &amp;&amp; den == 0
                    error(&quot;invalid rational: 0//0&quot;)
               end
               g = gcd(den, num)
               num = div(num, g)
               den = div(den, g)
               new(num, den)
           end
       end

julia&gt; OurRational(n::T, d::T) where {T&lt;:Integer} = OurRational{T}(n,d)
OurRational

julia&gt; OurRational(n::Integer, d::Integer) = OurRational(promote(n,d)...)
OurRational

julia&gt; OurRational(n::Integer) = OurRational(n,one(n))
OurRational

julia&gt; ⊘(n::Integer, d::Integer) = OurRational(n,d)
⊘ (generic function with 1 method)

julia&gt; ⊘(x::OurRational, y::Integer) = x.num ⊘ (x.den*y)
⊘ (generic function with 2 methods)

julia&gt; ⊘(x::Integer, y::OurRational) = (x*y.den) ⊘ y.num
⊘ (generic function with 3 methods)

julia&gt; ⊘(x::Complex, y::Real) = complex(real(x) ⊘ y, imag(x) ⊘ y)
⊘ (generic function with 4 methods)

julia&gt; ⊘(x::Real, y::Complex) = (x*y&#39;) ⊘ real(y*y&#39;)
⊘ (generic function with 5 methods)

julia&gt; function ⊘(x::Complex, y::Complex)
           xy = x*y&#39;
           yy = real(y*y&#39;)
           complex(real(xy) ⊘ yy, imag(xy) ⊘ yy)
       end
⊘ (generic function with 6 methods)</code></pre><p>The first line – <code>struct OurRational{T&lt;:Integer} &lt;: Real</code> – declares that <code>OurRational</code> takes one type parameter of an integer type, and is itself a real type. The field declarations <code>num::T</code> and <code>den::T</code> indicate that the data held in a <code>OurRational{T}</code> object are a pair of integers of type <code>T</code>, one representing the rational value&#39;s numerator and the other representing its denominator.</p><p>Now things get interesting. <code>OurRational</code> has a single inner constructor method which checks that both of <code>num</code> and <code>den</code> aren&#39;t zero and ensures that every rational is constructed in &quot;lowest terms&quot; with a non-negative denominator. This is accomplished by dividing the given numerator and denominator values by their greatest common divisor, computed using the <code>gcd</code> function. Since <code>gcd</code> returns the greatest common divisor of its arguments with sign matching the first argument (<code>den</code> here), after this division the new value of <code>den</code> is guaranteed to be non-negative. Because this is the only inner constructor for <code>OurRational</code>, we can be certain that <code>OurRational</code> objects are always constructed in this normalized form.</p><p><code>OurRational</code> also provides several outer constructor methods for convenience. The first is the &quot;standard&quot; general constructor that infers the type parameter <code>T</code> from the type of the numerator and denominator when they have the same type. The second applies when the given numerator and denominator values have different types: it promotes them to a common type and then delegates construction to the outer constructor for arguments of matching type. The third outer constructor turns integer values into rationals by supplying a value of <code>1</code> as the denominator.</p><p>Following the outer constructor definitions, we defined a number of methods for the <code>⊘</code> operator, which provides a syntax for writing rationals (e.g. <code>1 ⊘ 2</code>). Julia&#39;s <code>Rational</code> type uses the <a href="../../base/math/#Base.://"><code>//</code></a> operator for this purpose. Before these definitions, <code>⊘</code> is a completely undefined operator with only syntax and no meaning. Afterwards, it behaves just as described in <a href="manual/@ref">Rational Numbers</a> – its entire behavior is defined in these few lines. The first and most basic definition just makes <code>a ⊘ b</code> construct a <code>OurRational</code> by applying the <code>OurRational</code> constructor to <code>a</code> and <code>b</code> when they are integers. When one of the operands of <code>⊘</code> is already a rational number, we construct a new rational for the resulting ratio slightly differently; this behavior is actually identical to division of a rational with an integer. Finally, applying <code>⊘</code> to complex integral values creates an instance of <code>Complex{OurRational}</code> – a complex number whose real and imaginary parts are rationals:</p><pre><code class="language-julia-repl">julia&gt; z = (1 + 2im) ⊘ (1 - 2im);

julia&gt; typeof(z)
Complex{OurRational{Int64}}

julia&gt; typeof(z) &lt;: Complex{OurRational}
false</code></pre><p>Thus, although the <code>⊘</code> operator usually returns an instance of <code>OurRational</code>, if either of its arguments are complex integers, it will return an instance of <code>Complex{OurRational}</code> instead. The interested reader should consider perusing the rest of <a href="https://github.com/JuliaLang/julia/blob/master/base/rational.jl"><code>rational.jl</code></a>: it is short, self-contained, and implements an entire basic Julia type.</p><h2><a class="nav-anchor" id="Outer-only-constructors-1" href="#Outer-only-constructors-1">Outer-only constructors</a></h2><p>As we have seen, a typical parametric type has inner constructors that are called when type parameters are known; e.g. they apply to <code>Point{Int}</code> but not to <code>Point</code>. Optionally, outer constructors that determine type parameters automatically can be added, for example constructing a <code>Point{Int}</code> from the call <code>Point(1,2)</code>. Outer constructors call inner constructors to do the core work of making an instance. However, in some cases one would rather not provide inner constructors, so that specific type parameters cannot be requested manually.</p><p>For example, say we define a type that stores a vector along with an accurate representation of its sum:</p><pre><code class="language-julia-repl">julia&gt; struct SummedArray{T&lt;:Number,S&lt;:Number}
           data::Vector{T}
           sum::S
       end

julia&gt; SummedArray(Int32[1; 2; 3], Int32(6))
SummedArray{Int32,Int32}(Int32[1, 2, 3], 6)</code></pre><p>The problem is that we want <code>S</code> to be a larger type than <code>T</code>, so that we can sum many elements with less information loss. For example, when <code>T</code> is <a href="../../base/numbers/#Core.Int32"><code>Int32</code></a>, we would like <code>S</code> to be <a href="../../base/numbers/#Core.Int64"><code>Int64</code></a>. Therefore we want to avoid an interface that allows the user to construct instances of the type <code>SummedArray{Int32,Int32}</code>. One way to do this is to provide a constructor only for <code>SummedArray</code>, but inside the <code>struct</code> definition block to suppress generation of default constructors:</p><pre><code class="language-julia-repl">julia&gt; struct SummedArray{T&lt;:Number,S&lt;:Number}
           data::Vector{T}
           sum::S
           function SummedArray(a::Vector{T}) where T
               S = widen(T)
               new{T,S}(a, sum(S, a))
           end
       end

julia&gt; SummedArray(Int32[1; 2; 3], Int32(6))
ERROR: MethodError: no method matching SummedArray(::Array{Int32,1}, ::Int32)
Closest candidates are:
  SummedArray(::Array{T,1}) where T at none:5</code></pre><p>This constructor will be invoked by the syntax <code>SummedArray(a)</code>. The syntax <code>new{T,S}</code> allows specifying parameters for the type to be constructed, i.e. this call will return a <code>SummedArray{T,S}</code>. <code>new{T,S}</code> can be used in any constructor definition, but for convenience the parameters to <code>new{}</code> are automatically derived from the type being constructed when possible.</p><footer><hr/><a class="previous" href="../methods/"><span class="direction">Previous</span><span class="title">方法</span></a><a class="next" href="../conversion-and-promotion/"><span class="direction">Next</span><span class="title">类型转换和类型提升</span></a></footer></article></body></html>
