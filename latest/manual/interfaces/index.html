<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>接口 · Julia中文文档</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-89508993-1', 'auto');
ga('send', 'pageview');
</script><link rel="canonical" href="https://juliacn.github.io/JuliaZH.jl/latest/manual/interfaces/index.html"/><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../../assets/julia-manual.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../../index.html"><img class="logo" src="../../assets/logo.png" alt="Julia中文文档 logo"/></a><h1>Julia中文文档</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">主页</a></li><li><span class="toctext">手册</span><ul><li><a class="toctext" href="../getting-started/">入门</a></li><li><a class="toctext" href="../variables/">变量</a></li><li><a class="toctext" href="../integers-and-floating-point-numbers/">整数和浮点数</a></li><li><a class="toctext" href="../mathematical-operations/">数学运算和初等函数</a></li><li><a class="toctext" href="../complex-and-rational-numbers/">复数和分数</a></li><li><a class="toctext" href="../strings/">字符串</a></li><li><a class="toctext" href="../functions/">函数</a></li><li><a class="toctext" href="../control-flow/">流程控制</a></li><li><a class="toctext" href="../variables-and-scoping/">变量作用域</a></li><li><a class="toctext" href="../types/">类型</a></li><li><a class="toctext" href="../methods/">方法</a></li><li><a class="toctext" href="../constructors/">构造函数</a></li><li><a class="toctext" href="../conversion-and-promotion/">类型转换和类型提升</a></li><li class="current"><a class="toctext" href>接口</a><ul class="internal"><li><a class="toctext" href="#man-interface-iteration-1">Iteration</a></li><li class="toplevel"><a class="toctext" href="#output-1">output</a></li><li class="toplevel"><a class="toctext" href="#output-2">output</a></li><li class="toplevel"><a class="toctext" href="#output-3">output</a></li></ul></li><li><a class="toctext" href="../modules/">模块</a></li><li><a class="toctext" href="../documentation/">文档</a></li><li><a class="toctext" href="../metaprogramming/">Metaprogramming</a></li><li><a class="toctext" href="../arrays/">多维数组</a></li><li><a class="toctext" href="../missing/">缺失值</a></li><li><a class="toctext" href="../networking-and-streams/">网络和流</a></li><li><a class="toctext" href="../parallel-computing/">并行计算</a></li><li><a class="toctext" href="../running-external-programs/">运行外部程序</a></li><li><a class="toctext" href="../calling-c-and-fortran-code/">调用 C 和 Fortran 代码</a></li><li><a class="toctext" href="../handling-operating-system-variation/">处理操作系统差异</a></li><li><a class="toctext" href="../environment-variables/">环境变量</a></li><li><a class="toctext" href="../embedding/">嵌入 Julia</a></li><li><a class="toctext" href="../code-loading/">代码加载</a></li><li><a class="toctext" href="../profile/">分析</a></li><li><a class="toctext" href="../stacktraces/">堆栈跟踪</a></li><li><a class="toctext" href="../performance-tips/">性能建议</a></li><li><a class="toctext" href="../workflow-tips/">工作流程建议</a></li><li><a class="toctext" href="../style-guide/">代码风格指南</a></li><li><a class="toctext" href="../faq/">常见问题</a></li><li><a class="toctext" href="../noteworthy-differences/">与其他语言的显著差异</a></li><li><a class="toctext" href="../unicode-input/">Unicode 输入表</a></li></ul></li><li><span class="toctext">Base</span><ul><li><a class="toctext" href="../../base/base/">基本功能</a></li><li><a class="toctext" href="../../base/collections/">集合和数据结构</a></li><li><a class="toctext" href="../../base/math/">数学相关</a></li><li><a class="toctext" href="../../base/numbers/">Numbers</a></li><li><a class="toctext" href="../../base/strings/">字符串</a></li><li><a class="toctext" href="../../base/arrays/">Arrays</a></li><li><a class="toctext" href="../../base/parallel/">Tasks</a></li><li><a class="toctext" href="../../base/multi-threading/">多线程</a></li><li><a class="toctext" href="../../base/constants/">常量</a></li><li><a class="toctext" href="../../base/file/">文件系统</a></li><li><a class="toctext" href="../../base/io-network/">I/O 与网络</a></li><li><a class="toctext" href="../../base/punctuation/">标点符号</a></li><li><a class="toctext" href="../../base/sort/">排序及相关函数</a></li><li><a class="toctext" href="../../base/iterators/">迭代相关</a></li><li><a class="toctext" href="../../base/c/">C 接口</a></li><li><a class="toctext" href="../../base/libc/">C 标准库</a></li><li><a class="toctext" href="../../base/stacktraces/">StackTraces</a></li><li><a class="toctext" href="../../base/simd-types/">SIMD 支持</a></li></ul></li><li><span class="toctext">Standard Library</span><ul><li><a class="toctext" href="../../stdlib/Base64/">Base64</a></li><li><a class="toctext" href="../../stdlib/CRC32c/">CRC32c</a></li><li><a class="toctext" href="../../stdlib/Dates/">Dates</a></li><li><a class="toctext" href="../../stdlib/DelimitedFiles/">Delimited Files</a></li><li><a class="toctext" href="../../stdlib/Distributed/">Distributed Computing</a></li><li><a class="toctext" href="../../stdlib/FileWatching/">File Events</a></li><li><a class="toctext" href="../../stdlib/InteractiveUtils/">Interactive Utilities</a></li><li><a class="toctext" href="../../stdlib/LibGit2/">LibGit2</a></li><li><a class="toctext" href="../../stdlib/Libdl/">Dynamic Linker</a></li><li><a class="toctext" href="../../stdlib/LinearAlgebra/">Linear Algebra</a></li><li><a class="toctext" href="../../stdlib/Logging/">Logging</a></li><li><a class="toctext" href="../../stdlib/Markdown/">Markdown</a></li><li><a class="toctext" href="../../stdlib/Mmap/">Memory-mapped I/O</a></li><li><a class="toctext" href="../../stdlib/Pkg/">Pkg</a></li><li><a class="toctext" href="../../stdlib/Printf/">Printf</a></li><li><a class="toctext" href="../../stdlib/Profile/">Profiling</a></li><li><a class="toctext" href="../../stdlib/REPL/">The Julia REPL</a></li><li><a class="toctext" href="../../stdlib/Random/">Random Numbers</a></li><li><a class="toctext" href="../../stdlib/SHA/">SHA</a></li><li><a class="toctext" href="../../stdlib/Serialization/">Serialization</a></li><li><a class="toctext" href="../../stdlib/SharedArrays/">Shared Arrays</a></li><li><a class="toctext" href="../../stdlib/Sockets/">Sockets</a></li><li><a class="toctext" href="../../stdlib/SparseArrays/">Sparse Arrays</a></li><li><a class="toctext" href="../../stdlib/Statistics/">Statistics</a></li><li><a class="toctext" href="../../stdlib/Test/">Unit Testing</a></li><li><a class="toctext" href="../../stdlib/UUIDs/">UUIDs</a></li><li><a class="toctext" href="../../stdlib/Unicode/">Unicode</a></li></ul></li><li><span class="toctext">Developer Documentation</span><ul><li><a class="toctext" href="../../devdocs/reflection/">反射 与 自我检查</a></li><li><span class="toctext">Documentation of Julia&#39;s Internals</span><ul><li><a class="toctext" href="../../devdocs/init/">Julia 运行时的初始化</a></li><li><a class="toctext" href="../../devdocs/ast/">Julia 的 AST</a></li><li><a class="toctext" href="../../devdocs/types/">More about types</a></li><li><a class="toctext" href="../../devdocs/object/">Memory layout of Julia Objects</a></li><li><a class="toctext" href="../../devdocs/eval/">Eval of Julia code</a></li><li><a class="toctext" href="../../devdocs/callconv/">Calling Conventions</a></li><li><a class="toctext" href="../../devdocs/compiler/">High-level Overview of the Native-Code Generation Process</a></li><li><a class="toctext" href="../../devdocs/functions/">Julia的相关函数</a></li><li><a class="toctext" href="../../devdocs/cartesian/">Base.Cartesian</a></li><li><a class="toctext" href="../../devdocs/meta/">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="toctext" href="../../devdocs/subarrays/">SubArrays</a></li><li><a class="toctext" href="../../devdocs/isbitsunionarrays/">isbits Union Optimizations</a></li><li><a class="toctext" href="../../devdocs/sysimg/">System Image Building</a></li><li><a class="toctext" href="../../devdocs/llvm/">Working with LLVM</a></li><li><a class="toctext" href="../../devdocs/stdio/">printf() and stdio in the Julia runtime</a></li><li><a class="toctext" href="../../devdocs/boundscheck/">边界检查</a></li><li><a class="toctext" href="../../devdocs/locks/">Proper maintenance and care of multi-threading locks</a></li><li><a class="toctext" href="../../devdocs/offset-arrays/">Arrays with custom indices</a></li><li><a class="toctext" href="../../devdocs/require/">Module loading</a></li><li><a class="toctext" href="../../devdocs/inference/">Inference</a></li></ul></li><li><span class="toctext">Developing/debugging Julia&#39;s C code</span><ul><li><a class="toctext" href="../../devdocs/backtraces/">Reporting and analyzing crashes (segfaults)</a></li><li><a class="toctext" href="../../devdocs/debuggingtips/">gdb 调试提示</a></li><li><a class="toctext" href="../../devdocs/valgrind/">Using Valgrind with Julia</a></li><li><a class="toctext" href="../../devdocs/sanitizers/">Sanitizer support</a></li></ul></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>手册</li><li><a href>接口</a></li></ul><a class="edit-page" href="https://github.com/JuliaCN/JuliaZH.jl/blob/master/doc/src/manual/interfaces.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>接口</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="接口-1" href="#接口-1">接口</a></h1><p>Julia的很多能力和扩展性都来自于一些非正式的接口。 通过为自定义的类型及其对象扩展一些特定的方法， 可以不但获得它们的功能， 而且使它们能够被用到其它的基于它们的行为而定义的通用方法中。</p><h2><a class="nav-anchor" id="man-interface-iteration-1" href="#man-interface-iteration-1">Iteration</a></h2><table><tr><th>必须方法</th><th></th><th>简短描述</th></tr><tr><td><code>iterate(iter)</code></td><td></td><td>通常返回由第一项及其其初始状态组成的元组，但如果是空，则要么返回<a href="../../base/constants/#Core.nothing"><code>nothing</code></a></td></tr><tr><td><code>iterate(iter, state)</code></td><td></td><td>通常返回由下一项及其状态组成的元组，或者在没有下一项存在时返回<a href="../../base/constants/#Core.nothing"><code>nothing</code></a>。</td></tr><tr><td><strong>重要可选方法</strong></td><td><strong>默认定义</strong></td><td><strong>简短描述</strong></td></tr><tr><td><code>IteratorSize(IterType)</code></td><td><code>HasLength()</code></td><td><code>HasLength()</code> ， <code>HasShape{N}()</code> ，  <code>IsInfinite()</code> ， 或者 <code>SizeUnknown()</code> 作为合适的</td></tr><tr><td><code>IteratorEltype(IterType)</code></td><td><code>HasEltype()</code></td><td><code>EltypeUnknown()</code>  和 <code>HasEltype()</code>  都是可接受的</td></tr><tr><td><code>eltype(IterType)</code></td><td><code>Any</code></td><td>元组中第一个条目的类型由 <code>iterate()</code> 返回。</td></tr><tr><td><code>length(iter)</code></td><td>(<em>未定义</em>)</td><td>The number of items, if known</td></tr><tr><td><code>size(iter, [dim...])</code></td><td>(<em>未定义</em>)</td><td>在各个维度上条目的数量，如果知道</td></tr></table><table><tr><th><code>IteratorSize(IterType)</code> 返回的值。</th><th>必须方法</th></tr><tr><td><code>HasLength()</code></td><td><a href="../../base/strings/#Base.length-Tuple{AbstractString}"><code>length(iter)</code></a></td></tr><tr><td><code>HasShape{N}()</code></td><td><code>length(iter)</code>  and <code>size(iter, [dim...])</code></td></tr><tr><td><code>IsInfinite()</code></td><td>(<em>none</em>)</td></tr><tr><td><code>SizeUnknown()</code></td><td>(<em>none</em>)</td></tr></table><table><tr><th>由 <code>IteratorEltype(IterType)</code> 返回的值</th><th>必须方法</th></tr><tr><td><code>HasEltype()</code></td><td><code>eltype(IterType)</code></td></tr><tr><td><code>EltypeUnknown()</code></td><td>(<em>none</em>)</td></tr></table><p>顺序迭代由  <a href="../../base/collections/#Base.iterate"><code>iterate</code></a> 函数实现.  Julia的迭代器可以从目标外部跟踪迭代状态，而不是在迭代过程中改变目标本身。 迭代过程中的返回一个包含了当前迭代值及其状态的元组，或者在没有元素存在的情况下返回  <code>nothing</code>  。 状态对象将在下一次迭代时传递回迭代函数 并且通常被认为是可迭代对象的私有实现细节。</p><p>任何定义了这个函数的兑现个都是可迭代的，并且可以被应用到  <a href="../../base/collections/#lib-collections-iteration-1">many functions that rely upon iteration</a> 。 也可以直接被应用到  <a href="../../base/base/#for"><code>for</code></a> 循环中，因为根据语法：</p><pre><code class="language-julia">for i in iter   # or  &quot;for i = iter&quot;
    # body
end</code></pre><p>被解释为：</p><pre><code class="language-julia">next = iterate(iter)
while next !== nothing
    (i, state) = next
    # body
    next = iterate(iter, state)
end</code></pre><p>一个简单的例子是一组定长数据的平方数迭代序列：</p><pre><code class="language-julia-repl">julia&gt; struct Squares
           count::Int
       end

julia&gt; Base.iterate(S::Squares, state=1) = state &gt; S.count ? nothing : (state*state, state+1)</code></pre><p>仅仅定义了  <a href="../../base/collections/#Base.iterate"><code>iterate</code></a> 函数的 <code>Squares</code> 类型就已经很强大了。 我们现在可以迭代所有的元素了：</p><pre><code class="language-julia-repl">julia&gt; for i in Squares(7)
           println(i)
       end
1
4
9
16
25
36
49</code></pre><p>我们可以利用许多内置方法来处理迭代，比如标准库 <code>Statistics</code>  中的  <a href="../../base/collections/#Base.in"><code>in</code></a> ， <a href="../../stdlib/Statistics/#Statistics.mean"><code>mean</code></a> 和 <a href="../../stdlib/Statistics/#Statistics.std"><code>std</code></a> 。</p><pre><code class="language-julia-repl">julia&gt; 25 in Squares(10)
true

julia&gt; using Statistics

julia&gt; mean(Squares(100))
3383.5

julia&gt; std(Squares(100))
3024.355854282583
我们可以扩展一些其它的方法，为Julia提供有关此可迭代集合的更多信息。
我们知道 `Squares`  序列中的元素总是  `Int` 型的。
通过扩展  [`eltype`](@ref)  方法，  我们可以给Julia过多的信息来帮助其在更复杂的方法中产生更加具体的代码。
我们同时也知道我们序列中的元素数目，所以我们也同样可以扩展  [`length`](@ref) ：
</code></pre><p>jldoctest squaretype julia&gt; Base.eltype(::Type{Squares}) = Int # Note that this is defined for the type</p><p>julia&gt; Base.length(S::Squares) = S.count</p><pre><code class="language-none">
现在，当我们让Julia去  [`collect`](@ref) 所有元素到一个array中时，Julia可以预分配一个 适当大小的  `Vector{Int}` ，而不是盲目地  [`push!`](@ref) 每一个元素到 `Vector{Any}` ：
</code></pre><p>jldoctest squaretype julia&gt; collect(Squares(4)) 4-element Array{Int64,1}:   1   4   9  16</p><pre><code class="language-none">
尽管大多时候我们都可以依赖于一些通用的实现，某些时候如果我们知道有一个更简单的算法的话，可以扩展出更具体的实现。例如，计算平方和有一个公式，因此可以扩展出一个更高效的实现：
</code></pre><p>jldoctest squaretype julia&gt; Base.sum(S::Squares) = (n = S.count; return n<em>(n+1)</em>(2n+1)÷6)</p><p>julia&gt; sum(Squares(1803)) 1955361914</p><pre><code class="language-none">
这种模式在Julia Base中很常见，一些必须实现的方法构成了一个小的集合，从而定义出一个非正式的接口，用于实现一些非常炫酷的操作。某些时候，类型本身知道在其应用场景中有一些更高效的算法，因而可以扩展出额外方法。

It is also often useful to allow iteration over a collection in *reverse order*
by iterating over [`Iterators.reverse(iterator)`](@ref).  To actually support
reverse-order iteration, however, an iterator
type `T` needs to implement `iterate` for `Iterators.Reverse{T}`.
(Given `r::Iterators.Reverse{T}`, the underling iterator of type `T` is `r.itr`.)
In our `Squares` example, we would implement `Iterators.Reverse{Squares}` methods:
</code></pre><p>jldoctest squaretype julia&gt; Base.iterate(rS::Iterators.Reverse{Squares}, state=rS.itr.count) = state &lt; 1 ? nothing : (state*state, state-1)</p><p>julia&gt; collect(Iterators.reverse(Squares(4))) 4-element Array{Int64,1}:  16   9   4   1</p><pre><code class="language-none">
## 索引

| 需要实现的方法 | 简介                |
|:-------------------- |:-------------------------------- |
| `getindex(X, i)`     | `X[i]`, indexed element access   |
| `setindex!(X, v, i)` | `X[i] = v`, indexed assignment   |
| `firstindex(X)`      | The first index                  |
| `lastindex(X)`        | The last index, used in `X[end]` |

对于 `Squares` 类型而言，可以通过对第 `i` 个元素求平方计算出其中的第 `i` 个元素，可以用 `S[i]` 的索引表达式形式暴露该接口。为了支持该行为， `Squares` 只需要简单地定义 [`getindex`](@ref):
</code></pre><p>jldoctest squaretype julia&gt; function Base.getindex(S::Squares, i::Int)            1 &lt;= i &lt;= S.count || throw(BoundsError(S, i))            return i*i        end</p><p>julia&gt; Squares(100)[23] 529</p><pre><code class="language-none">
Additionally, to support the syntax `S[end]`, we must define [`lastindex`](@ref) to specify the last
valid index. It is recommended to also define [`firstindex`](@ref) to specify the first valid index:
</code></pre><p>jldoctest squaretype julia&gt; Base.firstindex(S::Squares) = 1</p><p>julia&gt; Base.lastindex(S::Squares) = length(S)</p><p>julia&gt; Squares(23)[end] 529</p><pre><code class="language-none">
Note, though, that the above *only* defines [`getindex`](@ref) with one integer index. Indexing with
anything other than an `Int` will throw a [`MethodError`](@ref) saying that there was no matching method.
In order to support indexing with ranges or vectors of `Int`s, separate methods must be written:
</code></pre><p>jldoctest squaretype julia&gt; Base.getindex(S::Squares, i::Number) = S[convert(Int, i)]</p><p>julia&gt; Base.getindex(S::Squares, I) = [S[i] for i in I]</p><p>julia&gt; Squares(10)[[3,4.,5]] 3-element Array{Int64,1}:   9  16  25</p><pre><code class="language-none">
While this is starting to support more of the [indexing operations supported by some of the builtin types](@ref man-array-indexing),
there&#39;s still quite a number of behaviors missing. This `Squares` sequence is starting to look
more and more like a vector as we&#39;ve added behaviors to it. Instead of defining all these behaviors
ourselves, we can officially define it as a subtype of an [`AbstractArray`](@ref).

## [Abstract Arrays](@id man-interface-array)

| Methods to implement                            |                                        | 简短描述                                                                     |
|:----------------------------------------------- |:-------------------------------------- |:------------------------------------------------------------------------------------- |
| `size(A)`                                       |                                        | Returns a tuple containing the dimensions of `A`                                      |
| `getindex(A, i::Int)`                           |                                        | (if `IndexLinear`) Linear scalar indexing                                             |
| `getindex(A, I::Vararg{Int, N})`                |                                        | (if `IndexCartesian`, where `N = ndims(A)`) N-dimensional scalar indexing             |
| `setindex!(A, v, i::Int)`                       |                                        | (if `IndexLinear`) Scalar indexed assignment                                          |
| `setindex!(A, v, I::Vararg{Int, N})`            |                                        | (if `IndexCartesian`, where `N = ndims(A)`) N-dimensional scalar indexed assignment   |
| **Optional methods**                            | **默认定义**                 | **简短描述**                                                                 |
| `IndexStyle(::Type)`                            | `IndexCartesian()`                     | Returns either `IndexLinear()` or `IndexCartesian()`. See the description below.      |
| `getindex(A, I...)`                             | defined in terms of scalar `getindex`  | [Multidimensional and nonscalar indexing](@ref man-array-indexing)                    |
| `setindex!(A, I...)`                            | defined in terms of scalar `setindex!` | [Multidimensional and nonscalar indexed assignment](@ref man-array-indexing)          |
| `iterate`                                       | defined in terms of scalar `getindex`  | Iteration                                                                             |
| `length(A)`                                     | `prod(size(A))`                        | Number of elements                                                                    |
| `similar(A)`                                    | `similar(A, eltype(A), size(A))`       | Return a mutable array with the same shape and element type                           |
| `similar(A, ::Type{S})`                         | `similar(A, S, size(A))`               | Return a mutable array with the same shape and the specified element type             |
| `similar(A, dims::NTuple{Int})`                 | `similar(A, eltype(A), dims)`          | Return a mutable array with the same element type and size *dims*                     |
| `similar(A, ::Type{S}, dims::NTuple{Int})`      | `Array{S}(undef, dims)`               | Return a mutable array with the specified element type and size                       |
| **Non-traditional indices**                     | **默认定义**                 | **简短描述**                                                                 |
| `axes(A)`                                    | `map(OneTo, size(A))`                  | Return the `AbstractUnitRange` of valid indices                                       |
| `Base.similar(A, ::Type{S}, inds::NTuple{Ind})` | `similar(A, S, Base.to_shape(inds))`   | Return a mutable array with the specified indices `inds` (see below)                  |
| `Base.similar(T::Union{Type,Function}, inds)`   | `T(Base.to_shape(inds))`               | Return an array similar to `T` with the specified indices `inds` (see below)          |

If a type is defined as a subtype of `AbstractArray`, it inherits a very large set of rich behaviors
including iteration and multidimensional indexing built on top of single-element access.  See
the [arrays manual page](@ref man-multi-dim-arrays) and the [Julia Base section](@ref lib-arrays) for more supported methods.

A key part in defining an `AbstractArray` subtype is [`IndexStyle`](@ref). Since indexing is
such an important part of an array and often occurs in hot loops, it&#39;s important to make both
indexing and indexed assignment as efficient as possible.  Array data structures are typically
defined in one of two ways: either it most efficiently accesses its elements using just one index
(linear indexing) or it intrinsically accesses the elements with indices specified for every dimension.
 These two modalities are identified by Julia as `IndexLinear()` and `IndexCartesian()`.
 Converting a linear index to multiple indexing subscripts is typically very expensive, so this
provides a traits-based mechanism to enable efficient generic code for all array types.

This distinction determines which scalar indexing methods the type must define. `IndexLinear()`
arrays are simple: just define `getindex(A::ArrayType, i::Int)`.  When the array is subsequently
indexed with a multidimensional set of indices, the fallback `getindex(A::AbstractArray, I...)()`
efficiently converts the indices into one linear index and then calls the above method. `IndexCartesian()`
arrays, on the other hand, require methods to be defined for each supported dimensionality with
`ndims(A)` `Int` indices. For example, [`SparseMatrixCSC`](@ref) from the `SparseArrays` standard
library module, only supports two dimensions, so it just defines
`getindex(A::SparseMatrixCSC, i::Int, j::Int)`. The same holds for [`setindex!`](@ref).

Returning to the sequence of squares from above, we could instead define it as a subtype of an
`AbstractArray{Int, 1}`:
</code></pre><p>jldoctest squarevectype julia&gt; struct SquaresVector &lt;: AbstractArray{Int, 1}            count::Int        end</p><p>julia&gt; Base.size(S::SquaresVector) = (S.count,)</p><p>julia&gt; Base.IndexStyle(::Type{&lt;:SquaresVector}) = IndexLinear()</p><p>julia&gt; Base.getindex(S::SquaresVector, i::Int) = i*i</p><pre><code class="language-none">
Note that it&#39;s very important to specify the two parameters of the `AbstractArray`; the first
defines the [`eltype`](@ref), and the second defines the [`ndims`](@ref). That supertype and those three
methods are all it takes for `SquaresVector` to be an iterable, indexable, and completely functional
array:
</code></pre><p>jldoctest squarevectype julia&gt; s = SquaresVector(4) 4-element SquaresVector:   1   4   9  16</p><p>julia&gt; s[s .&gt; 8] 2-element Array{Int64,1}:   9  16</p><p>julia&gt; s + s 4-element Array{Int64,1}:   2   8  18  32</p><p>julia&gt; sin.(s) 4-element Array{Float64,1}:   0.8414709848078965  -0.7568024953079282   0.4121184852417566  -0.2879033166650653</p><pre><code class="language-none">
As a more complicated example, let&#39;s define our own toy N-dimensional sparse-like array type built
on top of [`Dict`](@ref):
</code></pre><p>jldoctest squarevectype julia&gt; struct SparseArray{T,N} &lt;: AbstractArray{T,N}            data::Dict{NTuple{N,Int}, T}            dims::NTuple{N,Int}        end</p><p>julia&gt; SparseArray(::Type{T}, dims::Int...) where {T} = SparseArray(T, dims);</p><p>julia&gt; SparseArray(::Type{T}, dims::NTuple{N,Int}) where {T,N} = SparseArray{T,N}(Dict{NTuple{N,Int}, T}(), dims);</p><p>julia&gt; Base.size(A::SparseArray) = A.dims</p><p>julia&gt; Base.similar(A::SparseArray, ::Type{T}, dims::Dims) where {T} = SparseArray(T, dims)</p><p>julia&gt; Base.getindex(A::SparseArray{T,N}, I::Vararg{Int,N}) where {T,N} = get(A.data, I, zero(T))</p><p>julia&gt; Base.setindex!(A::SparseArray{T,N}, v, I::Vararg{Int,N}) where {T,N} = (A.data[I] = v)</p><pre><code class="language-none">
Notice that this is an `IndexCartesian` array, so we must manually define [`getindex`](@ref) and [`setindex!`](@ref)
at the dimensionality of the array. Unlike the `SquaresVector`, we are able to define [`setindex!`](@ref),
and so we can mutate the array:
</code></pre><p>jldoctest squarevectype julia&gt; A = SparseArray(Float64, 3, 3) 3×3 SparseArray{Float64,2}:  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0</p><p>julia&gt; fill!(A, 2) 3×3 SparseArray{Float64,2}:  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0</p><p>julia&gt; A[:] = 1:length(A); A 3×3 SparseArray{Float64,2}:  1.0  4.0  7.0  2.0  5.0  8.0  3.0  6.0  9.0</p><pre><code class="language-none">
The result of indexing an `AbstractArray` can itself be an array (for instance when indexing by
an `AbstractRange`). The `AbstractArray` fallback methods use [`similar`](@ref) to allocate an `Array`
of the appropriate size and element type, which is filled in using the basic indexing method described
above. However, when implementing an array wrapper you often want the result to be wrapped as
well:
</code></pre><p>jldoctest squarevectype julia&gt; A[1:2,:] 2×3 SparseArray{Float64,2}:  1.0  4.0  7.0  2.0  5.0  8.0</p><pre><code class="language-none">
In this example it is accomplished by defining `Base.similar{T}(A::SparseArray, ::Type{T}, dims::Dims)`
to create the appropriate wrapped array. (Note that while `similar` supports 1- and 2-argument
forms, in most case you only need to specialize the 3-argument form.) For this to work it&#39;s important
that `SparseArray` is mutable (supports `setindex!`). Defining `similar`, `getindex` and
`setindex!` for `SparseArray` also makes it possible to [`copy`](@ref) the array:
</code></pre><p>jldoctest squarevectype julia&gt; copy(A) 3×3 SparseArray{Float64,2}:  1.0  4.0  7.0  2.0  5.0  8.0  3.0  6.0  9.0</p><pre><code class="language-none">
In addition to all the iterable and indexable methods from above, these types can also interact
with each other and use most of the methods defined in Julia Base for `AbstractArrays`:
</code></pre><p>jldoctest squarevectype julia&gt; A[SquaresVector(3)] 3-element SparseArray{Float64,1}:  1.0  4.0  9.0</p><p>julia&gt; sum(A) 45.0</p><pre><code class="language-none">
If you are defining an array type that allows non-traditional indexing (indices that start at
something other than 1), you should specialize [`axes`](@ref). You should also specialize [`similar`](@ref)
so that the `dims` argument (ordinarily a `Dims` size-tuple) can accept `AbstractUnitRange` objects,
perhaps range-types `Ind` of your own design. For more information, see
[Arrays with custom indices](@ref man-custom-indices).

## [Strided Arrays](@id man-interface-strided-arrays)

| Methods to implement                            |                                        | Brief description                                                                     |
|:----------------------------------------------- |:-------------------------------------- |:------------------------------------------------------------------------------------- |
| `strides(A)`                             |                                        | Return the distance in memory (in number of elements) between adjacent elements in each dimension as a tuple. If `A` is an `AbstractArray{T,0}`, this should return an empty tuple.    |
| `Base.unsafe_convert(::Type{Ptr{T}}, A)`        |                                        | Return the native address of an array.                                            |
| **Optional methods**                            | **Default definition**                 | **Brief description**                                                                 |
| `stride(A, i::Int)`                             |     `strides(A)[i]`                                   | Return the distance in memory (in number of elements) between adjacent elements in dimension k.    |

A strided array is a subtype of `AbstractArray` whose entries are stored in memory with fixed strides.
Provided the element type of the array is compatible with BLAS, a strided array can utilize BLAS and LAPACK routines
for more efficient linear algebra routines.  A typical example of a user-defined strided array is one
that wraps a standard `Array` with additional structure.

Warning: do not implement these methods if the underlying storage is not actually strided, as it
may lead to incorrect results or segmentation faults.

Here are some examples to demonstrate which type of arrays are strided and which are not:</code></pre><p>julia 1:5   # not strided (there is no storage associated with this array.) Vector(1:5)  # is strided with strides (1,) A = [1 5; 2 6; 3 7; 4 8]  # is strided with strides (1,4) V = view(A, 1:2, :)   # is strided with strides (1,4) V = view(A, 1:2:3, 1:2)   # is strided with strides (2,4) V = view(A, [1,2,4], :)   # is not strided, as the spacing between rows is not fixed.</p><pre><code class="language-none">




## [Customizing broadcasting](@id man-interfaces-broadcasting)

| Methods to implement | 简短描述 |
|:-------------------- |:----------------- |
| `Base.BroadcastStyle(::Type{SrcType}) = SrcStyle()` | Broadcasting behavior of `SrcType` |
| `Base.similar(bc::Broadcasted{DestStyle}, ::Type{ElType})` | Allocation of output container |
| **Optional methods** | | |
| `Base.BroadcastStyle(::Style1, ::Style2) = Style12()` | Precedence rules for mixing styles |
| `Base.broadcast_axes(x)` | Declaration of the indices of `x` for broadcasting purposes (defaults to [`axes(x)`](@ref)) |
| `Base.broadcastable(x)` | Convert `x` to an object that has `axes` and supports indexing |
| **Bypassing default machinery** | |
| `Base.copy(bc::Broadcasted{DestStyle})` | Custom implementation of `broadcast` |
| `Base.copyto!(dest, bc::Broadcasted{DestStyle})` | Custom implementation of `broadcast!`, specializing on `DestStyle` |
| `Base.copyto!(dest::DestType, bc::Broadcasted{Nothing})` | Custom implementation of `broadcast!`, specializing on `DestType` |
| `Base.Broadcast.broadcasted(f, args...)` | Override the default lazy behavior within a fused expression |
| `Base.Broadcast.instantiate(bc::Broadcasted{DestStyle})` | Override the computation of the lazy broadcast&#39;s axes |

[Broadcasting](@ref) is triggered by an explicit call to `broadcast` or `broadcast!`, or implicitly by
&quot;dot&quot; operations like `A .+ b` or `f.(x, y)`. Any object that has [`axes`](@ref) and supports
indexing can participate as an argument in broadcasting, and by default the result is stored
in an `Array`. This basic framework is extensible in three major ways:

* Ensuring that all arguments support broadcast
* Selecting an appropriate output array for the given set of arguments
* Selecting an efficient implementation for the given set of arguments

Not all types support `axes` and indexing, but many are convenient to allow in broadcast.
The [`Base.broadcastable`](@ref) function is called on each argument to broadcast, allowing
it to return something different that supports `axes` and indexing. By
default, this is the identity function for all `AbstractArray`s and `Number`s — they already
support `axes` and indexing. For a handful of other types (including but not limited to
types themselves, functions, special singletons like [`missing`](@ref) and [`nothing`](@ref), and dates),
`Base.broadcastable` returns the argument wrapped in a `Ref` to act as a 0-dimensional
&quot;scalar&quot; for the purposes of broadcasting. Custom types can similarly specialize
`Base.broadcastable` to define their shape, but they should follow the convention that
`collect(Base.broadcastable(x)) == collect(x)`. A notable exception is `AbstractString`;
strings are special-cased to behave as scalars for the purposes of broadcast even though
they are iterable collections of their characters (see [Strings](@ref) for more).

The next two steps (selecting the output array and implementation) are dependent upon
determining a single answer for a given set of arguments. Broadcast must take all the varied
types of its arguments and collapse them down to just one output array and one
implementation. Broadcast calls this single answer a &quot;style.&quot; Every broadcastable object
each has its own preferred style, and a promotion-like system is used to combine these
styles into a single answer — the &quot;destination style&quot;.

### Broadcast Styles

`Base.BroadcastStyle` is the abstract type from which all broadcast styles are derived. When used as a
function it has two possible forms, unary (single-argument) and binary. The unary variant states
that you intend to implement specific broadcasting behavior and/or output type, and do not wish to
rely on the default fallback [`Broadcast.DefaultArrayStyle`](@ref).

To override these defaults, you can define a custom `BroadcastStyle` for your object:
</code></pre><p>julia struct MyStyle &lt;: Broadcast.BroadcastStyle end Base.BroadcastStyle(::Type{&lt;:MyType}) = MyStyle()</p><pre><code class="language-none">
In some cases it might be convenient not to have to define `MyStyle`, in which case you can
leverage one of the general broadcast wrappers:

  - `Base.BroadcastStyle(::Type{&lt;:MyType}) = Broadcast.Style{MyType}()` can be
    used for arbitrary types.
  - `Base.BroadcastStyle(::Type{&lt;:MyType}) = Broadcast.ArrayStyle{MyType}()` is preferred
    if `MyType` is an `AbstractArray`.
  - For `AbstractArrays` that only support a certain dimensionality, create a subtype of `Broadcast.AbstractArrayStyle{N}` (see below).

When your broadcast operation involves several arguments, individual argument styles get
combined to determine a single `DestStyle` that controls the type of the output container.
For more details, see [below](@ref writing-binary-broadcasting-rules).

### 选择合适的输出数组

The broadcast style is computed for every broadcasting operation to allow for
dispatch and specialization. The actual allocation of the result array is
handled by `similar`, using the Broadcasted object as its first argument.
</code></pre><p>julia Base.similar(bc::Broadcasted{DestStyle}, ::Type{ElType})</p><pre><code class="language-none">
The fallback definition is
</code></pre><p>julia similar(bc::Broadcasted{DefaultArrayStyle{N}}, ::Type{ElType}) where {N,ElType} =     similar(Array{ElType}, axes(bc))</p><pre><code class="language-none">
However, if needed you can specialize on any or all of these arguments. The final argument
`bc` is a lazy representation of a (potentially fused) broadcast operation, a `Broadcasted`
object.  For these purposes, the most important fields of the wrapper are
`f` and `args`, describing the function and argument list, respectively.  Note that the argument
list can — and often does — include other nested `Broadcasted` wrappers.

For a complete example, let&#39;s say you have created a type, `ArrayAndChar`, that stores an
array and a single character:
</code></pre><p>jldoctest ArrayAndChar; output = false struct ArrayAndChar{T,N} &lt;: AbstractArray{T,N}     data::Array{T,N}     char::Char end Base.size(A::ArrayAndChar) = size(A.data) Base.getindex(A::ArrayAndChar{T,N}, inds::Vararg{Int,N}) where {T,N} = A.data[inds...] Base.setindex!(A::ArrayAndChar{T,N}, val, inds::Vararg{Int,N}) where {T,N} = A.data[inds...] = val Base.showarg(io::IO, A::ArrayAndChar, toplevel) = print(io, typeof(A), &quot; with char &#39;&quot;, A.char, &quot;&#39;&quot;)</p><h1><a class="nav-anchor" id="output-1" href="#output-1">output</a></h1><pre><code class="language-none">
You might want broadcasting to preserve the `char` &quot;metadata.&quot; First we define
</code></pre><p>jldoctest ArrayAndChar; output = false Base.BroadcastStyle(::Type{&lt;:ArrayAndChar}) = Broadcast.ArrayStyle{ArrayAndChar}()</p><h1><a class="nav-anchor" id="output-2" href="#output-2">output</a></h1><pre><code class="language-none">
This means we must also define a corresponding `similar` method:</code></pre><p>jldoctest ArrayAndChar; output = false function Base.similar(bc::Broadcast.Broadcasted{Broadcast.ArrayStyle{ArrayAndChar}}, ::Type{ElType}) where ElType     # Scan the inputs for the ArrayAndChar:     A = find_aac(bc)     # Use the char field of A to create the output     ArrayAndChar(similar(Array{ElType}, axes(bc)), A.char) end</p><p>&quot;<code>A = find_aac(As)</code> returns the first ArrayAndChar among the arguments.&quot; find<em>aac(bc::Base.Broadcast.Broadcasted) = find</em>aac(bc.args) find<em>aac(args::Tuple) = find</em>aac(find<em>aac(args[1]), Base.tail(args)) find</em>aac(x) = x find<em>aac(a::ArrayAndChar, rest) = a find</em>aac(::Any, rest) = find_aac(rest)</p><h1><a class="nav-anchor" id="output-3" href="#output-3">output</a></h1><p>find_aac (generic function with 5 methods)</p><pre><code class="language-none">
From these definitions, one obtains the following behavior:</code></pre><p>jldoctest ArrayAndChar julia&gt; a = ArrayAndChar([1 2; 3 4], &#39;x&#39;) 2×2 ArrayAndChar{Int64,2} with char &#39;x&#39;:  1  2  3  4</p><p>julia&gt; a .+ 1 2×2 ArrayAndChar{Int64,2} with char &#39;x&#39;:  2  3  4  5</p><p>julia&gt; a .+ [5,10] 2×2 ArrayAndChar{Int64,2} with char &#39;x&#39;:   6   7  13  14</p><pre><code class="language-none">
### [Extending broadcast with custom implementations](@id extending-in-place-broadcast)

In general, a broadcast operation is represented by a lazy `Broadcasted` container that holds onto
the function to be applied alongside its arguments. Those arguments may themselves be more nested
`Broadcasted` containers, forming a large expression tree to be evaluated. A nested tree of
`Broadcasted` containers is directly constructed by the implicit dot syntax; `5 .+ 2.*x` is
transiently represented by `Broadcasted(+, 5, Broadcasted(*, 2, x))`, for example. This is
invisible to users as it is immediately realized through a call to `copy`, but it is this container
that provides the basis for broadcast&#39;s extensibility for authors of custom types. The built-in
broadcast machinery will then determine the result type and size based upon the arguments, allocate
it, and then finally copy the realization of the `Broadcasted` object into it with a default
`copyto!(::AbstractArray, ::Broadcasted)` method. The built-in fallback `broadcast` and
`broadcast!` methods similarly construct a transient `Broadcasted` representation of the operation
so they can follow the same codepath. This allows custom array implementations to
provide their own `copyto!` specialization to customize and
optimize broadcasting. This is again determined by the computed broadcast style. This is such
an important part of the operation that it is stored as the first type parameter of the
`Broadcasted` type, allowing for dispatch and specialization.

For some types, the machinery to &quot;fuse&quot; operations across nested levels of broadcasting
is not available or could be done more efficiently incrementally. In such cases, you may
need or want to evaluate `x .* (x .+ 1)` as if it had been
written `broadcast(*, x, broadcast(+, x, 1))`, where the inner operation is evaluated before
tackling the outer operation. This sort of eager operation is directly supported by a bit
of indirection; instead of directly constructing `Broadcasted` objects, Julia lowers the
fused expression `x .* (x .+ 1)` to `Broadcast.broadcasted(*, x, Broadcast.broadcasted(+, x, 1))`. Now,
by default, `broadcasted` just calls the `Broadcasted` constructor to create the lazy representation
of the fused expression tree, but you can choose to override it for a particular combination
of function and arguments.

As an example, the builtin `AbstractRange` objects use this machinery to optimize pieces
of broadcasted expressions that can be eagerly evaluated purely in terms of the start,
step, and length (or stop) instead of computing every single element. Just like all the
other machinery, `broadcasted` also computes and exposes the combined broadcast style of its
arguments, so instead of specializing on `broadcasted(f, args...)`, you can specialize on
`broadcasted(::DestStyle, f, args...)` for any combination of style, function, and arguments.

For example, the following definition supports the negation of ranges:
</code></pre><p>julia broadcasted(::DefaultArrayStyle{1}, ::typeof(-), r::OrdinalRange) = range(-first(r), step=-step(r), length=length(r))</p><pre><code class="language-none">
### [Extending in-place broadcasting](@id extending-in-place-broadcast)

In-place broadcasting can be supported by defining the appropriate `copyto!(dest, bc::Broadcasted)`
method. Because you might want to specialize either on `dest` or the specific subtype of `bc`,
to avoid ambiguities between packages we recommend the following convention.

If you wish to specialize on a particular style `DestStyle`, define a method for</code></pre><p>julia copyto!(dest, bc::Broadcasted{DestStyle})</p><pre><code class="language-none">Optionally, with this form you can also specialize on the type of `dest`.

If instead you want to specialize on the destination type `DestType` without specializing
on `DestStyle`, then you should define a method with the following signature:
</code></pre><p>julia copyto!(dest::DestType, bc::Broadcasted{Nothing})</p><pre><code class="language-none">
This leverages a fallback implementation of `copyto!` that converts the wrapper into a
`Broadcasted{Nothing}`. Consequently, specializing on `DestType` has lower precedence than
methods that specialize on `DestStyle`.

Similarly, you can completely override out-of-place broadcasting with a `copy(::Broadcasted)`
method.

#### Working with `Broadcasted` objects

In order to implement such a `copy` or `copyto!`, method, of course, you must
work with the `Broadcasted` wrapper to compute each element. There are two main
ways of doing so:

* `Broadcast.flatten` recomputes the potentially nested operation into a single
  function and flat list of arguments. You are responsible for implementing the
  broadcasting shape rules yourself, but this may be helpful in limited situations.
* Iterating over the `CartesianIndices` of the `axes(::Broadcasted)` and using
  indexing with the resulting `CartesianIndex` object to compute the result.

### [Writing binary broadcasting rules](@id writing-binary-broadcasting-rules)

The precedence rules are defined by binary `BroadcastStyle` calls:
</code></pre><p>julia Base.BroadcastStyle(::Style1, ::Style2) = Style12()</p><pre><code class="language-none">
where `Style12` is the `BroadcastStyle` you want to choose for outputs involving
arguments of `Style1` and `Style2`. For example,
</code></pre><p>julia Base.BroadcastStyle(::Broadcast.Style{Tuple}, ::Broadcast.AbstractArrayStyle{0}) = Broadcast.Style{Tuple}()</p><pre><code class="language-none">
indicates that `Tuple` &quot;wins&quot; over zero-dimensional arrays (the output container will be a tuple).
It is worth noting that you do not need to (and should not) define both argument orders
of this call; defining one is sufficient no matter what order the user supplies the arguments in.

For `AbstractArray` types, defining a `BroadcastStyle` supersedes the fallback choice,
[`Broadcast.DefaultArrayStyle`](@ref). `DefaultArrayStyle` and the abstract supertype, `AbstractArrayStyle`, store the dimensionality as a type parameter to support specialized
array types that have fixed dimensionality requirements.

`DefaultArrayStyle` &quot;loses&quot; to any other
`AbstractArrayStyle` that has been defined because of the following methods:
</code></pre><p>julia BroadcastStyle(a::AbstractArrayStyle{Any}, ::DefaultArrayStyle) = a BroadcastStyle(a::AbstractArrayStyle{N}, ::DefaultArrayStyle{N}) where N = a BroadcastStyle(a::AbstractArrayStyle{M}, ::DefaultArrayStyle{N}) where {M,N} =     typeof(a)(_max(Val(M),Val(N)))</p><pre><code class="language-none">
You do not need to write binary `BroadcastStyle`
rules unless you want to establish precedence for
two or more non-`DefaultArrayStyle` types.

If your array type does have fixed dimensionality requirements, then you should
subtype `AbstractArrayStyle`. For example, the sparse array code has the following definitions:
</code></pre><p>julia struct SparseVecStyle &lt;: Broadcast.AbstractArrayStyle{1} end struct SparseMatStyle &lt;: Broadcast.AbstractArrayStyle{2} end Base.BroadcastStyle(::Type{&lt;:SparseVector}) = SparseVecStyle() Base.BroadcastStyle(::Type{&lt;:SparseMatrixCSC}) = SparseMatStyle()</p><pre><code class="language-none">
Whenever you subtype `AbstractArrayStyle`, you also need to define rules for combining
dimensionalities, by creating a constructor for your style that takes a `Val(N)` argument.
For example:
</code></pre><p>julia SparseVecStyle(::Val{0}) = SparseVecStyle() SparseVecStyle(::Val{1}) = SparseVecStyle() SparseVecStyle(::Val{2}) = SparseMatStyle() SparseVecStyle(::Val{N}) where N = Broadcast.DefaultArrayStyle{N}() ```</p><p>These rules indicate that the combination of a <code>SparseVecStyle</code> with 0- or 1-dimensional arrays yields another <code>SparseVecStyle</code>, that its combination with a 2-dimensional array yields a <code>SparseMatStyle</code>, and anything of higher dimensionality falls back to the dense arbitrary-dimensional framework. These rules allow broadcasting to keep the sparse representation for operations that result in one or two dimensional outputs, but produce an <code>Array</code> for any other dimensionality.</p><footer><hr/><a class="previous" href="../conversion-and-promotion/"><span class="direction">Previous</span><span class="title">类型转换和类型提升</span></a><a class="next" href="../modules/"><span class="direction">Next</span><span class="title">模块</span></a></footer></article></body></html>
