<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>常见问题 · Julia中文文档</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-89508993-1', 'auto');
ga('send', 'pageview');
</script><link rel="canonical" href="https://juliacn.github.io/JuliaZH.jl/latest/manual/faq/index.html"/><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../../assets/julia-manual.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../../index.html"><img class="logo" src="../../assets/logo.png" alt="Julia中文文档 logo"/></a><h1>Julia中文文档</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">主页</a></li><li><span class="toctext">手册</span><ul><li><a class="toctext" href="../getting-started/">入门</a></li><li><a class="toctext" href="../variables/">变量</a></li><li><a class="toctext" href="../integers-and-floating-point-numbers/">整数和浮点数</a></li><li><a class="toctext" href="../mathematical-operations/">数学运算和初等函数</a></li><li><a class="toctext" href="../complex-and-rational-numbers/">复数和分数</a></li><li><a class="toctext" href="../strings/">字符串</a></li><li><a class="toctext" href="../functions/">函数</a></li><li><a class="toctext" href="../control-flow/">流程控制</a></li><li><a class="toctext" href="../variables-and-scoping/">变量作用域</a></li><li><a class="toctext" href="../types/">类型</a></li><li><a class="toctext" href="../methods/">方法</a></li><li><a class="toctext" href="../constructors/">构造函数</a></li><li><a class="toctext" href="../conversion-and-promotion/">类型转换和类型提升</a></li><li><a class="toctext" href="../interfaces/">接口</a></li><li><a class="toctext" href="../modules/">Modules</a></li><li><a class="toctext" href="../documentation/">文档</a></li><li><a class="toctext" href="../metaprogramming/">元编程</a></li><li><a class="toctext" href="../arrays/">多维数组</a></li><li><a class="toctext" href="../missing/">缺失值</a></li><li><a class="toctext" href="../networking-and-streams/">网络和流</a></li><li><a class="toctext" href="../parallel-computing/">并行计算</a></li><li><a class="toctext" href="../running-external-programs/">运行外部程序</a></li><li><a class="toctext" href="../calling-c-and-fortran-code/">调用 C 和 Fortran 代码</a></li><li><a class="toctext" href="../handling-operating-system-variation/">处理操作系统差异</a></li><li><a class="toctext" href="../environment-variables/">环境变量</a></li><li><a class="toctext" href="../embedding/">嵌入 Julia</a></li><li><a class="toctext" href="../code-loading/">代码加载</a></li><li><a class="toctext" href="../profile/">分析</a></li><li><a class="toctext" href="../stacktraces/">堆栈跟踪</a></li><li><a class="toctext" href="../performance-tips/">性能建议</a></li><li><a class="toctext" href="../workflow-tips/">工作流程建议</a></li><li><a class="toctext" href="../style-guide/">代码风格指南</a></li><li class="current"><a class="toctext" href>常见问题</a><ul class="internal"><li><a class="toctext" href="#会话和-REPL-1">会话和 REPL</a></li><li><a class="toctext" href="#函数-1">函数</a></li><li><a class="toctext" href="#Types,-type-declarations,-and-constructors-1">Types, type declarations, and constructors</a></li><li><a class="toctext" href="#Packages-and-Modules-1">Packages and Modules</a></li><li><a class="toctext" href="#Nothingness-and-missing-values-1">Nothingness and missing values</a></li><li><a class="toctext" href="#内存-1">内存</a></li><li><a class="toctext" href="#Asynchronous-IO-and-concurrent-synchronous-writes-1">Asynchronous IO and concurrent synchronous writes</a></li><li><a class="toctext" href="#Arrays-1">Arrays</a></li><li><a class="toctext" href="#Julia-版本发布-1">Julia 版本发布</a></li></ul></li><li><a class="toctext" href="../noteworthy-differences/">与其他语言的显著差异</a></li><li><a class="toctext" href="../unicode-input/">Unicode 输入表</a></li></ul></li><li><span class="toctext">Base</span><ul><li><a class="toctext" href="../../base/base/">基本功能</a></li><li><a class="toctext" href="../../base/collections/">集合和数据结构</a></li><li><a class="toctext" href="../../base/math/">数学相关</a></li><li><a class="toctext" href="../../base/numbers/">Numbers</a></li><li><a class="toctext" href="../../base/strings/">字符串</a></li><li><a class="toctext" href="../../base/arrays/">Arrays</a></li><li><a class="toctext" href="../../base/parallel/">Tasks</a></li><li><a class="toctext" href="../../base/multi-threading/">多线程</a></li><li><a class="toctext" href="../../base/constants/">常量</a></li><li><a class="toctext" href="../../base/file/">文件系统</a></li><li><a class="toctext" href="../../base/io-network/">I/O 与网络</a></li><li><a class="toctext" href="../../base/punctuation/">标点符号</a></li><li><a class="toctext" href="../../base/sort/">排序及相关函数</a></li><li><a class="toctext" href="../../base/iterators/">迭代相关</a></li><li><a class="toctext" href="../../base/c/">C 接口</a></li><li><a class="toctext" href="../../base/libc/">C 标准库</a></li><li><a class="toctext" href="../../base/stacktraces/">StackTraces</a></li><li><a class="toctext" href="../../base/simd-types/">SIMD 支持</a></li></ul></li><li><span class="toctext">Standard Library</span><ul><li><a class="toctext" href="../../stdlib/Base64/">Base64</a></li><li><a class="toctext" href="../../stdlib/CRC32c/">CRC32c</a></li><li><a class="toctext" href="../../stdlib/Dates/">Dates</a></li><li><a class="toctext" href="../../stdlib/DelimitedFiles/">Delimited Files</a></li><li><a class="toctext" href="../../stdlib/Distributed/">Distributed Computing</a></li><li><a class="toctext" href="../../stdlib/FileWatching/">File Events</a></li><li><a class="toctext" href="../../stdlib/InteractiveUtils/">Interactive Utilities</a></li><li><a class="toctext" href="../../stdlib/LibGit2/">LibGit2</a></li><li><a class="toctext" href="../../stdlib/Libdl/">Dynamic Linker</a></li><li><a class="toctext" href="../../stdlib/LinearAlgebra/">Linear Algebra</a></li><li><a class="toctext" href="../../stdlib/Logging/">Logging</a></li><li><a class="toctext" href="../../stdlib/Markdown/">Markdown</a></li><li><a class="toctext" href="../../stdlib/Mmap/">Memory-mapped I/O</a></li><li><a class="toctext" href="../../stdlib/Pkg/">Pkg</a></li><li><a class="toctext" href="../../stdlib/Printf/">Printf</a></li><li><a class="toctext" href="../../stdlib/Profile/">Profiling</a></li><li><a class="toctext" href="../../stdlib/REPL/">The Julia REPL</a></li><li><a class="toctext" href="../../stdlib/Random/">Random Numbers</a></li><li><a class="toctext" href="../../stdlib/SHA/">SHA</a></li><li><a class="toctext" href="../../stdlib/Serialization/">Serialization</a></li><li><a class="toctext" href="../../stdlib/SharedArrays/">Shared Arrays</a></li><li><a class="toctext" href="../../stdlib/Sockets/">Sockets</a></li><li><a class="toctext" href="../../stdlib/SparseArrays/">Sparse Arrays</a></li><li><a class="toctext" href="../../stdlib/Statistics/">Statistics</a></li><li><a class="toctext" href="../../stdlib/Test/">Unit Testing</a></li><li><a class="toctext" href="../../stdlib/UUIDs/">UUIDs</a></li><li><a class="toctext" href="../../stdlib/Unicode/">Unicode</a></li></ul></li><li><span class="toctext">Developer Documentation</span><ul><li><a class="toctext" href="../../devdocs/reflection/">反射 与 自我检查</a></li><li><span class="toctext">Documentation of Julia&#39;s Internals</span><ul><li><a class="toctext" href="../../devdocs/init/">Julia 运行时的初始化</a></li><li><a class="toctext" href="../../devdocs/ast/">Julia 的 AST</a></li><li><a class="toctext" href="../../devdocs/types/">More about types</a></li><li><a class="toctext" href="../../devdocs/object/">Memory layout of Julia Objects</a></li><li><a class="toctext" href="../../devdocs/eval/">Eval of Julia code</a></li><li><a class="toctext" href="../../devdocs/callconv/">Calling Conventions</a></li><li><a class="toctext" href="../../devdocs/compiler/">High-level Overview of the Native-Code Generation Process</a></li><li><a class="toctext" href="../../devdocs/functions/">Julia Functions</a></li><li><a class="toctext" href="../../devdocs/cartesian/">Base.Cartesian</a></li><li><a class="toctext" href="../../devdocs/meta/">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="toctext" href="../../devdocs/subarrays/">SubArrays</a></li><li><a class="toctext" href="../../devdocs/isbitsunionarrays/">isbits Union Optimizations</a></li><li><a class="toctext" href="../../devdocs/sysimg/">System Image Building</a></li><li><a class="toctext" href="../../devdocs/llvm/">Working with LLVM</a></li><li><a class="toctext" href="../../devdocs/stdio/">printf() and stdio in the Julia runtime</a></li><li><a class="toctext" href="../../devdocs/boundscheck/">边界检查</a></li><li><a class="toctext" href="../../devdocs/locks/">Proper maintenance and care of multi-threading locks</a></li><li><a class="toctext" href="../../devdocs/offset-arrays/">Arrays with custom indices</a></li><li><a class="toctext" href="../../devdocs/require/">Module loading</a></li><li><a class="toctext" href="../../devdocs/inference/">Inference</a></li></ul></li><li><span class="toctext">Developing/debugging Julia&#39;s C code</span><ul><li><a class="toctext" href="../../devdocs/backtraces/">Reporting and analyzing crashes (segfaults)</a></li><li><a class="toctext" href="../../devdocs/debuggingtips/">gdb 调试提示</a></li><li><a class="toctext" href="../../devdocs/valgrind/">Using Valgrind with Julia</a></li><li><a class="toctext" href="../../devdocs/sanitizers/">Sanitizer support</a></li></ul></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>手册</li><li><a href>常见问题</a></li></ul><a class="edit-page" href="https://github.com/JuliaCN/JuliaZH.jl/blob/master/doc/src/manual/faq.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>常见问题</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="常见问题-1" href="#常见问题-1">常见问题</a></h1><h2><a class="nav-anchor" id="会话和-REPL-1" href="#会话和-REPL-1">会话和 REPL</a></h2><h3><a class="nav-anchor" id="如何从内存中删除对象？-1" href="#如何从内存中删除对象？-1">如何从内存中删除对象？</a></h3><p>Julia 没有类似于 MATLAB 的 <code>clear</code> 函数，某个名称一旦定义在 Julia 的会话中（准确地说，在 <code>Main</code> 模块中），它就会一直存在下去。</p><p>如果关心内存用量，一个对象总能被一个占用更少内存的对象替换掉。例如，如果 <code>A</code> 是一个不再需要的吉字节量级的数组，可以使用 <code>A = nothing</code> 来释放内存。该内存将在下一次垃圾回收器运行时被释放，也可以使用 <a href="../../base/base/#Base.GC.gc"><code>gc()</code></a> 强制执行。另外，试图使用 <code>A</code> 很可能导致错误，因为大部分方法在 <code>Nothing</code> 类型上没有定义。</p><h3><a class="nav-anchor" id="如何在会话中修改某个类型的声明？-1" href="#如何在会话中修改某个类型的声明？-1">如何在会话中修改某个类型的声明？</a></h3><p>也许你定义了某个类型，后来发现需要向其中增加一个新的域。如果在 REPL 中尝试这样做，会得到一个错误：</p><pre><code class="language-none">ERROR: invalid redefinition of constant MyType</code></pre><p>模块 <code>Main</code> 中的类型不能重新定义。</p><p>尽管这在开发新代码时会造成不便，但是对于这个问题仍然有一个不错的解决办法：可以用重新定义的方法替换模块，所以可以把所有新代码封装在一个模块里。虽说不能将类型名称导入到 <code>Main</code> 模块中再去重新定义，但是可以用模块名来解决这个问题。换言之，开发时的工作流可能类似这样：</p><pre><code class="language-julia">include(&quot;mynewcode.jl&quot;) # this defines a module MyModule
obj1 = MyModule.ObjConstructor(a, b)
obj2 = MyModule.somefunction(obj1)
# Got an error. Change something in &quot;mynewcode.jl&quot;
include(&quot;mynewcode.jl&quot;) # reload the module
obj1 = MyModule.ObjConstructor(a, b) # old objects are no longer valid, must reconstruct
obj2 = MyModule.somefunction(obj1) # this time it worked!
obj3 = MyModule.someotherfunction(obj2, c)
...</code></pre><h2><a class="nav-anchor" id="函数-1" href="#函数-1">函数</a></h2><h3><a class="nav-anchor" id="向函数传递了参数-x，在函数中做了修改，但是在函数外变量-x-的值还是没有变。为什么？-1" href="#向函数传递了参数-x，在函数中做了修改，但是在函数外变量-x-的值还是没有变。为什么？-1">向函数传递了参数 <code>x</code>，在函数中做了修改，但是在函数外变量 <code>x</code> 的值还是没有变。为什么？</a></h3><p>假设函数被如此调用：</p><pre><code class="language-julia-repl">julia&gt; x = 10
10

julia&gt; function change_value!(y)
           y = 17
       end
change_value! (generic function with 1 method)

julia&gt; change_value!(x)
17

julia&gt; x # x is unchanged!
10</code></pre><p>In Julia, the binding of a variable <code>x</code> cannot be changed by passing <code>x</code> as an argument to a function. When calling <code>change_value!(x)</code> in the above example, <code>y</code> is a newly created variable, bound initially to the value of <code>x</code>, i.e. <code>10</code>; then <code>y</code> is rebound to the constant <code>17</code>, while the variable <code>x</code> of the outer scope is left untouched.</p><p>但是这里有一个需要注意的点: 假设 &#39;x&#39; 被绑定至 &#39;Array&#39; 类型 (或者其他 <em>可变</em> 的类型). 在函数中,你无法改变&#39;x&#39; 的&#39;Array&#39;类型, 但是你可以改变其内容. 例如</p><pre><code class="language-julia-repl">julia&gt; x = [1,2,3]
3-element Array{Int64,1}:
 1
 2
 3

julia&gt; function change_array!(A)
           A[1] = 5
       end
change_array! (generic function with 1 method)

julia&gt; change_array!(x)
5

julia&gt; x
3-element Array{Int64,1}:
 5
 2
 3</code></pre><p>Here we created a function <code>change_array!</code>, that assigns <code>5</code> to the first element of the passed array (bound to <code>x</code> at the call site, and bound to <code>A</code> within the function). Notice that, after the function call, <code>x</code> is still bound to the same array, but the content of that array changed: the variables <code>A</code> and <code>x</code> were distinct bindings referring to the same mutable <code>Array</code> object.</p><h3><a class="nav-anchor" id="函数内部能否使用-using-或-import？-1" href="#函数内部能否使用-using-或-import？-1">函数内部能否使用 <code>using</code> 或 <code>import</code>？</a></h3><p>不可以，在函数内部含有 <code>using</code> 或 <code>import</code> 语句是不被允许的。 如果你希望导入一个模块，但只在特定的一个或一组函数中使用它的符号， 有以下两种方式：</p><ol><li><p>使用 <code>import</code>：</p><pre><code class="language-julia">import Foo
function bar(...)
    # ... refer to Foo symbols via Foo.baz ...
end</code></pre><p>这会加载 <code>Foo</code> 模块，同时定义一个变量 <code>Foo</code> 引用该模块，但并不会将其他任何符号从该模块中导入当前的名字空间。<code>Foo</code> 等符号可以由限定的名称 <code>Foo.bar</code> 等引用。 import any of the other symbols from the module into the current namespace.  You refer to the <code>Foo</code> symbols by their qualified names <code>Foo.bar</code> etc.</p></li><li><p>将函数封装到模块中：</p><pre><code class="language-julia">module Bar
export bar
using Foo
function bar(...)
    # ... refer to Foo.baz as simply baz ....
end
end
using Bar</code></pre><p>这会从 <code>Foo</code> 中导入所有符号，但仅限于 <code>Bar</code> 模块内。</p></li></ol><h3><a class="nav-anchor" id="运算符-...-有何作用？-1" href="#运算符-...-有何作用？-1">运算符 <code>...</code> 有何作用？</a></h3><h3><a class="nav-anchor" id="The-two-uses-of-the-...-operator:-slurping-and-splatting-1" href="#The-two-uses-of-the-...-operator:-slurping-and-splatting-1">The two uses of the <code>...</code> operator: slurping and splatting</a></h3><p>Many newcomers to Julia find the use of <code>...</code> operator confusing. Part of what makes the <code>...</code> operator confusing is that it means two different things depending on context.</p><h3><a class="nav-anchor" id="...-combines-many-arguments-into-one-argument-in-function-definitions-1" href="#...-combines-many-arguments-into-one-argument-in-function-definitions-1"><code>...</code> combines many arguments into one argument in function definitions</a></h3><p>In the context of function definitions, the <code>...</code> operator is used to combine many different arguments into a single argument. This use of <code>...</code> for combining many different arguments into a single argument is called slurping:</p><pre><code class="language-julia-repl">julia&gt; function printargs(args...)
           println(typeof(args))
           for (i, arg) in enumerate(args)
               println(&quot;Arg #$i = $arg&quot;)
           end
       end
printargs (generic function with 1 method)

julia&gt; printargs(1, 2, 3)
Tuple{Int64,Int64,Int64}
Arg #1 = 1
Arg #2 = 2
Arg #3 = 3</code></pre><p>If Julia were a language that made more liberal use of ASCII characters, the slurping operator might have been written as <code>&lt;-...</code> instead of <code>...</code>.</p><h3><a class="nav-anchor" id="...-splits-one-argument-into-many-different-arguments-in-function-calls-1" href="#...-splits-one-argument-into-many-different-arguments-in-function-calls-1"><code>...</code> splits one argument into many different arguments in function calls</a></h3><p>In contrast to the use of the <code>...</code> operator to denote slurping many different arguments into one argument when defining a function, the <code>...</code> operator is also used to cause a single function argument to be split apart into many different arguments when used in the context of a function call. This use of <code>...</code> is called splatting:</p><pre><code class="language-julia-repl">julia&gt; function threeargs(a, b, c)
           println(&quot;a = $a::$(typeof(a))&quot;)
           println(&quot;b = $b::$(typeof(b))&quot;)
           println(&quot;c = $c::$(typeof(c))&quot;)
       end
threeargs (generic function with 1 method)

julia&gt; x = [1, 2, 3]
3-element Array{Int64,1}:
 1
 2
 3

julia&gt; threeargs(x...)
a = 1::Int64
b = 2::Int64
c = 3::Int64</code></pre><p>If Julia were a language that made more liberal use of ASCII characters, the splatting operator might have been written as <code>...-&gt;</code> instead of <code>...</code>.</p><h3><a class="nav-anchor" id="What-is-the-return-value-of-an-assignment?-1" href="#What-is-the-return-value-of-an-assignment?-1">What is the return value of an assignment?</a></h3><p>The operator <code>=</code> always returns the right-hand side, therefore:</p><pre><code class="language-julia-repl">julia&gt; function threeint()
           x::Int = 3.0
           x # returns variable x
       end
threeint (generic function with 1 method)

julia&gt; function threefloat()
           x::Int = 3.0 # returns 3.0
       end
threefloat (generic function with 1 method)

julia&gt; threeint()
3

julia&gt; threefloat()
3.0</code></pre><p>and similarly:</p><pre><code class="language-julia-repl">julia&gt; function threetup()
           x, y = [3, 3]
           x, y # returns a tuple
       end
threetup (generic function with 1 method)

julia&gt; function threearr()
           x, y = [3, 3] # returns an array
       end
threearr (generic function with 1 method)

julia&gt; threetup()
(3, 3)

julia&gt; threearr()
2-element Array{Int64,1}:
 3
 3</code></pre><h2><a class="nav-anchor" id="Types,-type-declarations,-and-constructors-1" href="#Types,-type-declarations,-and-constructors-1">Types, type declarations, and constructors</a></h2><h3><a class="nav-anchor" id="man-type-stability-1" href="#man-type-stability-1">何谓“类型稳定”？</a></h3><p>这意味着输出的类型可以由输入的类型预测出来。特别地，这意味着输出的类型不会因输入的<strong>值</strong>的不同而变化。以下代码<strong>不是</strong>类型稳定的：</p><pre><code class="language-julia-repl">julia&gt; function unstable(flag::Bool)
           if flag
               return 1
           else
               return 1.0
           end
       end
unstable (generic function with 1 method)</code></pre><p>根据参数的不同，该函数可能返回 <code>Int</code> 或 <a href="../../base/numbers/#Core.Float64"><code>Float64</code></a>。 由于 Julia 无法在编译期预测该函数的返回值类型，任何使用该函数的计算都需要考虑这两种可能的返回类型，这样难以生成高效的机器码。</p><h3><a class="nav-anchor" id="faq-domain-errors-1" href="#faq-domain-errors-1">为何 Julia 对某个看似合理的操作返回 <code>DomainError</code>？</a></h3><p>某些运算在数学上有意义，但会产生错误：</p><pre><code class="language-julia-repl">julia&gt; sqrt(-2.0)
ERROR: DomainError with -2.0:
sqrt will only return a complex result if called with a complex argument. Try sqrt(Complex(x)).
Stacktrace:
[...]</code></pre><p>这一行为是为了保证类型稳定而带来的不便。对于 <a href="../../base/math/#Base.sqrt-Tuple{Real}"><code>sqrt</code></a>，许多用户会希望 <code>sqrt(2.0)</code> 产生一个实数，如果得到了复数 <code>1.4142135623730951 + 0.0im</code> 则会不高兴。也可以编写 <a href="../../base/math/#Base.sqrt-Tuple{Real}"><code>sqrt</code></a> 函数，只有当传递一个负数时才切换到复值输出，但结果将不是类型稳定的，而且 <a href="../../base/math/#Base.sqrt-Tuple{Real}"><code>sqrt</code></a> 函数的性能会很差。</p><p>In these and other cases, you can get the result you want by choosing an <em>input type</em> that conveys your willingness to accept an <em>output type</em> in which the result can be represented:</p><pre><code class="language-julia-repl">julia&gt; sqrt(-2.0+0im)
0.0 + 1.4142135623730951im</code></pre><h3><a class="nav-anchor" id="Why-does-Julia-use-native-machine-integer-arithmetic?-1" href="#Why-does-Julia-use-native-machine-integer-arithmetic?-1">Why does Julia use native machine integer arithmetic?</a></h3><p>Julia uses machine arithmetic for integer computations. This means that the range of <code>Int</code> values is bounded and wraps around at either end so that adding, subtracting and multiplying integers can overflow or underflow, leading to some results that can be unsettling at first:</p><pre><code class="language-julia-repl">julia&gt; typemax(Int)
9223372036854775807

julia&gt; ans+1
-9223372036854775808

julia&gt; -ans
-9223372036854775808

julia&gt; 2*ans
0</code></pre><p>Clearly, this is far from the way mathematical integers behave, and you might think it less than ideal for a high-level programming language to expose this to the user. For numerical work where efficiency and transparency are at a premium, however, the alternatives are worse.</p><p>One alternative to consider would be to check each integer operation for overflow and promote results to bigger integer types such as <a href="../../base/numbers/#Core.Int128"><code>Int128</code></a> or <a href="../../base/numbers/#Base.GMP.BigInt"><code>BigInt</code></a> in the case of overflow. Unfortunately, this introduces major overhead on every integer operation (think incrementing a loop counter) – it requires emitting code to perform run-time overflow checks after arithmetic instructions and branches to handle potential overflows. Worse still, this would cause every computation involving integers to be type-unstable. As we mentioned above, <a href="#man-type-stability-1">type-stability is crucial</a> for effective generation of efficient code. If you can&#39;t count on the results of integer operations being integers, it&#39;s impossible to generate fast, simple code the way C and Fortran compilers do.</p><p>A variation on this approach, which avoids the appearance of type instability is to merge the <code>Int</code> and <a href="../../base/numbers/#Base.GMP.BigInt"><code>BigInt</code></a> types into a single hybrid integer type, that internally changes representation when a result no longer fits into the size of a machine integer. While this superficially avoids type-instability at the level of Julia code, it just sweeps the problem under the rug by foisting all of the same difficulties onto the C code implementing this hybrid integer type. This approach <em>can</em> be made to work and can even be made quite fast in many cases, but has several drawbacks. One problem is that the in-memory representation of integers and arrays of integers no longer match the natural representation used by C, Fortran and other languages with native machine integers. Thus, to interoperate with those languages, we would ultimately need to introduce native integer types anyway. Any unbounded representation of integers cannot have a fixed number of bits, and thus cannot be stored inline in an array with fixed-size slots – large integer values will always require separate heap-allocated storage. And of course, no matter how clever a hybrid integer implementation one uses, there are always performance traps – situations where performance degrades unexpectedly. Complex representation, lack of interoperability with C and Fortran, the inability to represent integer arrays without additional heap storage, and unpredictable performance characteristics make even the cleverest hybrid integer implementations a poor choice for high-performance numerical work.</p><p>An alternative to using hybrid integers or promoting to BigInts is to use saturating integer arithmetic, where adding to the largest integer value leaves it unchanged and likewise for subtracting from the smallest integer value. This is precisely what Matlab™ does:</p><pre><code class="language-none">&gt;&gt; int64(9223372036854775807)

ans =

  9223372036854775807

&gt;&gt; int64(9223372036854775807) + 1

ans =

  9223372036854775807

&gt;&gt; int64(-9223372036854775808)

ans =

 -9223372036854775808

&gt;&gt; int64(-9223372036854775808) - 1

ans =

 -9223372036854775808</code></pre><p>At first blush, this seems reasonable enough since 9223372036854775807 is much closer to 9223372036854775808 than -9223372036854775808 is and integers are still represented with a fixed size in a natural way that is compatible with C and Fortran. Saturated integer arithmetic, however, is deeply problematic. The first and most obvious issue is that this is not the way machine integer arithmetic works, so implementing saturated operations requires emitting instructions after each machine integer operation to check for underflow or overflow and replace the result with <a href="../../base/base/#Base.typemin"><code>typemin(Int)</code></a> or <a href="../../base/base/#Base.typemax"><code>typemax(Int)</code></a> as appropriate. This alone expands each integer operation from a single, fast instruction into half a dozen instructions, probably including branches. Ouch. But it gets worse – saturating integer arithmetic isn&#39;t associative. Consider this Matlab computation:</p><pre><code class="language-none">&gt;&gt; n = int64(2)^62
4611686018427387904

&gt;&gt; n + (n - 1)
9223372036854775807

&gt;&gt; (n + n) - 1
9223372036854775806</code></pre><p>This makes it hard to write many basic integer algorithms since a lot of common techniques depend on the fact that machine addition with overflow <em>is</em> associative. Consider finding the midpoint between integer values <code>lo</code> and <code>hi</code> in Julia using the expression <code>(lo + hi) &gt;&gt;&gt; 1</code>:</p><pre><code class="language-julia-repl">julia&gt; n = 2^62
4611686018427387904

julia&gt; (n + 2n) &gt;&gt;&gt; 1
6917529027641081856</code></pre><p>See? No problem. That&#39;s the correct midpoint between 2^62 and 2^63, despite the fact that <code>n + 2n</code> is -4611686018427387904. Now try it in Matlab:</p><pre><code class="language-none">&gt;&gt; (n + 2*n)/2

ans =

  4611686018427387904</code></pre><p>Oops. Adding a <code>&gt;&gt;&gt;</code> operator to Matlab wouldn&#39;t help, because saturation that occurs when adding <code>n</code> and <code>2n</code> has already destroyed the information necessary to compute the correct midpoint.</p><p>Not only is lack of associativity unfortunate for programmers who cannot rely it for techniques like this, but it also defeats almost anything compilers might want to do to optimize integer arithmetic. For example, since Julia integers use normal machine integer arithmetic, LLVM is free to aggressively optimize simple little functions like <code>f(k) = 5k-1</code>. The machine code for this function is just this:</p><pre><code class="language-julia-repl">julia&gt; code_native(f, Tuple{Int})
  .text
Filename: none
  pushq %rbp
  movq  %rsp, %rbp
Source line: 1
  leaq  -1(%rdi,%rdi,4), %rax
  popq  %rbp
  retq
  nopl  (%rax,%rax)</code></pre><p>The actual body of the function is a single <code>leaq</code> instruction, which computes the integer multiply and add at once. This is even more beneficial when <code>f</code> gets inlined into another function:</p><pre><code class="language-julia-repl">julia&gt; function g(k, n)
           for i = 1:n
               k = f(k)
           end
           return k
       end
g (generic function with 1 methods)

julia&gt; code_native(g, Tuple{Int,Int})
  .text
Filename: none
  pushq %rbp
  movq  %rsp, %rbp
Source line: 2
  testq %rsi, %rsi
  jle L26
  nopl  (%rax)
Source line: 3
L16:
  leaq  -1(%rdi,%rdi,4), %rdi
Source line: 2
  decq  %rsi
  jne L16
Source line: 5
L26:
  movq  %rdi, %rax
  popq  %rbp
  retq
  nop</code></pre><p>Since the call to <code>f</code> gets inlined, the loop body ends up being just a single <code>leaq</code> instruction. Next, consider what happens if we make the number of loop iterations fixed:</p><pre><code class="language-julia-repl">julia&gt; function g(k)
           for i = 1:10
               k = f(k)
           end
           return k
       end
g (generic function with 2 methods)

julia&gt; code_native(g,(Int,))
  .text
Filename: none
  pushq %rbp
  movq  %rsp, %rbp
Source line: 3
  imulq $9765625, %rdi, %rax    # imm = 0x9502F9
  addq  $-2441406, %rax         # imm = 0xFFDABF42
Source line: 5
  popq  %rbp
  retq
  nopw  %cs:(%rax,%rax)</code></pre><p>Because the compiler knows that integer addition and multiplication are associative and that multiplication distributes over addition – neither of which is true of saturating arithmetic – it can optimize the entire loop down to just a multiply and an add. Saturated arithmetic completely defeats this kind of optimization since associativity and distributivity can fail at each loop iteration, causing different outcomes depending on which iteration the failure occurs in. The compiler can unroll the loop, but it cannot algebraically reduce multiple operations into fewer equivalent operations.</p><p>The most reasonable alternative to having integer arithmetic silently overflow is to do checked arithmetic everywhere, raising errors when adds, subtracts, and multiplies overflow, producing values that are not value-correct. In this <a href="http://danluu.com/integer-overflow/">blog post</a>, Dan Luu analyzes this and finds that rather than the trivial cost that this approach should in theory have, it ends up having a substantial cost due to compilers (LLVM and GCC) not gracefully optimizing around the added overflow checks. If this improves in the future, we could consider defaulting to checked integer arithmetic in Julia, but for now, we have to live with the possibility of overflow.</p><h3><a class="nav-anchor" id="What-are-the-possible-causes-of-an-UndefVarError-during-remote-execution?-1" href="#What-are-the-possible-causes-of-an-UndefVarError-during-remote-execution?-1">What are the possible causes of an <code>UndefVarError</code> during remote execution?</a></h3><p>As the error states, an immediate cause of an <code>UndefVarError</code> on a remote node is that a binding by that name does not exist. Let us explore some of the possible causes.</p><pre><code class="language-julia-repl">julia&gt; module Foo
           foo() = remotecall_fetch(x-&gt;x, 2, &quot;Hello&quot;)
       end

julia&gt; Foo.foo()
ERROR: On worker 2:
UndefVarError: Foo not defined
Stacktrace:
[...]</code></pre><p>The closure <code>x-&gt;x</code> carries a reference to <code>Foo</code>, and since <code>Foo</code> is unavailable on node 2, an <code>UndefVarError</code> is thrown.</p><p>Globals under modules other than <code>Main</code> are not serialized by value to the remote node. Only a reference is sent. Functions which create global bindings (except under <code>Main</code>) may cause an <code>UndefVarError</code> to be thrown later.</p><pre><code class="language-julia-repl">julia&gt; @everywhere module Foo
           function foo()
               global gvar = &quot;Hello&quot;
               remotecall_fetch(()-&gt;gvar, 2)
           end
       end

julia&gt; Foo.foo()
ERROR: On worker 2:
UndefVarError: gvar not defined
Stacktrace:
[...]</code></pre><p>In the above example, <code>@everywhere module Foo</code> defined <code>Foo</code> on all nodes. However the call to <code>Foo.foo()</code> created a new global binding <code>gvar</code> on the local node, but this was not found on node 2 resulting in an <code>UndefVarError</code> error.</p><p>Note that this does not apply to globals created under module <code>Main</code>. Globals under module <code>Main</code> are serialized and new bindings created under <code>Main</code> on the remote node.</p><pre><code class="language-julia-repl">julia&gt; gvar_self = &quot;Node1&quot;
&quot;Node1&quot;

julia&gt; remotecall_fetch(()-&gt;gvar_self, 2)
&quot;Node1&quot;

julia&gt; remotecall_fetch(varinfo, 2)
name          size summary
––––––––– –––––––– –––––––
Base               Module
Core               Module
Main               Module
gvar_self 13 bytes String</code></pre><p>This does not apply to <code>function</code> or <code>struct</code> declarations. However, anonymous functions bound to global variables are serialized as can be seen below.</p><pre><code class="language-julia-repl">julia&gt; bar() = 1
bar (generic function with 1 method)

julia&gt; remotecall_fetch(bar, 2)
ERROR: On worker 2:
UndefVarError: #bar not defined
[...]

julia&gt; anon_bar  = ()-&gt;1
(::#21) (generic function with 1 method)

julia&gt; remotecall_fetch(anon_bar, 2)
1</code></pre><h2><a class="nav-anchor" id="Packages-and-Modules-1" href="#Packages-and-Modules-1">Packages and Modules</a></h2><h3><a class="nav-anchor" id="What-is-the-difference-between-&quot;using&quot;-and-&quot;import&quot;?-1" href="#What-is-the-difference-between-&quot;using&quot;-and-&quot;import&quot;?-1">What is the difference between &quot;using&quot; and &quot;import&quot;?</a></h3><p>There is only one difference, and on the surface (syntax-wise) it may seem very minor. The difference between <code>using</code> and <code>import</code> is that with <code>using</code> you need to say <code>function Foo.bar(..</code> to extend module Foo&#39;s function bar with a new method, but with <code>import Foo.bar</code>, you only need to say <code>function bar(...</code> and it automatically extends module Foo&#39;s function bar.</p><p>The reason this is important enough to have been given separate syntax is that you don&#39;t want to accidentally extend a function that you didn&#39;t know existed, because that could easily cause a bug. This is most likely to happen with a method that takes a common type like a string or integer, because both you and the other module could define a method to handle such a common type. If you use <code>import</code>, then you&#39;ll replace the other module&#39;s implementation of <code>bar(s::AbstractString)</code> with your new implementation, which could easily do something completely different (and break all/many future usages of the other functions in module Foo that depend on calling bar).</p><h2><a class="nav-anchor" id="Nothingness-and-missing-values-1" href="#Nothingness-and-missing-values-1">Nothingness and missing values</a></h2><h3><a class="nav-anchor" id="faq-nothing-1" href="#faq-nothing-1">How does &quot;null&quot;, &quot;nothingness&quot; or &quot;missingness&quot; work in Julia?</a></h3><p>Unlike many languages (for example, C and Java), Julia objects cannot be &quot;null&quot; by default. When a reference (variable, object field, or array element) is uninitialized, accessing it will immediately throw an error. This situation can be detected using the <a href="../../base/base/#Core.isdefined"><code>isdefined</code></a> or <a href="../../base/arrays/#Base.isassigned"><code>isassigned</code></a> functions.</p><p>Some functions are used only for their side effects, and do not need to return a value. In these cases, the convention is to return the value <code>nothing</code>, which is just a singleton object of type <code>Nothing</code>. This is an ordinary type with no fields; there is nothing special about it except for this convention, and that the REPL does not print anything for it. Some language constructs that would not otherwise have a value also yield <code>nothing</code>, for example <code>if false; end</code>.</p><p>For situations where a value <code>x</code> of type <code>T</code> exists only sometimes, the <code>Union{T, Nothing}</code> type can be used for function arguments, object fields and array element types as the equivalent of <a href="https://en.wikipedia.org/wiki/Nullable_type"><code>Nullable</code>, <code>Option</code> or <code>Maybe</code></a> in other languages. If the value itself can be <code>nothing</code> (notably, when <code>T</code> is <code>Any</code>), the <code>Union{Some{T}, Nothing}</code> type is more appropriate since <code>x == nothing</code> then indicates the absence of a value, and <code>x == Some(nothing)</code> indicates the presence of a value equal to <code>nothing</code>. The <a href="../../base/base/#Base.something"><code>something</code></a> function allows unwrapping <code>Some</code> objects and using a default value instead of <code>nothing</code> arguments. Note that the compiler is able to generate efficient code when working with <code>Union{T, Nothing}</code> arguments or fields.</p><p>To represent missing data in the statistical sense (<code>NA</code> in R or <code>NULL</code> in SQL), use the <a href="../../base/base/#Base.missing"><code>missing</code></a> object. See the <a href="../missing/#missing-1"><code>Missing Values</code></a> section for more details.</p><p>The empty tuple (<code>()</code>) is another form of nothingness. But, it should not really be thought of as nothing but rather a tuple of zero values.</p><p>The empty (or &quot;bottom&quot;) type, written as <code>Union{}</code> (an empty union type), is a type with no values and no subtypes (except itself). You will generally not need to use this type.</p><h3><a class="nav-anchor" id="How-do-I-check-if-the-current-file-is-being-run-as-the-main-script?-1" href="#How-do-I-check-if-the-current-file-is-being-run-as-the-main-script?-1">How do I check if the current file is being run as the main script?</a></h3><p>When a file is run as the main script using <code>julia file.jl</code> one might want to activate extra functionality like command line argument handling. A way to determine that a file is run in this fashion is to check if <code>abspath(PROGRAM_FILE) == @__FILE__</code> is <code>true</code>.</p><h2><a class="nav-anchor" id="内存-1" href="#内存-1">内存</a></h2><h3><a class="nav-anchor" id="Why-does-x-y-allocate-memory-when-x-and-y-are-arrays?-1" href="#Why-does-x-y-allocate-memory-when-x-and-y-are-arrays?-1">Why does <code>x += y</code> allocate memory when <code>x</code> and <code>y</code> are arrays?</a></h3><p>In Julia, <code>x += y</code> gets replaced during parsing by <code>x = x + y</code>. For arrays, this has the consequence that, rather than storing the result in the same location in memory as <code>x</code>, it allocates a new array to store the result.</p><p>While this behavior might surprise some, the choice is deliberate. The main reason is the presence of immutable objects within Julia, which cannot change their value once created.  Indeed, a number is an immutable object; the statements <code>x = 5; x += 1</code> do not modify the meaning of <code>5</code>, they modify the value bound to <code>x</code>. For an immutable, the only way to change the value is to reassign it.</p><p>To amplify a bit further, consider the following function:</p><pre><code class="language-julia">function power_by_squaring(x, n::Int)
    ispow2(n) || error(&quot;This implementation only works for powers of 2&quot;)
    while n &gt;= 2
        x *= x
        n &gt;&gt;= 1
    end
    x
end</code></pre><p>After a call like <code>x = 5; y = power_by_squaring(x, 4)</code>, you would get the expected result: <code>x == 5 &amp;&amp; y == 625</code>.  However, now suppose that <code>*=</code>, when used with matrices, instead mutated the left hand side.  There would be two problems:</p><ul><li>For general square matrices, <code>A = A*B</code> cannot be implemented without temporary storage: <code>A[1,1]</code> gets computed and stored on the left hand side before you&#39;re done using it on the right hand side.</li><li>Suppose you were willing to allocate a temporary for the computation (which would eliminate most of the point of making <code>*=</code> work in-place); if you took advantage of the mutability of <code>x</code>, then this function would behave differently for mutable vs. immutable inputs. In particular, for immutable <code>x</code>, after the call you&#39;d have (in general) <code>y != x</code>, but for mutable <code>x</code> you&#39;d have <code>y == x</code>.</li></ul><p>Because supporting generic programming is deemed more important than potential performance optimizations that can be achieved by other means (e.g., using explicit loops), operators like <code>+=</code> and <code>*=</code> work by rebinding new values.</p><h2><a class="nav-anchor" id="Asynchronous-IO-and-concurrent-synchronous-writes-1" href="#Asynchronous-IO-and-concurrent-synchronous-writes-1">Asynchronous IO and concurrent synchronous writes</a></h2><h3><a class="nav-anchor" id="Why-do-concurrent-writes-to-the-same-stream-result-in-inter-mixed-output?-1" href="#Why-do-concurrent-writes-to-the-same-stream-result-in-inter-mixed-output?-1">Why do concurrent writes to the same stream result in inter-mixed output?</a></h3><p>While the streaming I/O API is synchronous, the underlying implementation is fully asynchronous.</p><p>Consider the printed output from the following:</p><pre><code class="language-julia-repl">julia&gt; @sync for i in 1:3
           @async write(stdout, string(i), &quot; Foo &quot;, &quot; Bar &quot;)
       end
123 Foo  Foo  Foo  Bar  Bar  Bar</code></pre><p>This is happening because, while the <code>write</code> call is synchronous, the writing of each argument yields to other tasks while waiting for that part of the I/O to complete.</p><p><code>print</code> and <code>println</code> &quot;lock&quot; the stream during a call. Consequently changing <code>write</code> to <code>println</code> in the above example results in:</p><pre><code class="language-julia-repl">julia&gt; @sync for i in 1:3
           @async println(stdout, string(i), &quot; Foo &quot;, &quot; Bar &quot;)
       end
1 Foo  Bar
2 Foo  Bar
3 Foo  Bar</code></pre><p>You can lock your writes with a <code>ReentrantLock</code> like this:</p><pre><code class="language-julia-repl">julia&gt; l = ReentrantLock()
ReentrantLock(nothing, Condition(Any[]), 0)

julia&gt; @sync for i in 1:3
           @async begin
               lock(l)
               try
                   write(stdout, string(i), &quot; Foo &quot;, &quot; Bar &quot;)
               finally
                   unlock(l)
               end
           end
       end
1 Foo  Bar 2 Foo  Bar 3 Foo  Bar</code></pre><h2><a class="nav-anchor" id="Arrays-1" href="#Arrays-1">Arrays</a></h2><h3><a class="nav-anchor" id="What-are-the-differences-between-zero-dimensional-arrays-and-scalars?-1" href="#What-are-the-differences-between-zero-dimensional-arrays-and-scalars?-1">What are the differences between zero-dimensional arrays and scalars?</a></h3><p>Zero-dimensional arrays are arrays of the form <code>Array{T,0}</code>. They behave similar to scalars, but there are important differences. They deserve a special mention because they are a special case which makes logical sense given the generic definition of arrays, but might be a bit unintuitive at first. The following line defines a zero-dimensional array:</p><pre><code class="language-none">julia&gt; A = zeros()
0-dimensional Array{Float64,0}:
0.0</code></pre><p>In this example, <code>A</code> is a mutable container that contains one element, which can be set by <code>A[] = 1.0</code> and retrieved with <code>A[]</code>. All zero-dimensional arrays have the same size (<code>size(A) == ()</code>), and length (<code>length(A) == 1</code>). In particular, zero-dimensional arrays are not empty. If you find this unintuitive, here are some ideas that might help to understand Julia&#39;s definition.</p><ul><li>Zero-dimensional arrays are the &quot;point&quot; to vector&#39;s &quot;line&quot; and matrix&#39;s &quot;plane&quot;. Just as a line has no area (but still represents a set of things), a point has no length or any dimensions at all (but still represents a thing).</li><li>We define <code>prod(())</code> to be 1, and the total number of elements in an array is the product of the size. The size of a zero-dimensional array is <code>()</code>, and therefore its length is <code>1</code>.</li><li>Zero-dimensional arrays don&#39;t natively have any dimensions into which you index – they’re just <code>A[]</code>. We can apply the same &quot;trailing one&quot; rule for them as for all other array dimensionalities, so you can indeed index them as <code>A[1]</code>, <code>A[1,1]</code>, etc.</li></ul><p>It is also important to understand the differences to ordinary scalars. Scalars are not mutable containers (even though they are iterable and define things like <code>length</code>, <code>getindex</code>, <em>e.g.</em> <code>1[] == 1</code>). In particular, if <code>x = 0.0</code> is defined as a scalar, it is an error to attempt to change its value via <code>x[] = 1.0</code>. A scalar <code>x</code> can be converted into a zero-dimensional array containing it via <code>fill(x)</code>, and conversely, a zero-dimensional array <code>a</code> can be converted to the contained scalar via <code>a[]</code>. Another difference is that a scalar can participate in linear algebra operations such as <code>2 * rand(2,2)</code>, but the analogous operation with a zero-dimensional array <code>fill(2) * rand(2,2)</code> is an error.</p><h2><a class="nav-anchor" id="Julia-版本发布-1" href="#Julia-版本发布-1">Julia 版本发布</a></h2><h3><a class="nav-anchor" id="应该使用-Julia-的正式版（release-version），测试版（beta-version）还是每夜更新版（nightly-version）？-1" href="#应该使用-Julia-的正式版（release-version），测试版（beta-version）还是每夜更新版（nightly-version）？-1">应该使用 Julia 的正式版（release version），测试版（beta version）还是每夜更新版（nightly version）？</a></h3><p>如果您正在寻找稳定的代码库，您可能更喜欢Julia的正式版。 通常每6个月发布一次，为您提供编写代码的稳定平台。</p><p>如果您不介意稍微落后于最新的错误修正和更改，觉得稍微更快的修改更具吸引力，您可能更喜欢Julia的测试版。 此外，这些二进制文件在发布之前会进行测试，以确保它们完全正常运行。</p><p>如果您想利用该语言的最新更新，并且不介意今天可用的版本偶尔出现实际上并没有正常工作，您可能更喜欢 Julia 的每夜更新版。</p><p>最后，您也可以考虑自己从源代码编译Julia。 此选项主要适用于那些适应命令行或对学习感兴趣的人。 如果您是这样，您可能也有兴趣阅读我们的<a href="https://github.com/JuliaLang/julia/blob/master/CONTRIBUTING.md">贡献指南</a>。</p><p>可以在<a href="https://julialang.org/downloads/">https://julialang.org/downloads/</a>的下载页面上找到每种下载类型的链接。 请注意，并非所有版本的Julia都适用于所有平台。</p><h3><a class="nav-anchor" id="已弃用的功能会在何时移除？-1" href="#已弃用的功能会在何时移除？-1">已弃用的功能会在何时移除？</a></h3><p>Deprecated functions are removed after the subsequent release. For example, functions marked as deprecated in the 0.1 release will not be available starting with the 0.2 release.</p><footer><hr/><a class="previous" href="../style-guide/"><span class="direction">Previous</span><span class="title">代码风格指南</span></a><a class="next" href="../noteworthy-differences/"><span class="direction">Next</span><span class="title">与其他语言的显著差异</span></a></footer></article></body></html>
