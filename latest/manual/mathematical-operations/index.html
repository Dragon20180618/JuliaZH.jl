<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>数学运算和初等函数 · Julia中文文档</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-89508993-1', 'auto');
ga('send', 'pageview');
</script><link rel="canonical" href="https://juliacn.github.io/JuliaZH.jl/latest/manual/mathematical-operations/index.html"/><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../../assets/julia-manual.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../../index.html"><img class="logo" src="../../assets/logo.png" alt="Julia中文文档 logo"/></a><h1>Julia中文文档</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">主页</a></li><li><span class="toctext">手册</span><ul><li><a class="toctext" href="../getting-started/">入门</a></li><li><a class="toctext" href="../variables/">变量</a></li><li><a class="toctext" href="../integers-and-floating-point-numbers/">整数和浮点数</a></li><li class="current"><a class="toctext" href>数学运算和初等函数</a><ul class="internal"><li><a class="toctext" href="#算术运算符-1">算术运算符</a></li><li><a class="toctext" href="#位运算符-1">位运算符</a></li><li><a class="toctext" href="#复合赋值操作符-1">复合赋值操作符</a></li><li><a class="toctext" href="#man-dot-operators-1">矢量化 &quot;dot&quot; 运算符</a></li><li><a class="toctext" href="#数值比较-1">数值比较</a></li><li><a class="toctext" href="#运算符的优先级与结合性-1">运算符的优先级与结合性</a></li><li><a class="toctext" href="#数值转换-1">数值转换</a></li></ul></li><li><a class="toctext" href="../complex-and-rational-numbers/">复数和分数</a></li><li><a class="toctext" href="../strings/">字符串</a></li><li><a class="toctext" href="../functions/">函数</a></li><li><a class="toctext" href="../control-flow/">流程控制</a></li><li><a class="toctext" href="../variables-and-scoping/">变量作用域</a></li><li><a class="toctext" href="../types/">类型</a></li><li><a class="toctext" href="../methods/">方法</a></li><li><a class="toctext" href="../constructors/">构造函数</a></li><li><a class="toctext" href="../conversion-and-promotion/">类型转换和类型提升</a></li><li><a class="toctext" href="../interfaces/">接口</a></li><li><a class="toctext" href="../modules/">Modules</a></li><li><a class="toctext" href="../documentation/">文档</a></li><li><a class="toctext" href="../metaprogramming/">元编程</a></li><li><a class="toctext" href="../arrays/">多维数组</a></li><li><a class="toctext" href="../missing/">缺失值</a></li><li><a class="toctext" href="../networking-and-streams/">网络和流</a></li><li><a class="toctext" href="../parallel-computing/">并行计算</a></li><li><a class="toctext" href="../running-external-programs/">运行外部程序</a></li><li><a class="toctext" href="../calling-c-and-fortran-code/">调用 C 和 Fortran 代码</a></li><li><a class="toctext" href="../handling-operating-system-variation/">处理操作系统差异</a></li><li><a class="toctext" href="../environment-variables/">环境变量</a></li><li><a class="toctext" href="../embedding/">嵌入 Julia</a></li><li><a class="toctext" href="../code-loading/">代码加载</a></li><li><a class="toctext" href="../profile/">分析</a></li><li><a class="toctext" href="../stacktraces/">堆栈跟踪</a></li><li><a class="toctext" href="../performance-tips/">性能建议</a></li><li><a class="toctext" href="../workflow-tips/">工作流程建议</a></li><li><a class="toctext" href="../style-guide/">代码风格指南</a></li><li><a class="toctext" href="../faq/">常见问题</a></li><li><a class="toctext" href="../noteworthy-differences/">与其他语言的显著差异</a></li><li><a class="toctext" href="../unicode-input/">Unicode 输入表</a></li></ul></li><li><span class="toctext">Base</span><ul><li><a class="toctext" href="../../base/base/">基本功能</a></li><li><a class="toctext" href="../../base/collections/">集合和数据结构</a></li><li><a class="toctext" href="../../base/math/">数学相关</a></li><li><a class="toctext" href="../../base/numbers/">Numbers</a></li><li><a class="toctext" href="../../base/strings/">字符串</a></li><li><a class="toctext" href="../../base/arrays/">Arrays</a></li><li><a class="toctext" href="../../base/parallel/">Tasks</a></li><li><a class="toctext" href="../../base/multi-threading/">多线程</a></li><li><a class="toctext" href="../../base/constants/">常量</a></li><li><a class="toctext" href="../../base/file/">文件系统</a></li><li><a class="toctext" href="../../base/io-network/">I/O 与网络</a></li><li><a class="toctext" href="../../base/punctuation/">标点符号</a></li><li><a class="toctext" href="../../base/sort/">排序及相关函数</a></li><li><a class="toctext" href="../../base/iterators/">迭代相关</a></li><li><a class="toctext" href="../../base/c/">C 接口</a></li><li><a class="toctext" href="../../base/libc/">C 标准库</a></li><li><a class="toctext" href="../../base/stacktraces/">StackTraces</a></li><li><a class="toctext" href="../../base/simd-types/">SIMD 支持</a></li></ul></li><li><span class="toctext">Standard Library</span><ul><li><a class="toctext" href="../../stdlib/Base64/">Base64</a></li><li><a class="toctext" href="../../stdlib/CRC32c/">CRC32c</a></li><li><a class="toctext" href="../../stdlib/Dates/">Dates</a></li><li><a class="toctext" href="../../stdlib/DelimitedFiles/">Delimited Files</a></li><li><a class="toctext" href="../../stdlib/Distributed/">Distributed Computing</a></li><li><a class="toctext" href="../../stdlib/FileWatching/">File Events</a></li><li><a class="toctext" href="../../stdlib/InteractiveUtils/">Interactive Utilities</a></li><li><a class="toctext" href="../../stdlib/LibGit2/">LibGit2</a></li><li><a class="toctext" href="../../stdlib/Libdl/">Dynamic Linker</a></li><li><a class="toctext" href="../../stdlib/LinearAlgebra/">Linear Algebra</a></li><li><a class="toctext" href="../../stdlib/Logging/">Logging</a></li><li><a class="toctext" href="../../stdlib/Markdown/">Markdown</a></li><li><a class="toctext" href="../../stdlib/Mmap/">Memory-mapped I/O</a></li><li><a class="toctext" href="../../stdlib/Pkg/">Pkg</a></li><li><a class="toctext" href="../../stdlib/Printf/">Printf</a></li><li><a class="toctext" href="../../stdlib/Profile/">Profiling</a></li><li><a class="toctext" href="../../stdlib/REPL/">The Julia REPL</a></li><li><a class="toctext" href="../../stdlib/Random/">Random Numbers</a></li><li><a class="toctext" href="../../stdlib/SHA/">SHA</a></li><li><a class="toctext" href="../../stdlib/Serialization/">Serialization</a></li><li><a class="toctext" href="../../stdlib/SharedArrays/">Shared Arrays</a></li><li><a class="toctext" href="../../stdlib/Sockets/">Sockets</a></li><li><a class="toctext" href="../../stdlib/SparseArrays/">Sparse Arrays</a></li><li><a class="toctext" href="../../stdlib/Statistics/">Statistics</a></li><li><a class="toctext" href="../../stdlib/Test/">Unit Testing</a></li><li><a class="toctext" href="../../stdlib/UUIDs/">UUIDs</a></li><li><a class="toctext" href="../../stdlib/Unicode/">Unicode</a></li></ul></li><li><span class="toctext">Developer Documentation</span><ul><li><a class="toctext" href="../../devdocs/reflection/">反射 与 自我检查</a></li><li><span class="toctext">Documentation of Julia&#39;s Internals</span><ul><li><a class="toctext" href="../../devdocs/init/">Julia 运行时的初始化</a></li><li><a class="toctext" href="../../devdocs/ast/">Julia 的 AST</a></li><li><a class="toctext" href="../../devdocs/types/">More about types</a></li><li><a class="toctext" href="../../devdocs/object/">Memory layout of Julia Objects</a></li><li><a class="toctext" href="../../devdocs/eval/">Eval of Julia code</a></li><li><a class="toctext" href="../../devdocs/callconv/">Calling Conventions</a></li><li><a class="toctext" href="../../devdocs/compiler/">High-level Overview of the Native-Code Generation Process</a></li><li><a class="toctext" href="../../devdocs/functions/">Julia的相关函数</a></li><li><a class="toctext" href="../../devdocs/cartesian/">Base.Cartesian</a></li><li><a class="toctext" href="../../devdocs/meta/">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="toctext" href="../../devdocs/subarrays/">SubArrays</a></li><li><a class="toctext" href="../../devdocs/isbitsunionarrays/">isbits Union Optimizations</a></li><li><a class="toctext" href="../../devdocs/sysimg/">System Image Building</a></li><li><a class="toctext" href="../../devdocs/llvm/">Working with LLVM</a></li><li><a class="toctext" href="../../devdocs/stdio/">printf() and stdio in the Julia runtime</a></li><li><a class="toctext" href="../../devdocs/boundscheck/">边界检查</a></li><li><a class="toctext" href="../../devdocs/locks/">Proper maintenance and care of multi-threading locks</a></li><li><a class="toctext" href="../../devdocs/offset-arrays/">Arrays with custom indices</a></li><li><a class="toctext" href="../../devdocs/require/">Module loading</a></li><li><a class="toctext" href="../../devdocs/inference/">Inference</a></li></ul></li><li><span class="toctext">Developing/debugging Julia&#39;s C code</span><ul><li><a class="toctext" href="../../devdocs/backtraces/">Reporting and analyzing crashes (segfaults)</a></li><li><a class="toctext" href="../../devdocs/debuggingtips/">gdb 调试提示</a></li><li><a class="toctext" href="../../devdocs/valgrind/">Using Valgrind with Julia</a></li><li><a class="toctext" href="../../devdocs/sanitizers/">Sanitizer support</a></li></ul></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>手册</li><li><a href>数学运算和初等函数</a></li></ul><a class="edit-page" href="https://github.com/JuliaCN/JuliaZH.jl/blob/master/doc/src/manual/mathematical-operations.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>数学运算和初等函数</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="数学运算和初等函数-1" href="#数学运算和初等函数-1">数学运算和初等函数</a></h1><p>Julia 为它所有的基础数值类型，提供了整套的基础算术和位运算，也提供了一套高效、可移植的标准数学函数。</p><h2><a class="nav-anchor" id="算术运算符-1" href="#算术运算符-1">算术运算符</a></h2><p>以下 <a href="https://en.wikipedia.org/wiki/Arithmetic#Arithmetic_operations">算术运算符</a> 支持所有的基本算术类型：</p><table><tr><th>表达式</th><th>名称</th><th>描述</th></tr><tr><td><code>+x</code></td><td>一元加法运算符</td><td>全等操作</td></tr><tr><td><code>-x</code></td><td>一元减法运算符</td><td>将值变为其相反数</td></tr><tr><td><code>x + y</code></td><td>二元加法运算符</td><td>执行加法</td></tr><tr><td><code>x - y</code></td><td>二元减法运算符</td><td>执行减法</td></tr><tr><td><code>x * y</code></td><td>乘法运算符</td><td>执行乘法</td></tr><tr><td><code>x / y</code></td><td>除法运算符</td><td>执行除法</td></tr><tr><td><code>x ÷ y</code></td><td>整除</td><td>取 x / y 的整数部分</td></tr><tr><td><code>x \ y</code></td><td>反向除法</td><td>等价于 <code>y / x</code></td></tr><tr><td><code>x ^ y</code></td><td>幂操作符</td><td><code>x</code> 的 <code>y</code> 次幂</td></tr><tr><td><code>x % y</code></td><td>取余</td><td>等价于 <code>rem(x,y)</code></td></tr></table><p>以及对 <a href="../../base/numbers/#Core.Bool"><code>Bool</code></a> 类型的否定：</p><table><tr><th>表达式</th><th>名称</th><th>描述</th></tr><tr><td><code>!x</code></td><td>否定</td><td>将 <code>true</code> 和 <code>false</code> 互换</td></tr></table><p>Julia 的类型提升系统使得混合参数类型上的代数运算也能顺其自然的工作。请参考<a href="../conversion-and-promotion/#conversion-and-promotion-1">类型提升系统</a>来了解更多内容。</p><p>这里是使用算术运算符的一些简单例子：</p><pre><code class="language-julia-repl">julia&gt; 1 + 2 + 3
6

julia&gt; 1 - 2
-1

julia&gt; 3*2/12
0.5</code></pre><p>习惯上我们会把优先运算的操作符紧邻操作数，比如 <code>-x + 2</code> 表示先要给 <code>x</code>  取反，然后再加 <code>2</code> 。</p><h2><a class="nav-anchor" id="位运算符-1" href="#位运算符-1">位运算符</a></h2><p>所有基本整数类型都支持以下<a href="https://en.wikipedia.org/wiki/Bitwise_operation#Bitwise_operators">位运算符</a>：</p><table><tr><th>表达式</th><th>名称</th></tr><tr><td><code>~x</code></td><td>按位取反</td></tr><tr><td><code>x &amp; y</code></td><td>按位与</td></tr><tr><td><code>x | y</code></td><td>按位或</td></tr><tr><td><code>x ⊻ y</code></td><td>按位异或（逻辑异或）</td></tr><tr><td><code>x &gt;&gt;&gt; y</code></td><td><a href="https://en.wikipedia.org/wiki/Logical_shift">逻辑右移</a></td></tr><tr><td><code>x &gt;&gt; y</code></td><td><a href="https://en.wikipedia.org/wiki/Arithmetic_shift">算术右移</a></td></tr><tr><td><code>x &lt;&lt; y</code></td><td>逻辑/算术左移</td></tr></table><p>以下是位运算符的一些示例：</p><pre><code class="language-julia-repl">julia&gt; ~123
-124

julia&gt; 123 &amp; 234
106

julia&gt; 123 | 234
251

julia&gt; 123 ⊻ 234
145

julia&gt; xor(123, 234)
145

julia&gt; ~UInt32(123)
0xffffff84

julia&gt; ~UInt8(123)
0x84</code></pre><h2><a class="nav-anchor" id="复合赋值操作符-1" href="#复合赋值操作符-1">复合赋值操作符</a></h2><p>每一个二元运算符和位运算符都可以给左操作数复合赋值：方法是把 <code>=</code> 直接放在二元运算符后面。比如，<code>x += 3</code> 等价于 <code>x = x + 3</code> 。</p><pre><code class="language-julia-repl">julia&gt; x = 1
1

julia&gt; x += 3
4

julia&gt; x
4</code></pre><p>二元运算和位运算的复合赋值操作符有下面几种：</p><pre><code class="language-none">+=  -=  *=  /=  \=  ÷=  %=  ^=  &amp;=  |=  ⊻=  &gt;&gt;&gt;=  &gt;&gt;=  &lt;&lt;=</code></pre><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>复合赋值后会把变量重新绑定到左操作数上，所以变量的类型可能会改变。</p><pre><code class="language-julia-repl">julia&gt; x = 0x01; typeof(x)
UInt8

julia&gt; x *= 2 # Same as x = x * 2
2

julia&gt; typeof(x)
Int64</code></pre></div></div><h2><a class="nav-anchor" id="man-dot-operators-1" href="#man-dot-operators-1">矢量化 &quot;dot&quot; 运算符</a></h2><p>对于每一个二元运算符，比如 <code>^</code> ，都有一个“dot”运算符 <code>.^</code> 与之对应，它会对数组元素一一执行 <code>^</code> 运算。比如 <code>[1,2,3] ^ 3</code> 是非法的，因为数学上没有给（长宽不一样的）数组的立方下过定义。但是 <code>[1,2,3] .^ 3</code> 在 Julia 里是合法的，它会逐个元素（“矢量式的”）计算，得到 <code>[1^3, 2^3, 3^3]</code>。类似地，像 <code>!</code> 和 <code>√</code> 这种一元运算符也会依次针对每个元素运算。</p><pre><code class="language-julia-repl">julia&gt; [1,2,3] .^ 3
3-element Array{Int64,1}:
  1
  8
 27</code></pre><p>具体来说，<code>a .^ b</code> 被解析为 <a href="../functions/#man-vectorized-1">&quot;dot&quot; call</a> <code>(^).(a,b)</code>，进而会执行 <a href="manual/@ref Broadcasting">broadcast</a> 操作： it can combine arrays and scalars, arrays of the same size (performing the operation elementwise), and even arrays of different shapes (e.g. combining row and column vectors to produce a matrix). Moreover, like all vectorized &quot;dot calls,&quot; these &quot;dot operators&quot; are <em>fusing</em>. For example, if you compute <code>2 .* A.^2 .+ sin.(A)</code> (or equivalently <code>@. 2A^2 + sin(A)</code>, using the <a href="../../base/arrays/#Base.Broadcast.@__dot__"><code>@.</code></a> macro) for an array <code>A</code>, it performs a <em>single</em> loop over <code>A</code>, computing <code>2a^2 + sin(a)</code> for each element of <code>A</code>. In particular, nested dot calls like <code>f.(g.(x))</code> are fused, and &quot;adjacent&quot; binary operators like <code>x .+ 3 .* x.^2</code> are equivalent to nested dot calls <code>(+).(x, (*).(3, (^).(x, 2)))</code>.</p><p>Furthermore, &quot;dotted&quot; updating operators like <code>a .+= b</code> (or <code>@. a += b</code>) are parsed as <code>a .= a .+ b</code>, where <code>.=</code> is a fused <em>in-place</em> assignment operation (see the <a href="../functions/#man-vectorized-1">dot syntax documentation</a>).</p><p>Note the dot syntax is also applicable to user-defined operators. For example, if you define <code>⊗(A,B) = kron(A,B)</code> to give a convenient infix syntax <code>A ⊗ B</code> for Kronecker products (<a href="../../stdlib/LinearAlgebra/#Base.kron"><code>kron</code></a>), then <code>[A,B] .⊗ [C,D]</code> will compute <code>[A⊗C, B⊗D]</code> with no additional coding.</p><p>Combining dot operators with numeric literals can be ambiguous. For example, it is not clear whether <code>1.+x</code> means <code>1. + x</code> or <code>1 .+ x</code>. Therefore this syntax is disallowed, and spaces must be used around the operator in such cases.</p><h2><a class="nav-anchor" id="数值比较-1" href="#数值比较-1">数值比较</a></h2><p>Standard comparison operations are defined for all the primitive numeric types:</p><table><tr><th>Operator</th><th>名称</th></tr><tr><td><a href="../../base/math/#Base.:=="><code>==</code></a></td><td>相等</td></tr><tr><td><a href="../../base/math/#Base.:!="><code>!=</code></a>, <a href="../../base/math/#Base.:!="><code>≠</code></a></td><td>不等</td></tr><tr><td><a href="../../base/math/#Base.:&lt;"><code>&lt;</code></a></td><td>小于</td></tr><tr><td><a href="../../base/math/#Base.:&lt;="><code>&lt;=</code></a>, <a href="../../base/math/#Base.:&lt;="><code>≤</code></a></td><td>小于等于</td></tr><tr><td><a href="../../base/math/#Base.:&gt;"><code>&gt;</code></a></td><td>大于</td></tr><tr><td><a href="../../base/math/#Base.:&gt;="><code>&gt;=</code></a>, <a href="../../base/math/#Base.:&gt;="><code>≥</code></a></td><td>大于等于</td></tr></table><p>下面是一些简单的例子：</p><pre><code class="language-julia-repl">julia&gt; 1 == 1
true

julia&gt; 1 == 2
false

julia&gt; 1 != 2
true

julia&gt; 1 == 1.0
true

julia&gt; 1 &lt; 2
true

julia&gt; 1.0 &gt; 3
false

julia&gt; 1 &gt;= 1.0
true

julia&gt; -1 &lt;= 1
true

julia&gt; -1 &lt;= -1
true

julia&gt; -1 &lt;= -2
false

julia&gt; 3 &lt; -0.5
false</code></pre><p>Integers are compared in the standard manner – by comparison of bits. Floating-point numbers are compared according to the <a href="https://en.wikipedia.org/wiki/IEEE_754-2008">IEEE 754 standard</a>:</p><ul><li>Finite numbers are ordered in the usual manner.</li><li>Positive zero is equal but not greater than negative zero.</li><li><code>Inf</code> is equal to itself and greater than everything else except <code>NaN</code>.</li><li><code>-Inf</code> is equal to itself and less then everything else except <code>NaN</code>.</li><li><code>NaN</code> is not equal to, not less than, and not greater than anything, including itself.</li></ul><p>The last point is potentially surprising and thus worth noting:</p><pre><code class="language-julia-repl">julia&gt; NaN == NaN
false

julia&gt; NaN != NaN
true

julia&gt; NaN &lt; NaN
false

julia&gt; NaN &gt; NaN
false</code></pre><p>and can cause especial headaches with <a href="../arrays/#man-multi-dim-arrays-1">arrays</a>:</p><pre><code class="language-julia-repl">julia&gt; [1 NaN] == [1 NaN]
false</code></pre><p>Julia provides additional functions to test numbers for special values, which can be useful in situations like hash key comparisons:</p><table><tr><th>函数</th><th>测试是否满足如下性质</th></tr><tr><td><a href="../../base/base/#Base.isequal"><code>isequal(x, y)</code></a></td><td><code>x</code> 与 <code>y</code> 是完全相同的</td></tr><tr><td><a href="../../base/numbers/#Base.isfinite"><code>isfinite(x)</code></a></td><td><code>x</code> 是有限大的数字</td></tr><tr><td><a href="../../base/numbers/#Base.isinf"><code>isinf(x)</code></a></td><td><code>x</code> 是（正/负）无穷大</td></tr><tr><td><a href="../../base/numbers/#Base.isnan"><code>isnan(x)</code></a></td><td><code>x</code> 是 <code>NaN</code></td></tr></table><p><a href="../../base/base/#Base.isequal"><code>isequal</code></a> 认为 <code>NaN</code> 之间是相等的：</p><pre><code class="language-julia-repl">julia&gt; isequal(NaN, NaN)
true

julia&gt; isequal([1 NaN], [1 NaN])
true

julia&gt; isequal(NaN, NaN32)
true</code></pre><p><code>isequal</code> 也能用来区分带符号的零：</p><pre><code class="language-julia-repl">julia&gt; -0.0 == 0.0
true

julia&gt; isequal(-0.0, 0.0)
false</code></pre><p>Mixed-type comparisons between signed integers, unsigned integers, and floats can be tricky. A great deal of care has been taken to ensure that Julia does them correctly.</p><p>For other types, <code>isequal</code> defaults to calling <a href="../../base/math/#Base.:=="><code>==</code></a>, so if you want to define equality for your own types then you only need to add a <a href="../../base/math/#Base.:=="><code>==</code></a> method.  If you define your own equality function, you should probably define a corresponding <a href="../../base/base/#Base.hash"><code>hash</code></a> method to ensure that <code>isequal(x,y)</code> implies <code>hash(x) == hash(y)</code>.</p><h3><a class="nav-anchor" id="链式比较-1" href="#链式比较-1">链式比较</a></h3><p>Unlike most languages, with the <a href="https://en.wikipedia.org/wiki/Python_syntax_and_semantics#Comparison_operators">notable exception of Python</a>, comparisons can be arbitrarily chained:</p><pre><code class="language-julia-repl">julia&gt; 1 &lt; 2 &lt;= 2 &lt; 3 == 3 &gt; 2 &gt;= 1 == 1 &lt; 3 != 5
true</code></pre><p>Chaining comparisons is often quite convenient in numerical code. Chained comparisons use the <code>&amp;&amp;</code> operator for scalar comparisons, and the <a href="../../base/math/#Base.:&amp;"><code>&amp;</code></a> operator for elementwise comparisons, which allows them to work on arrays. For example, <code>0 .&lt; A .&lt; 1</code> gives a boolean array whose entries are true where the corresponding elements of <code>A</code> are between 0 and 1.</p><p>Note the evaluation behavior of chained comparisons:</p><pre><code class="language-julia-repl">julia&gt; v(x) = (println(x); x)
v (generic function with 1 method)

julia&gt; v(1) &lt; v(2) &lt;= v(3)
2
1
3
true

julia&gt; v(1) &gt; v(2) &lt;= v(3)
2
1
false</code></pre><p>The middle expression is only evaluated once, rather than twice as it would be if the expression were written as <code>v(1) &lt; v(2) &amp;&amp; v(2) &lt;= v(3)</code>. However, the order of evaluations in a chained comparison is undefined. It is strongly recommended not to use expressions with side effects (such as printing) in chained comparisons. If side effects are required, the short-circuit <code>&amp;&amp;</code> operator should be used explicitly (see <a href="manual/@ref">Short-Circuit Evaluation</a>).</p><h3><a class="nav-anchor" id="初等函数-1" href="#初等函数-1">初等函数</a></h3><p>Julia provides a comprehensive collection of mathematical functions and operators. These mathematical operations are defined over as broad a class of numerical values as permit sensible definitions, including integers, floating-point numbers, rationals, and complex numbers, wherever such definitions make sense.</p><p>Moreover, these functions (like any Julia function) can be applied in &quot;vectorized&quot; fashion to arrays and other collections with the <a href="../functions/#man-vectorized-1">dot syntax</a> <code>f.(A)</code>, e.g. <code>sin.(A)</code> will compute the sine of each element of an array <code>A</code>.</p><h2><a class="nav-anchor" id="运算符的优先级与结合性-1" href="#运算符的优先级与结合性-1">运算符的优先级与结合性</a></h2><p>Julia applies the following order and associativity of operations, from highest precedence to lowest:</p><table><tr><th>分类</th><th>运算符</th><th>结合性</th></tr><tr><td>语法</td><td><code>.</code> followed by <code>::</code></td><td>左结合</td></tr><tr><td>幂运算</td><td><code>^</code></td><td>右结合</td></tr><tr><td>一元运算符</td><td><code>+ - √</code></td><td>右结合<a href="#footnote-1">[1]</a></td></tr><tr><td>移位运算</td><td><code>&lt;&lt; &gt;&gt; &gt;&gt;&gt;</code></td><td>左结合</td></tr><tr><td>除法</td><td><code>//</code></td><td>左结合</td></tr><tr><td>乘法</td><td><code>* / % &amp; \ ÷</code></td><td>左结合<a href="#footnote-2">[2]</a></td></tr><tr><td>加法</td><td><code>+ - | ⊻</code></td><td>左结合<a href="#footnote-2">[2]</a></td></tr><tr><td>语法</td><td><code>: ..</code></td><td>左结合</td></tr><tr><td>语法</td><td><code>|&gt;</code></td><td>左结合</td></tr><tr><td>语法</td><td><code>&lt;|</code></td><td>右结合</td></tr><tr><td>比较</td><td><code>&gt; &lt; &gt;= &lt;= == === != !== &lt;:</code></td><td>无结合性</td></tr><tr><td>控制流程</td><td><code>&amp;&amp;</code> followed by <code>||</code> followed by <code>?</code></td><td>右结合</td></tr><tr><td>Pair</td><td><code>=&gt;</code></td><td>右结合</td></tr><tr><td>赋值</td><td><code>= += -= *= /= //= \= ^= ÷= %= |= &amp;= ⊻= &lt;&lt;= &gt;&gt;= &gt;&gt;&gt;=</code></td><td>右结合</td></tr></table><div class="footnote" id="footnote-1"><a href="#footnote-1"><strong>[1]</strong></a><p>The unary operators <code>+</code> and <code>-</code> require explicit parentheses around their argument to disambiguate them from the operator <code>++</code>, etc. Other compositions of unary operators are parsed with right-associativity, e. g., <code>√√-a</code> as <code>√(√(-a))</code>.</p></div><div class="footnote" id="footnote-2"><a href="#footnote-2"><strong>[2]</strong></a><p>The operators <code>+</code>, <code>++</code> and <code>*</code> are non-associative. <code>a + b + c</code> is parsed as <code>+(a, b, c)</code> not <code>+(+(a, b), c)</code>. However, the fallback methods for <code>+(a, b, c, d...)</code> and <code>*(a, b, c, d...)</code> both default to left-associative evaluation.</p></div><p>For a complete list of <em>every</em> Julia operator&#39;s precedence, see the top of this file: <a href="https://github.com/JuliaLang/julia/blob/master/src/julia-parser.scm"><code>src/julia-parser.scm</code></a></p><p>You can also find the numerical precedence for any given operator via the built-in function <code>Base.operator_precedence</code>, where higher numbers take precedence:</p><pre><code class="language-julia-repl">julia&gt; Base.operator_precedence(:+), Base.operator_precedence(:*), Base.operator_precedence(:.)
(11, 13, 17)

julia&gt; Base.operator_precedence(:sin), Base.operator_precedence(:+=), Base.operator_precedence(:(=))  # (Note the necessary parens on `:(=)`)
(0, 1, 1)</code></pre><p>A symbol representing the operator associativity can also be found by calling the built-in function <code>Base.operator_associativity</code>:</p><pre><code class="language-julia-repl">julia&gt; Base.operator_associativity(:-), Base.operator_associativity(:+), Base.operator_associativity(:^)
(:left, :none, :right)

julia&gt; Base.operator_associativity(:⊗), Base.operator_associativity(:sin), Base.operator_associativity(:→)
(:left, :none, :right)</code></pre><p>Note that symbols such as <code>:sin</code> return precedence <code>0</code>. This value represents invalid operators and not operators of lowest precedence. Similarly, such operators are assigned associativity <code>:none</code>.</p><h2><a class="nav-anchor" id="数值转换-1" href="#数值转换-1">数值转换</a></h2><p>Julia supports three forms of numerical conversion, which differ in their handling of inexact conversions.</p><ul><li><p>The notation <code>T(x)</code> or <code>convert(T,x)</code> converts <code>x</code> to a value of type <code>T</code>.</p><ul><li>If <code>T</code> is a floating-point type, the result is the nearest representable value, which could be positive or negative infinity.</li><li>如果 <code>T</code> 为整数类型，当 <code>x</code> 不为 <code>T</code> 类型时，会触发 <code>InexactError</code></li></ul></li><li><p><code>x % T</code> converts an integer <code>x</code> to a value of integer type <code>T</code> congruent to <code>x</code> modulo <code>2^n</code>, where <code>n</code> is the number of bits in <code>T</code>. In other words, the binary representation is truncated to fit.</p></li><li><p>The <a href="manual/@ref">Rounding functions</a> take a type <code>T</code> as an optional argument. For example, <code>round(Int,x)</code> is a shorthand for <code>Int(round(x))</code>.</p></li></ul><p>The following examples show the different forms.</p><pre><code class="language-julia-repl">julia&gt; Int8(127)
127

julia&gt; Int8(128)
ERROR: InexactError: trunc(Int8, 128)
Stacktrace:
[...]

julia&gt; Int8(127.0)
127

julia&gt; Int8(3.14)
ERROR: InexactError: Int8(Int8, 3.14)
Stacktrace:
[...]

julia&gt; Int8(128.0)
ERROR: InexactError: Int8(Int8, 128.0)
Stacktrace:
[...]

julia&gt; 127 % Int8
127

julia&gt; 128 % Int8
-128

julia&gt; round(Int8,127.4)
127

julia&gt; round(Int8,127.6)
ERROR: InexactError: trunc(Int8, 128.0)
Stacktrace:
[...]</code></pre><p>See <a href="../conversion-and-promotion/#conversion-and-promotion-1">Conversion and Promotion</a> for how to define your own conversions and promotions.</p><h3><a class="nav-anchor" id="舍入函数-1" href="#舍入函数-1">舍入函数</a></h3><table><tr><th>函数</th><th>描述</th><th>返回类型</th></tr><tr><td><a href="../../stdlib/Dates/#Base.round-Tuple{TimeType,Period,RoundingMode{:NearestTiesUp}}"><code>round(x)</code></a></td><td><code>x</code> 舍到最接近的整数</td><td><code>typeof(x)</code></td></tr><tr><td><a href="../../stdlib/Dates/#Base.round-Tuple{TimeType,Period,RoundingMode{:NearestTiesUp}}"><code>round(T, x)</code></a></td><td><code>x</code> 舍到最接近的整数</td><td><code>T</code></td></tr><tr><td><a href="../../stdlib/Dates/#Base.floor-Tuple{TimeType,Period}"><code>floor(x)</code></a></td><td><code>x</code> 舍到<code>-Inf</code></td><td><code>typeof(x)</code></td></tr><tr><td><a href="../../stdlib/Dates/#Base.floor-Tuple{TimeType,Period}"><code>floor(T, x)</code></a></td><td><code>x</code> 舍到<code>-Inf</code></td><td><code>T</code></td></tr><tr><td><a href="../../stdlib/Dates/#Base.ceil-Tuple{TimeType,Period}"><code>ceil(x)</code></a></td><td>round <code>x</code> towards <code>+Inf</code></td><td><code>typeof(x)</code></td></tr><tr><td><a href="../../stdlib/Dates/#Base.ceil-Tuple{TimeType,Period}"><code>ceil(T, x)</code></a></td><td>round <code>x</code> towards <code>+Inf</code></td><td><code>T</code></td></tr><tr><td><a href="../../stdlib/Dates/#Base.trunc-Tuple{TimeType,Type{Period}}"><code>trunc(x)</code></a></td><td>round <code>x</code> towards zero</td><td><code>typeof(x)</code></td></tr><tr><td><a href="../../stdlib/Dates/#Base.trunc-Tuple{TimeType,Type{Period}}"><code>trunc(T, x)</code></a></td><td>round <code>x</code> towards zero</td><td><code>T</code></td></tr></table><h3><a class="nav-anchor" id="除法函数-1" href="#除法函数-1">除法函数</a></h3><table><tr><th>函数</th><th>描述</th></tr><tr><td><a href="../../base/math/#Base.div"><code>div(x,y)</code></a>, <code>x÷y</code></td><td>truncated division; quotient rounded towards zero</td></tr><tr><td><a href="../../base/math/#Base.fld"><code>fld(x,y)</code></a></td><td>floored division; quotient rounded towards <code>-Inf</code></td></tr><tr><td><a href="../../base/math/#Base.cld"><code>cld(x,y)</code></a></td><td>ceiling division; quotient rounded towards <code>+Inf</code></td></tr><tr><td><a href="../../base/math/#Base.rem"><code>rem(x,y)</code></a></td><td>remainder; satisfies <code>x == div(x,y)*y + rem(x,y)</code>; sign matches <code>x</code></td></tr><tr><td><a href="../../base/math/#Base.mod"><code>mod(x,y)</code></a></td><td>modulus; satisfies <code>x == fld(x,y)*y + mod(x,y)</code>; sign matches <code>y</code></td></tr><tr><td><a href="../../base/math/#Base.mod1"><code>mod1(x,y)</code></a></td><td><code>mod</code> with offset 1; returns <code>r∈(0,y]</code> for <code>y&gt;0</code> or <code>r∈[y,0)</code> for <code>y&lt;0</code>, where <code>mod(r, y) == mod(x, y)</code></td></tr><tr><td><a href="../../base/math/#Base.Math.mod2pi"><code>mod2pi(x)</code></a></td><td>modulus with respect to 2pi;  <code>0 &lt;= mod2pi(x)    &lt; 2pi</code></td></tr><tr><td><a href="../../base/math/#Base.divrem"><code>divrem(x,y)</code></a></td><td>returns <code>(div(x,y),rem(x,y))</code></td></tr><tr><td><a href="../../base/math/#Base.fldmod"><code>fldmod(x,y)</code></a></td><td>returns <code>(fld(x,y),mod(x,y))</code></td></tr><tr><td><a href="../../base/math/#Base.gcd"><code>gcd(x,y...)</code></a></td><td>greatest positive common divisor of <code>x</code>, <code>y</code>,...</td></tr><tr><td><a href="../../base/math/#Base.lcm"><code>lcm(x,y...)</code></a></td><td>least positive common multiple of <code>x</code>, <code>y</code>,...</td></tr></table><h3><a class="nav-anchor" id="符号和绝对值函数-1" href="#符号和绝对值函数-1">符号和绝对值函数</a></h3><table><tr><th>函数</th><th>描述</th></tr><tr><td><a href="../../base/math/#Base.abs"><code>abs(x)</code></a></td><td>a positive value with the magnitude of <code>x</code></td></tr><tr><td><a href="../../base/math/#Base.abs2"><code>abs2(x)</code></a></td><td>the squared magnitude of <code>x</code></td></tr><tr><td><a href="../../base/math/#Base.sign"><code>sign(x)</code></a></td><td>indicates the sign of <code>x</code>, returning -1, 0, or +1</td></tr><tr><td><a href="../../base/math/#Base.signbit"><code>signbit(x)</code></a></td><td>indicates whether the sign bit is on (true) or off (false)</td></tr><tr><td><a href="../../base/math/#Base.copysign"><code>copysign(x,y)</code></a></td><td>a value with the magnitude of <code>x</code> and the sign of <code>y</code></td></tr><tr><td><a href="../../base/math/#Base.flipsign"><code>flipsign(x,y)</code></a></td><td>a value with the magnitude of <code>x</code> and the sign of <code>x*y</code></td></tr></table><h3><a class="nav-anchor" id="幂、对数与平方根-1" href="#幂、对数与平方根-1">幂、对数与平方根</a></h3><table><tr><th>函数</th><th>描述</th></tr><tr><td><a href="../../base/math/#Base.sqrt-Tuple{Real}"><code>sqrt(x)</code></a>, <code>√x</code></td><td>square root of <code>x</code></td></tr><tr><td><a href="../../base/math/#Base.Math.cbrt"><code>cbrt(x)</code></a>, <code>∛x</code></td><td>cube root of <code>x</code></td></tr><tr><td><a href="../../base/math/#Base.Math.hypot"><code>hypot(x,y)</code></a></td><td>hypotenuse of right-angled triangle with other sides of length <code>x</code> and <code>y</code></td></tr><tr><td><a href="../../base/math/#Base.exp-Tuple{Float64}"><code>exp(x)</code></a></td><td>natural exponential function at <code>x</code></td></tr><tr><td><a href="../../base/math/#Base.expm1"><code>expm1(x)</code></a></td><td>accurate <code>exp(x)-1</code> for <code>x</code> near zero</td></tr><tr><td><a href="../../base/math/#Base.Math.ldexp"><code>ldexp(x,n)</code></a></td><td><code>x*2^n</code> computed efficiently for integer values of <code>n</code></td></tr><tr><td><a href="../../base/math/#Base.log-Tuple{Number}"><code>log(x)</code></a></td><td>natural logarithm of <code>x</code></td></tr><tr><td><a href="../../base/math/#Base.log-Tuple{Number}"><code>log(b,x)</code></a></td><td>base <code>b</code> logarithm of <code>x</code></td></tr><tr><td><a href="../../base/math/#Base.log2"><code>log2(x)</code></a></td><td>base 2 logarithm of <code>x</code></td></tr><tr><td><a href="../../base/math/#Base.log10"><code>log10(x)</code></a></td><td>base 10 logarithm of <code>x</code></td></tr><tr><td><a href="../../base/math/#Base.log1p"><code>log1p(x)</code></a></td><td>accurate <code>log(1+x)</code> for <code>x</code> near zero</td></tr><tr><td><a href="../../base/numbers/#Base.Math.exponent"><code>exponent(x)</code></a></td><td>binary exponent of <code>x</code></td></tr><tr><td><a href="../../base/numbers/#Base.Math.significand"><code>significand(x)</code></a></td><td>binary significand (a.k.a. mantissa) of a floating-point number <code>x</code></td></tr></table><p>For an overview of why functions like <a href="../../base/math/#Base.Math.hypot"><code>hypot</code></a>, <a href="../../base/math/#Base.expm1"><code>expm1</code></a>, and <a href="../../base/math/#Base.log1p"><code>log1p</code></a> are necessary and useful, see John D. Cook&#39;s excellent pair of blog posts on the subject: <a href="https://www.johndcook.com/blog/2010/06/07/math-library-functions-that-seem-unnecessary/">expm1, log1p, erfc</a>, and <a href="https://www.johndcook.com/blog/2010/06/02/whats-so-hard-about-finding-a-hypotenuse/">hypot</a>.</p><h3><a class="nav-anchor" id="三角和双曲函数-1" href="#三角和双曲函数-1">三角和双曲函数</a></h3><p>All the standard trigonometric and hyperbolic functions are also defined:</p><pre><code class="language-none">sin    cos    tan    cot    sec    csc
sinh   cosh   tanh   coth   sech   csch
asin   acos   atan   acot   asec   acsc
asinh  acosh  atanh  acoth  asech  acsch
sinc   cosc</code></pre><p>These are all single-argument functions, with <a href="../../base/math/#Base.atan-Tuple{Number}"><code>atan</code></a> also accepting two arguments corresponding to a traditional <a href="https://en.wikipedia.org/wiki/Atan2"><code>atan2</code></a> function.</p><p>Additionally, <a href="../../base/math/#Base.Math.sinpi"><code>sinpi(x)</code></a> and <a href="../../base/math/#Base.Math.cospi"><code>cospi(x)</code></a> are provided for more accurate computations of <a href="../../base/math/#Base.sin-Tuple{Number}"><code>sin(pi*x)</code></a> and <a href="../../base/math/#Base.cos-Tuple{Number}"><code>cos(pi*x)</code></a> respectively.</p><p>In order to compute trigonometric functions with degrees instead of radians, suffix the function with <code>d</code>. For example, <a href="../../base/math/#Base.Math.sind"><code>sind(x)</code></a> computes the sine of <code>x</code> where <code>x</code> is specified in degrees. The complete list of trigonometric functions with degree variants is:</p><pre><code class="language-none">sind   cosd   tand   cotd   secd   cscd
asind  acosd  atand  acotd  asecd  acscd</code></pre><h3><a class="nav-anchor" id="特殊函数-1" href="#特殊函数-1">特殊函数</a></h3><p><a href="https://github.com/JuliaMath/SpecialFunctions.jl">SpecialFunctions.jl</a> 提供了许多其他的特殊数学函数。</p><footer><hr/><a class="previous" href="../integers-and-floating-point-numbers/"><span class="direction">Previous</span><span class="title">整数和浮点数</span></a><a class="next" href="../complex-and-rational-numbers/"><span class="direction">Next</span><span class="title">复数和分数</span></a></footer></article></body></html>
