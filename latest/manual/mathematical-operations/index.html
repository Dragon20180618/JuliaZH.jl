<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>数学运算和初等函数 · Julia中文文档</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-89508993-1', 'auto');
ga('send', 'pageview');
</script><link rel="canonical" href="https://juliacn.github.io/JuliaZH.jl/latest/manual/mathematical-operations/index.html"/><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../../assets/julia-manual.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../../index.html"><img class="logo" src="../../assets/logo.png" alt="Julia中文文档 logo"/></a><h1>Julia中文文档</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">主页</a></li><li><span class="toctext">手册</span><ul><li><a class="toctext" href="../getting-started/">入门</a></li><li><a class="toctext" href="../variables/">变量</a></li><li><a class="toctext" href="../integers-and-floating-point-numbers/">整数和浮点数</a></li><li class="current"><a class="toctext" href>数学运算和初等函数</a><ul class="internal"><li><a class="toctext" href="#算术运算符-1">算术运算符</a></li><li><a class="toctext" href="#位运算符-1">位运算符</a></li><li><a class="toctext" href="#复合赋值操作符-1">复合赋值操作符</a></li><li><a class="toctext" href="#man-dot-operators-1">向量化 <code>dot</code> 运算符</a></li><li><a class="toctext" href="#数值比较-1">数值比较</a></li><li><a class="toctext" href="#运算符的优先级与结合性-1">运算符的优先级与结合性</a></li><li><a class="toctext" href="#数值转换-1">数值转换</a></li></ul></li><li><a class="toctext" href="../complex-and-rational-numbers/">复数和分数</a></li><li><a class="toctext" href="../strings/">字符串</a></li><li><a class="toctext" href="../functions/">函数</a></li><li><a class="toctext" href="../control-flow/">流程控制</a></li><li><a class="toctext" href="../variables-and-scoping/">变量作用域</a></li><li><a class="toctext" href="../types/">类型</a></li><li><a class="toctext" href="../methods/">方法</a></li><li><a class="toctext" href="../constructors/">构造函数</a></li><li><a class="toctext" href="../conversion-and-promotion/">类型转换和类型提升</a></li><li><a class="toctext" href="../interfaces/">接口</a></li><li><a class="toctext" href="../modules/">模块</a></li><li><a class="toctext" href="../documentation/">文档</a></li><li><a class="toctext" href="../metaprogramming/">元编程</a></li><li><a class="toctext" href="../arrays/">多维数组</a></li><li><a class="toctext" href="../missing/">缺失值</a></li><li><a class="toctext" href="../networking-and-streams/">网络和流</a></li><li><a class="toctext" href="../parallel-computing/">并行计算</a></li><li><a class="toctext" href="../running-external-programs/">运行外部程序</a></li><li><a class="toctext" href="../calling-c-and-fortran-code/">调用 C 和 Fortran 代码</a></li><li><a class="toctext" href="../handling-operating-system-variation/">处理操作系统差异</a></li><li><a class="toctext" href="../environment-variables/">环境变量</a></li><li><a class="toctext" href="../embedding/">嵌入 Julia</a></li><li><a class="toctext" href="../code-loading/">代码加载</a></li><li><a class="toctext" href="../profile/">性能分析</a></li><li><a class="toctext" href="../stacktraces/">栈跟踪</a></li><li><a class="toctext" href="../performance-tips/">性能建议</a></li><li><a class="toctext" href="../workflow-tips/">工作流程建议</a></li><li><a class="toctext" href="../style-guide/">代码风格指南</a></li><li><a class="toctext" href="../faq/">常见问题</a></li><li><a class="toctext" href="../noteworthy-differences/">与其他语言的显著差异</a></li><li><a class="toctext" href="../unicode-input/">Unicode 输入表</a></li></ul></li><li><span class="toctext">Base</span><ul><li><a class="toctext" href="../../base/base/">基本功能</a></li><li><a class="toctext" href="../../base/collections/">集合和数据结构</a></li><li><a class="toctext" href="../../base/math/">数学相关</a></li><li><a class="toctext" href="../../base/numbers/">Numbers</a></li><li><a class="toctext" href="../../base/strings/">字符串</a></li><li><a class="toctext" href="../../base/arrays/">Arrays</a></li><li><a class="toctext" href="../../base/parallel/">Tasks</a></li><li><a class="toctext" href="../../base/multi-threading/">多线程</a></li><li><a class="toctext" href="../../base/constants/">常量</a></li><li><a class="toctext" href="../../base/file/">文件系统</a></li><li><a class="toctext" href="../../base/io-network/">I/O 与网络</a></li><li><a class="toctext" href="../../base/punctuation/">标点符号</a></li><li><a class="toctext" href="../../base/sort/">排序及相关函数</a></li><li><a class="toctext" href="../../base/iterators/">迭代相关</a></li><li><a class="toctext" href="../../base/c/">C 接口</a></li><li><a class="toctext" href="../../base/libc/">C 标准库</a></li><li><a class="toctext" href="../../base/stacktraces/">StackTraces</a></li><li><a class="toctext" href="../../base/simd-types/">SIMD 支持</a></li></ul></li><li><span class="toctext">Standard Library</span><ul><li><a class="toctext" href="../../stdlib/Base64/">Base64</a></li><li><a class="toctext" href="../../stdlib/CRC32c/">CRC32c</a></li><li><a class="toctext" href="../../stdlib/Dates/">Dates</a></li><li><a class="toctext" href="../../stdlib/DelimitedFiles/">Delimited Files</a></li><li><a class="toctext" href="../../stdlib/Distributed/">Distributed Computing</a></li><li><a class="toctext" href="../../stdlib/FileWatching/">File Events</a></li><li><a class="toctext" href="../../stdlib/InteractiveUtils/">Interactive Utilities</a></li><li><a class="toctext" href="../../stdlib/LibGit2/">LibGit2</a></li><li><a class="toctext" href="../../stdlib/Libdl/">Dynamic Linker</a></li><li><a class="toctext" href="../../stdlib/LinearAlgebra/">线性代数</a></li><li><a class="toctext" href="../../stdlib/Logging/">Logging</a></li><li><a class="toctext" href="../../stdlib/Markdown/">Markdown</a></li><li><a class="toctext" href="../../stdlib/Mmap/">Memory-mapped I/O</a></li><li><a class="toctext" href="../../stdlib/Pkg/">Pkg</a></li><li><a class="toctext" href="../../stdlib/Printf/">Printf</a></li><li><a class="toctext" href="../../stdlib/Profile/">Profiling</a></li><li><a class="toctext" href="../../stdlib/REPL/">Julia REPL</a></li><li><a class="toctext" href="../../stdlib/Random/">Random Numbers</a></li><li><a class="toctext" href="../../stdlib/SHA/">SHA</a></li><li><a class="toctext" href="../../stdlib/Serialization/">Serialization</a></li><li><a class="toctext" href="../../stdlib/SharedArrays/">Shared Arrays</a></li><li><a class="toctext" href="../../stdlib/Sockets/">Sockets</a></li><li><a class="toctext" href="../../stdlib/SparseArrays/">Sparse Arrays</a></li><li><a class="toctext" href="../../stdlib/Statistics/">Statistics</a></li><li><a class="toctext" href="../../stdlib/Test/">Unit Testing</a></li><li><a class="toctext" href="../../stdlib/UUIDs/">UUIDs</a></li><li><a class="toctext" href="../../stdlib/Unicode/">Unicode</a></li></ul></li><li><span class="toctext">Developer Documentation</span><ul><li><a class="toctext" href="../../devdocs/reflection/">反射 与 自我检查</a></li><li><span class="toctext">Documentation of Julia&#39;s Internals</span><ul><li><a class="toctext" href="../../devdocs/init/">Julia 运行时的初始化</a></li><li><a class="toctext" href="../../devdocs/ast/">Julia 的 AST</a></li><li><a class="toctext" href="../../devdocs/types/">More about types</a></li><li><a class="toctext" href="../../devdocs/object/">Memory layout of Julia Objects</a></li><li><a class="toctext" href="../../devdocs/eval/">Eval of Julia code</a></li><li><a class="toctext" href="../../devdocs/callconv/">Calling Conventions</a></li><li><a class="toctext" href="../../devdocs/compiler/">High-level Overview of the Native-Code Generation Process</a></li><li><a class="toctext" href="../../devdocs/functions/">Julia的相关函数</a></li><li><a class="toctext" href="../../devdocs/cartesian/">Base.Cartesian</a></li><li><a class="toctext" href="../../devdocs/meta/">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="toctext" href="../../devdocs/subarrays/">SubArrays</a></li><li><a class="toctext" href="../../devdocs/isbitsunionarrays/">isbits Union Optimizations</a></li><li><a class="toctext" href="../../devdocs/sysimg/">System Image Building</a></li><li><a class="toctext" href="../../devdocs/llvm/">Working with LLVM</a></li><li><a class="toctext" href="../../devdocs/stdio/">printf() and stdio in the Julia runtime</a></li><li><a class="toctext" href="../../devdocs/boundscheck/">边界检查</a></li><li><a class="toctext" href="../../devdocs/locks/">Proper maintenance and care of multi-threading locks</a></li><li><a class="toctext" href="../../devdocs/offset-arrays/">Arrays with custom indices</a></li><li><a class="toctext" href="../../devdocs/require/">Module loading</a></li><li><a class="toctext" href="../../devdocs/inference/">Inference</a></li></ul></li><li><span class="toctext">Developing/debugging Julia&#39;s C code</span><ul><li><a class="toctext" href="../../devdocs/backtraces/">Reporting and analyzing crashes (segfaults)</a></li><li><a class="toctext" href="../../devdocs/debuggingtips/">gdb 调试提示</a></li><li><a class="toctext" href="../../devdocs/valgrind/">Using Valgrind with Julia</a></li><li><a class="toctext" href="../../devdocs/sanitizers/">Sanitizer support</a></li></ul></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>手册</li><li><a href>数学运算和初等函数</a></li></ul><a class="edit-page" href="https://github.com/JuliaCN/JuliaZH.jl/blob/master/doc/src/manual/mathematical-operations.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>数学运算和初等函数</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="数学运算和初等函数-1" href="#数学运算和初等函数-1">数学运算和初等函数</a></h1><p>Julia 为它所有的基础数值类型，提供了整套的基础算术和位运算，也提供了一套高效、可移植的标准数学函数。</p><h2><a class="nav-anchor" id="算术运算符-1" href="#算术运算符-1">算术运算符</a></h2><p>以下<a href="https://en.wikipedia.org/wiki/Arithmetic#Arithmetic_operations">算术运算符</a>支持所有的原始数值类型：</p><table><tr><th>表达式</th><th>名称</th><th>描述</th></tr><tr><td><code>+x</code></td><td>一元加法运算符</td><td>全等操作</td></tr><tr><td><code>-x</code></td><td>一元减法运算符</td><td>将值变为其相反数</td></tr><tr><td><code>x + y</code></td><td>二元加法运算符</td><td>执行加法</td></tr><tr><td><code>x - y</code></td><td>二元减法运算符</td><td>执行减法</td></tr><tr><td><code>x * y</code></td><td>乘法运算符</td><td>执行乘法</td></tr><tr><td><code>x / y</code></td><td>除法运算符</td><td>执行除法</td></tr><tr><td><code>x ÷ y</code></td><td>整除</td><td>取 x / y 的整数部分</td></tr><tr><td><code>x \ y</code></td><td>反向除法</td><td>等价于 <code>y / x</code></td></tr><tr><td><code>x ^ y</code></td><td>幂操作符</td><td><code>x</code> 的 <code>y</code> 次幂</td></tr><tr><td><code>x % y</code></td><td>取余</td><td>等价于 <code>rem(x,y)</code></td></tr></table><p>以及对 <a href="../../base/numbers/#Core.Bool"><code>Bool</code></a> 类型的否定：</p><table><tr><th>表达式</th><th>名称</th><th>描述</th></tr><tr><td><code>!x</code></td><td>否定</td><td>将 <code>true</code> 和 <code>false</code> 互换</td></tr></table><p>Julia 的类型提升系统使得混合参数类型上的代数运算也能顺其自然的工作，请参考<a href="../conversion-and-promotion/#conversion-and-promotion-1">类型提升系统</a>来了解更多内容。</p><p>这里是使用算术运算符的一些简单例子：</p><pre><code class="language-julia-repl">julia&gt; 1 + 2 + 3
6

julia&gt; 1 - 2
-1

julia&gt; 3*2/12
0.5</code></pre><p>习惯上我们会把优先运算的操作符紧邻操作数，比如 <code>-x + 2</code> 表示先要给 <code>x</code>  取反，然后再加 <code>2</code> 。</p><h2><a class="nav-anchor" id="位运算符-1" href="#位运算符-1">位运算符</a></h2><p>所有原始整数类型都支持以下<a href="https://en.wikipedia.org/wiki/Bitwise_operation#Bitwise_operators">位运算符</a>：</p><table><tr><th>表达式</th><th>名称</th></tr><tr><td><code>~x</code></td><td>按位取反</td></tr><tr><td><code>x &amp; y</code></td><td>按位与</td></tr><tr><td><code>x | y</code></td><td>按位或</td></tr><tr><td><code>x ⊻ y</code></td><td>按位异或（逻辑异或）</td></tr><tr><td><code>x &gt;&gt;&gt; y</code></td><td><a href="https://en.wikipedia.org/wiki/Logical_shift">逻辑右移</a></td></tr><tr><td><code>x &gt;&gt; y</code></td><td><a href="https://en.wikipedia.org/wiki/Arithmetic_shift">算术右移</a></td></tr><tr><td><code>x &lt;&lt; y</code></td><td>逻辑/算术左移</td></tr></table><p>以下是位运算符的一些示例：</p><pre><code class="language-julia-repl">julia&gt; ~123
-124

julia&gt; 123 &amp; 234
106

julia&gt; 123 | 234
251

julia&gt; 123 ⊻ 234
145

julia&gt; xor(123, 234)
145

julia&gt; ~UInt32(123)
0xffffff84

julia&gt; ~UInt8(123)
0x84</code></pre><h2><a class="nav-anchor" id="复合赋值操作符-1" href="#复合赋值操作符-1">复合赋值操作符</a></h2><p>每一个二元运算符和位运算符都可以给左操作数复合赋值：方法是把 <code>=</code> 直接放在二元运算符后面。比如，<code>x += 3</code> 等价于 <code>x = x + 3</code> 。</p><pre><code class="language-julia-repl">julia&gt; x = 1
1

julia&gt; x += 3
4

julia&gt; x
4</code></pre><p>二元运算和位运算的复合赋值操作符有下面几种：</p><pre><code class="language-none">+=  -=  *=  /=  \=  ÷=  %=  ^=  &amp;=  |=  ⊻=  &gt;&gt;&gt;=  &gt;&gt;=  &lt;&lt;=</code></pre><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>复合赋值后会把变量重新绑定到左操作数上，所以变量的类型可能会改变。</p><pre><code class="language-julia-repl">julia&gt; x = 0x01; typeof(x)
UInt8

julia&gt; x *= 2 # Same as x = x * 2
2

julia&gt; typeof(x)
Int64</code></pre></div></div><h2><a class="nav-anchor" id="man-dot-operators-1" href="#man-dot-operators-1">向量化 <code>dot</code> 运算符</a></h2><p>Julia 中，<strong>每个</strong>二元运算符都有一个 <code>dot</code> 运算符与之对应，例如 <code>^</code> 就有对应的 <code>.^</code> 存在。这个对应的 <code>.^</code> 被 Julia <strong>自动地</strong>定义为逐元素地执行 <code>^</code> 运算。比如 <code>[1,2,3] ^ 3</code> 是非法的，因为数学上没有给（长宽不一样的）数组的立方下过定义。但是 <code>[1,2,3] .^ 3</code> 在 Julia 里是合法的，它会逐元素地执行 <code>^</code> 运算（或称向量化运算），得到 <code>[1^3, 2^3, 3^3]</code>。类似地，<code>!</code> 或 <code>√</code> 这样的一元运算符，也都有一个对应的 <code>.√</code> 用于执行逐元素运算。</p><pre><code class="language-julia-repl">julia&gt; [1,2,3] .^ 3
3-element Array{Int64,1}:
  1
  8
 27</code></pre><p>具体来说，<code>a .^ b</code> 被解析为 <a href="../functions/#man-vectorized-1"><code>dot</code> 调用</a> <code>(^).(a,b)</code>，这会执行 <a href="manual/@ref Broadcasting">broadcast</a> 操作：该操作能结合数组和标量、相同大小的数组（元素之间的运算）、甚至不同形状的数组（例如行、列向量结合生成矩阵）。更进一步，就像所有向量化的 <code>dot</code> 调用一样，这些 <code>dot</code> 运算符是<strong>融合</strong>的（fused）。例如，在计算表达式 <code>2 .* A.^2 .+ sin.(A)</code> 时，Julia 只对 <code>A</code> 进行做<strong>一次</strong>循环，遍历 <code>A</code> 中的每个元素 a 并计算 <code>2a^2 + sin(a)</code>。上诉表达式也可以用<a href="../../base/arrays/#Base.Broadcast.@__dot__"><code>@.</code></a> 宏简写为 <code>@. 2A^2 + sin(A)</code>。特别的，类似 <code>f.(g.(x))</code> 的嵌套 <code>dot</code> 调用也是<strong>融合</strong>的，并且“相邻的”二元运算符表达式 <code>x .+ 3 .* x.^2</code> 可以等价转换为嵌套 <code>dot</code> 调用：<code>(+).(x, (*).(3, (^).(x, 2)))</code>。</p><p>除了 <code>dot</code> 运算符，我们还有 <code>dot</code> 复合赋值运算符，类似 <code>a .+= b</code>（或者 <code>@. a += b</code>）会被解析成 <code>a .= a .+ b</code>，这里的 <code>.=</code> 是一个<strong>融合</strong>的 in-place 运算，更多信息请查看 <a href="../functions/#man-vectorized-1"><code>dot</code> 文档</a>）。</p><p>这个加点的语法，也能用在用户自定义的运算符上。For example, if you define <code>⊗(A,B) = kron(A,B)</code> to give a convenient infix syntax <code>A ⊗ B</code> for Kronecker products (<a href="../../stdlib/LinearAlgebra/#Base.kron"><code>kron</code></a>), then <code>[A,B] .⊗ [C,D]</code> will compute <code>[A⊗C, B⊗D]</code> with no additional coding.</p><p>将点运算符用于数值字面量可能会导致歧义。<code>1.+x</code> 是表示 <code>1. + x</code> 呢还是  <code>1 .+ x</code> ？这叫人疑惑。因此不允许使用这种语法，遇到这种情况时，必须明确地用空格消除歧义。</p><h2><a class="nav-anchor" id="数值比较-1" href="#数值比较-1">数值比较</a></h2><p>标准的比较操作对所有原始数值类型有定义：</p><table><tr><th>操作符</th><th>名称</th></tr><tr><td><a href="../../base/math/#Base.:=="><code>==</code></a></td><td>相等</td></tr><tr><td><a href="../../base/math/#Base.:!="><code>!=</code></a>, <a href="../../base/math/#Base.:!="><code>≠</code></a></td><td>不等</td></tr><tr><td><a href="../../base/math/#Base.:&lt;"><code>&lt;</code></a></td><td>小于</td></tr><tr><td><a href="../../base/math/#Base.:&lt;="><code>&lt;=</code></a>, <a href="../../base/math/#Base.:&lt;="><code>≤</code></a></td><td>小于等于</td></tr><tr><td><a href="../../base/math/#Base.:&gt;"><code>&gt;</code></a></td><td>大于</td></tr><tr><td><a href="../../base/math/#Base.:&gt;="><code>&gt;=</code></a>, <a href="../../base/math/#Base.:&gt;="><code>≥</code></a></td><td>大于等于</td></tr></table><p>下面是一些简单的例子：</p><pre><code class="language-julia-repl">julia&gt; 1 == 1
true

julia&gt; 1 == 2
false

julia&gt; 1 != 2
true

julia&gt; 1 == 1.0
true

julia&gt; 1 &lt; 2
true

julia&gt; 1.0 &gt; 3
false

julia&gt; 1 &gt;= 1.0
true

julia&gt; -1 &lt;= 1
true

julia&gt; -1 &lt;= -1
true

julia&gt; -1 &lt;= -2
false

julia&gt; 3 &lt; -0.5
false</code></pre><p>整数的比较以标准方式——按位比较，而浮点数的比较以 <a href="https://en.wikipedia.org/wiki/IEEE_754-2008">IEEE 754 标准</a>。</p><ul><li>有限数的大小顺序，和我们所熟知的相同。</li><li><code>+0</code> 等于但不大于 <code>-0</code>.</li><li><code>Inf</code> 等于自身，并且大于除了 <code>NaN</code> 外的所有数。</li><li><code>-Inf</code> 等于自身，并且小于除了 <code>NaN</code> 外的所有数。</li><li><code>NaN</code> “不具有可比性”，它与任何数值（甚至包括它自己）做大小比较，结果都是 false；并且与任何数值（包括它自己）做不等比较，结果都为 true.</li></ul><p><code>NaN</code> 的“不可比性”可能有点奇特，这里举例说明一下：</p><pre><code class="language-julia-repl">julia&gt; NaN == NaN
false

julia&gt; NaN != NaN
true

julia&gt; NaN &lt; NaN
false

julia&gt; NaN &gt; NaN
false</code></pre><p>在做<a href="../arrays/#man-multi-dim-arrays-1">数组</a>比较时，<code>NaN</code> 的存在，会使比较结果变得很奇怪：</p><pre><code class="language-julia-repl">julia&gt; [1 NaN] == [1 NaN]
false</code></pre><p>为此，Julia 给这些 <em>非有限数</em> 提供了下面几个额外的测试函数。这些函数在有些情况下很有用处，比如在做 hash 比较时。</p><table><tr><th>函数</th><th>测试是否满足如下性质</th></tr><tr><td><a href="../../base/base/#Base.isequal"><code>isequal(x, y)</code></a></td><td><code>x</code> 与 <code>y</code> 是完全相同的</td></tr><tr><td><a href="../../base/numbers/#Base.isfinite"><code>isfinite(x)</code></a></td><td><code>x</code> 是有限大的数字</td></tr><tr><td><a href="../../base/numbers/#Base.isinf"><code>isinf(x)</code></a></td><td><code>x</code> 是（正/负）无穷大</td></tr><tr><td><a href="../../base/numbers/#Base.isnan"><code>isnan(x)</code></a></td><td><code>x</code> 是 <code>NaN</code></td></tr></table><p><a href="../../base/base/#Base.isequal"><code>isequal</code></a> 认为 <code>NaN</code> 之间是相等的：</p><pre><code class="language-julia-repl">julia&gt; isequal(NaN, NaN)
true

julia&gt; isequal([1 NaN], [1 NaN])
true

julia&gt; isequal(NaN, NaN32)
true</code></pre><p><code>isequal</code> 也能用来区分带符号的零：</p><pre><code class="language-julia-repl">julia&gt; -0.0 == 0.0
true

julia&gt; isequal(-0.0, 0.0)
false</code></pre><p>有符号整数、无符号整数以及浮点数之间的混合类型比较是很棘手的。开发者费了很大精力来确保 Julia 在这个问题上做的是正确的。</p><p>对于其它类型，<code>isequal</code> 会默认调用 <a href="../../base/math/#Base.:=="><code>==</code></a>，所以如果你想给自己的类型定义相等，那么就只需要为 <a href="../../base/math/#Base.:=="><code>==</code></a> 增加一个方法。如果你想自己定义一个相等函数，你可能需要定义一个对应的 <a href="../../base/base/#Base.hash"><code>hash</code></a> 方法，用于确保 <code>isequal(x,y)</code> 隐含着 <code>hash(x) == hash(y)</code>。</p><h3><a class="nav-anchor" id="链式比较-1" href="#链式比较-1">链式比较</a></h3><p>与其它语言不通，with the <a href="https://en.wikipedia.org/wiki/Python_syntax_and_semantics#Comparison_operators">notable exception of Python</a>，Julia 允许链式比较：</p><pre><code class="language-julia-repl">julia&gt; 1 &lt; 2 &lt;= 2 &lt; 3 == 3 &gt; 2 &gt;= 1 == 1 &lt; 3 != 5
true</code></pre><p>Chaining comparisons is often quite convenient in numerical code. Chained comparisons use the <code>&amp;&amp;</code> operator for scalar comparisons, and the <a href="../../base/math/#Base.:&amp;"><code>&amp;</code></a> operator for elementwise comparisons, which allows them to work on arrays. For example, <code>0 .&lt; A .&lt; 1</code> gives a boolean array whose entries are true where the corresponding elements of <code>A</code> are between 0 and 1.</p><p>注意链式比较的执行顺序：</p><pre><code class="language-julia-repl">julia&gt; v(x) = (println(x); x)
v (generic function with 1 method)

julia&gt; v(1) &lt; v(2) &lt;= v(3)
2
1
3
true

julia&gt; v(1) &gt; v(2) &lt;= v(3)
2
1
false</code></pre><p>The middle expression is only evaluated once, rather than twice as it would be if the expression were written as <code>v(1) &lt; v(2) &amp;&amp; v(2) &lt;= v(3)</code>. However, the order of evaluations in a chained comparison is undefined. It is strongly recommended not to use expressions with side effects (such as printing) in chained comparisons. If side effects are required, the short-circuit <code>&amp;&amp;</code> operator should be used explicitly (see <a href="manual/@ref">Short-Circuit Evaluation</a>).</p><h3><a class="nav-anchor" id="初等函数-1" href="#初等函数-1">初等函数</a></h3><p>Julia provides a comprehensive collection of mathematical functions and operators. These mathematical operations are defined over as broad a class of numerical values as permit sensible definitions, including integers, floating-point numbers, rationals, and complex numbers, wherever such definitions make sense.</p><p>Moreover, these functions (like any Julia function) can be applied in &quot;vectorized&quot; fashion to arrays and other collections with the <a href="../functions/#man-vectorized-1">dot syntax</a> <code>f.(A)</code>, e.g. <code>sin.(A)</code> will compute the sine of each element of an array <code>A</code>.</p><h2><a class="nav-anchor" id="运算符的优先级与结合性-1" href="#运算符的优先级与结合性-1">运算符的优先级与结合性</a></h2><p>从高到低，Julia 运算符的优先级与结合性为：</p><table><tr><th>分类</th><th>运算符</th><th>结合性</th></tr><tr><td>语法</td><td><code>.</code> followed by <code>::</code></td><td>左结合</td></tr><tr><td>幂运算</td><td><code>^</code></td><td>右结合</td></tr><tr><td>一元运算符</td><td><code>+ - √</code></td><td>右结合<a href="#footnote-1">[1]</a></td></tr><tr><td>移位运算</td><td><code>&lt;&lt; &gt;&gt; &gt;&gt;&gt;</code></td><td>左结合</td></tr><tr><td>除法</td><td><code>//</code></td><td>左结合</td></tr><tr><td>乘法</td><td><code>* / % &amp; \ ÷</code></td><td>左结合<a href="#footnote-2">[2]</a></td></tr><tr><td>加法</td><td><code>+ - | ⊻</code></td><td>左结合<a href="#footnote-2">[2]</a></td></tr><tr><td>语法</td><td><code>: ..</code></td><td>左结合</td></tr><tr><td>语法</td><td><code>|&gt;</code></td><td>左结合</td></tr><tr><td>语法</td><td><code>&lt;|</code></td><td>右结合</td></tr><tr><td>比较</td><td><code>&gt; &lt; &gt;= &lt;= == === != !== &lt;:</code></td><td>无结合性</td></tr><tr><td>控制流程</td><td><code>&amp;&amp;</code> followed by <code>||</code> followed by <code>?</code></td><td>右结合</td></tr><tr><td>Pair 操作</td><td><code>=&gt;</code></td><td>右结合</td></tr><tr><td>赋值</td><td><code>= += -= *= /= //= \= ^= ÷= %= |= &amp;= ⊻= &lt;&lt;= &gt;&gt;= &gt;&gt;&gt;=</code></td><td>右结合</td></tr></table><div class="footnote" id="footnote-1"><a href="#footnote-1"><strong>[1]</strong></a><p>The unary operators <code>+</code> and <code>-</code> require explicit parentheses around their argument to disambiguate them from the operator <code>++</code>, etc. Other compositions of unary operators are parsed with right-associativity, e. g., <code>√√-a</code> as <code>√(√(-a))</code>.</p></div><div class="footnote" id="footnote-2"><a href="#footnote-2"><strong>[2]</strong></a><p>The operators <code>+</code>, <code>++</code> and <code>*</code> are non-associative. <code>a + b + c</code> is parsed as <code>+(a, b, c)</code> not <code>+(+(a, b), c)</code>. However, the fallback methods for <code>+(a, b, c, d...)</code> and <code>*(a, b, c, d...)</code> both default to left-associative evaluation.</p></div><p>For a complete list of <em>every</em> Julia operator&#39;s precedence, see the top of this file: <a href="https://github.com/JuliaLang/julia/blob/master/src/julia-parser.scm"><code>src/julia-parser.scm</code></a></p><p>You can also find the numerical precedence for any given operator via the built-in function <code>Base.operator_precedence</code>, where higher numbers take precedence:</p><pre><code class="language-julia-repl">julia&gt; Base.operator_precedence(:+), Base.operator_precedence(:*), Base.operator_precedence(:.)
(11, 13, 17)

julia&gt; Base.operator_precedence(:sin), Base.operator_precedence(:+=), Base.operator_precedence(:(=))  # (Note the necessary parens on `:(=)`)
(0, 1, 1)</code></pre><p>A symbol representing the operator associativity can also be found by calling the built-in function <code>Base.operator_associativity</code>:</p><pre><code class="language-julia-repl">julia&gt; Base.operator_associativity(:-), Base.operator_associativity(:+), Base.operator_associativity(:^)
(:left, :none, :right)

julia&gt; Base.operator_associativity(:⊗), Base.operator_associativity(:sin), Base.operator_associativity(:→)
(:left, :none, :right)</code></pre><p>Note that symbols such as <code>:sin</code> return precedence <code>0</code>. This value represents invalid operators and not operators of lowest precedence. Similarly, such operators are assigned associativity <code>:none</code>.</p><h2><a class="nav-anchor" id="数值转换-1" href="#数值转换-1">数值转换</a></h2><p>Julia supports three forms of numerical conversion, which differ in their handling of inexact conversions.</p><ul><li><p>The notation <code>T(x)</code> or <code>convert(T,x)</code> converts <code>x</code> to a value of type <code>T</code>.</p><ul><li>If <code>T</code> is a floating-point type, the result is the nearest representable value, which could be positive or negative infinity.</li><li>如果 <code>T</code> 为整数类型，当 <code>x</code> 不为 <code>T</code> 类型时，会触发 <code>InexactError</code></li></ul></li><li><p><code>x % T</code> converts an integer <code>x</code> to a value of integer type <code>T</code> congruent to <code>x</code> modulo <code>2^n</code>, where <code>n</code> is the number of bits in <code>T</code>. In other words, the binary representation is truncated to fit.</p></li><li><p>The <a href="manual/@ref">Rounding functions</a> take a type <code>T</code> as an optional argument. For example, <code>round(Int,x)</code> is a shorthand for <code>Int(round(x))</code>.</p></li></ul><p>下面的例子展示了不同的形式</p><pre><code class="language-julia-repl">julia&gt; Int8(127)
127

julia&gt; Int8(128)
ERROR: InexactError: trunc(Int8, 128)
Stacktrace:
[...]

julia&gt; Int8(127.0)
127

julia&gt; Int8(3.14)
ERROR: InexactError: Int8(Int8, 3.14)
Stacktrace:
[...]

julia&gt; Int8(128.0)
ERROR: InexactError: Int8(Int8, 128.0)
Stacktrace:
[...]

julia&gt; 127 % Int8
127

julia&gt; 128 % Int8
-128

julia&gt; round(Int8,127.4)
127

julia&gt; round(Int8,127.6)
ERROR: InexactError: trunc(Int8, 128.0)
Stacktrace:
[...]</code></pre><p>请参考<a href="../conversion-and-promotion/#conversion-and-promotion-1">类型转换与类型提升</a>一节来定义你自己的类型转换和提升规则。</p><h3><a class="nav-anchor" id="舍入函数-1" href="#舍入函数-1">舍入函数</a></h3><table><tr><th>函数</th><th>描述</th><th>返回类型</th></tr><tr><td><a href="../../stdlib/Dates/#Base.round-Tuple{TimeType,Period,RoundingMode{:NearestTiesUp}}"><code>round(x)</code></a></td><td><code>x</code> 舍到最接近的整数</td><td><code>typeof(x)</code></td></tr><tr><td><a href="../../stdlib/Dates/#Base.round-Tuple{TimeType,Period,RoundingMode{:NearestTiesUp}}"><code>round(T, x)</code></a></td><td><code>x</code> 舍到最接近的整数</td><td><code>T</code></td></tr><tr><td><a href="../../stdlib/Dates/#Base.floor-Tuple{TimeType,Period}"><code>floor(x)</code></a></td><td><code>x</code> 舍到<code>-Inf</code></td><td><code>typeof(x)</code></td></tr><tr><td><a href="../../stdlib/Dates/#Base.floor-Tuple{TimeType,Period}"><code>floor(T, x)</code></a></td><td><code>x</code> 舍到<code>-Inf</code></td><td><code>T</code></td></tr><tr><td><a href="../../stdlib/Dates/#Base.ceil-Tuple{TimeType,Period}"><code>ceil(x)</code></a></td><td>round <code>x</code> towards <code>+Inf</code></td><td><code>typeof(x)</code></td></tr><tr><td><a href="../../stdlib/Dates/#Base.ceil-Tuple{TimeType,Period}"><code>ceil(T, x)</code></a></td><td>round <code>x</code> towards <code>+Inf</code></td><td><code>T</code></td></tr><tr><td><a href="../../stdlib/Dates/#Base.trunc-Tuple{TimeType,Type{Period}}"><code>trunc(x)</code></a></td><td>round <code>x</code> towards zero</td><td><code>typeof(x)</code></td></tr><tr><td><a href="../../stdlib/Dates/#Base.trunc-Tuple{TimeType,Type{Period}}"><code>trunc(T, x)</code></a></td><td>round <code>x</code> towards zero</td><td><code>T</code></td></tr></table><h3><a class="nav-anchor" id="除法函数-1" href="#除法函数-1">除法函数</a></h3><table><tr><th>函数</th><th>描述</th></tr><tr><td><a href="../../base/math/#Base.div"><code>div(x,y)</code></a>, <code>x÷y</code></td><td>截断除法；商向零近似</td></tr><tr><td><a href="../../base/math/#Base.fld"><code>fld(x,y)</code></a></td><td>向下取整除法；商向 <code>-Inf</code> 近似</td></tr><tr><td><a href="../../base/math/#Base.cld"><code>cld(x,y)</code></a></td><td>向上取整除法；商向 <code>+Inf</code> 近似</td></tr><tr><td><a href="../../base/math/#Base.rem"><code>rem(x,y)</code></a></td><td>取余；满足 <code>x == div(x,y)*y + rem(x,y)</code>；符号与 <code>x</code> 一致</td></tr><tr><td><a href="../../base/math/#Base.mod"><code>mod(x,y)</code></a></td><td>取模；满足 <code>x == fld(x,y)*y + mod(x,y)</code>；符号与 <code>y</code> 一致</td></tr><tr><td><a href="../../base/math/#Base.mod1"><code>mod1(x,y)</code></a></td><td>偏移 1 的 <code>mod</code>；若 <code>y&gt;0</code>，则返回 <code>r∈(0,y]</code>，若 <code>y&lt;0</code>，则 <code>r∈[y,0)</code> 且满足 <code>mod(r, y) == mod(x, y)</code></td></tr><tr><td><a href="../../base/math/#Base.Math.mod2pi"><code>mod2pi(x)</code></a></td><td>以 2pi 为基取模；<code>0 &lt;= mod2pi(x) &lt; 2pi</code></td></tr><tr><td><a href="../../base/math/#Base.divrem"><code>divrem(x,y)</code></a></td><td>返回 <code>(div(x,y),rem(x,y))</code></td></tr><tr><td><a href="../../base/math/#Base.fldmod"><code>fldmod(x,y)</code></a></td><td>返回 <code>(fld(x,y),mod(x,y))</code></td></tr><tr><td><a href="../../base/math/#Base.gcd"><code>gcd(x,y...)</code></a></td><td><code>x</code>, <code>y</code>,... 的最大公约数</td></tr><tr><td><a href="../../base/math/#Base.lcm"><code>lcm(x,y...)</code></a></td><td><code>x</code>, <code>y</code>,... 的最小公倍数</td></tr></table><h3><a class="nav-anchor" id="符号和绝对值函数-1" href="#符号和绝对值函数-1">符号和绝对值函数</a></h3><table><tr><th>函数</th><th>描述</th></tr><tr><td><a href="../../base/math/#Base.abs"><code>abs(x)</code></a></td><td><code>x</code> 的模</td></tr><tr><td><a href="../../base/math/#Base.abs2"><code>abs2(x)</code></a></td><td><code>x</code> 的模的平方</td></tr><tr><td><a href="../../base/math/#Base.sign"><code>sign(x)</code></a></td><td>表示 <code>x</code> 的符号，返回 -1，0，或 +1</td></tr><tr><td><a href="../../base/math/#Base.signbit"><code>signbit(x)</code></a></td><td>表示符号位是开启的(true)或关闭的(false)</td></tr><tr><td><a href="../../base/math/#Base.copysign"><code>copysign(x,y)</code></a></td><td>返回一个数，其值等于 <code>x</code> 的模，符号与 <code>y</code> 一致</td></tr><tr><td><a href="../../base/math/#Base.flipsign"><code>flipsign(x,y)</code></a></td><td>返回一个数，其值等于 <code>x</code> 的模，符号与 <code>x*y</code> 一致</td></tr></table><h3><a class="nav-anchor" id="幂、对数与平方根-1" href="#幂、对数与平方根-1">幂、对数与平方根</a></h3><table><tr><th>函数</th><th>描述</th></tr><tr><td><a href="../../base/math/#Base.sqrt-Tuple{Real}"><code>sqrt(x)</code></a>, <code>√x</code></td><td><code>x</code> 的平方根</td></tr><tr><td><a href="../../base/math/#Base.Math.cbrt"><code>cbrt(x)</code></a>, <code>∛x</code></td><td><code>x</code> 的立方根</td></tr><tr><td><a href="../../base/math/#Base.Math.hypot"><code>hypot(x,y)</code></a></td><td>当直角边的长度为 <code>x</code> 和 <code>y</code>时，直角三角形斜边的长度</td></tr><tr><td><a href="../../base/math/#Base.exp-Tuple{Float64}"><code>exp(x)</code></a></td><td>自然指数函数在 <code>x</code> 处的值</td></tr><tr><td><a href="../../base/math/#Base.expm1"><code>expm1(x)</code></a></td><td>当 <code>x</code> 接近 0 时的 <code>exp(x)-1</code> 的精确值</td></tr><tr><td><a href="../../base/math/#Base.Math.ldexp"><code>ldexp(x,n)</code></a></td><td><code>x*2^n</code> 的高效算法，<code>n</code> 为整数</td></tr><tr><td><a href="../../base/math/#Base.log-Tuple{Number}"><code>log(x)</code></a></td><td><code>x</code> 的自然对数</td></tr><tr><td><a href="../../base/math/#Base.log-Tuple{Number}"><code>log(b,x)</code></a></td><td>以 <code>b</code> 为底 <code>x</code> 的对数</td></tr><tr><td><a href="../../base/math/#Base.log2"><code>log2(x)</code></a></td><td>以 2 为底 <code>x</code> 的对数</td></tr><tr><td><a href="../../base/math/#Base.log10"><code>log10(x)</code></a></td><td>以 10 为底 <code>x</code> 的对数</td></tr><tr><td><a href="../../base/math/#Base.log1p"><code>log1p(x)</code></a></td><td>当 <code>x</code>接近 0 时的 <code>log(1+x)</code> 的精确值</td></tr><tr><td><a href="../../base/numbers/#Base.Math.exponent"><code>exponent(x)</code></a></td><td>binary exponent of <code>x</code></td></tr><tr><td><a href="../../base/numbers/#Base.Math.significand"><code>significand(x)</code></a></td><td>binary significand (a.k.a. mantissa) of a floating-point number <code>x</code></td></tr></table><p>For an overview of why functions like <a href="../../base/math/#Base.Math.hypot"><code>hypot</code></a>, <a href="../../base/math/#Base.expm1"><code>expm1</code></a>, and <a href="../../base/math/#Base.log1p"><code>log1p</code></a> are necessary and useful, see John D. Cook&#39;s excellent pair of blog posts on the subject: <a href="https://www.johndcook.com/blog/2010/06/07/math-library-functions-that-seem-unnecessary/">expm1, log1p, erfc</a>, and <a href="https://www.johndcook.com/blog/2010/06/02/whats-so-hard-about-finding-a-hypotenuse/">hypot</a>.</p><h3><a class="nav-anchor" id="三角和双曲函数-1" href="#三角和双曲函数-1">三角和双曲函数</a></h3><p>All the standard trigonometric and hyperbolic functions are also defined:</p><pre><code class="language-none">sin    cos    tan    cot    sec    csc
sinh   cosh   tanh   coth   sech   csch
asin   acos   atan   acot   asec   acsc
asinh  acosh  atanh  acoth  asech  acsch
sinc   cosc</code></pre><p>These are all single-argument functions, with <a href="../../base/math/#Base.atan-Tuple{Number}"><code>atan</code></a> also accepting two arguments corresponding to a traditional <a href="https://en.wikipedia.org/wiki/Atan2"><code>atan2</code></a> function.</p><p>Additionally, <a href="../../base/math/#Base.Math.sinpi"><code>sinpi(x)</code></a> and <a href="../../base/math/#Base.Math.cospi"><code>cospi(x)</code></a> are provided for more accurate computations of <a href="../../base/math/#Base.sin-Tuple{Number}"><code>sin(pi*x)</code></a> and <a href="../../base/math/#Base.cos-Tuple{Number}"><code>cos(pi*x)</code></a> respectively.</p><p>In order to compute trigonometric functions with degrees instead of radians, suffix the function with <code>d</code>. For example, <a href="../../base/math/#Base.Math.sind"><code>sind(x)</code></a> computes the sine of <code>x</code> where <code>x</code> is specified in degrees. The complete list of trigonometric functions with degree variants is:</p><pre><code class="language-none">sind   cosd   tand   cotd   secd   cscd
asind  acosd  atand  acotd  asecd  acscd</code></pre><h3><a class="nav-anchor" id="特殊函数-1" href="#特殊函数-1">特殊函数</a></h3><p><a href="https://github.com/JuliaMath/SpecialFunctions.jl">SpecialFunctions.jl</a> 提供了许多其他的特殊数学函数。</p><footer><hr/><a class="previous" href="../integers-and-floating-point-numbers/"><span class="direction">Previous</span><span class="title">整数和浮点数</span></a><a class="next" href="../complex-and-rational-numbers/"><span class="direction">Next</span><span class="title">复数和分数</span></a></footer></article></body></html>
