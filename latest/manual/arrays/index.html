<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>多维数组 · Julia中文文档</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-89508993-1', 'auto');
ga('send', 'pageview');
</script><link rel="canonical" href="https://juliacn.github.io/JuliaZH.jl/latest/manual/arrays/index.html"/><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../../assets/julia-manual.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../../index.html"><img class="logo" src="../../assets/logo.png" alt="Julia中文文档 logo"/></a><h1>Julia中文文档</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">主页</a></li><li><span class="toctext">手册</span><ul><li><a class="toctext" href="../getting-started/">入门</a></li><li><a class="toctext" href="../variables/">变量</a></li><li><a class="toctext" href="../integers-and-floating-point-numbers/">整数和浮点数</a></li><li><a class="toctext" href="../mathematical-operations/">数学运算和初等函数</a></li><li><a class="toctext" href="../complex-and-rational-numbers/">复数和有理数</a></li><li><a class="toctext" href="../strings/">字符串</a></li><li><a class="toctext" href="../functions/">函数</a></li><li><a class="toctext" href="../control-flow/">流程控制</a></li><li><a class="toctext" href="../variables-and-scoping/">Scope变量</a></li><li><a class="toctext" href="../types/">类型</a></li><li><a class="toctext" href="../methods/">方法</a></li><li><a class="toctext" href="../constructors/">构造函数</a></li><li><a class="toctext" href="../conversion-and-promotion/">类型转换和类型提升</a></li><li><a class="toctext" href="../interfaces/">接口</a></li><li><a class="toctext" href="../modules/">Modules</a></li><li><a class="toctext" href="../documentation/">文档</a></li><li><a class="toctext" href="../metaprogramming/">元编程</a></li><li class="current"><a class="toctext" href>多维数组</a><ul class="internal"><li><a class="toctext" href="#基本函数-1">基本函数</a></li><li><a class="toctext" href="#构造和初始化-1">构造和初始化</a></li><li><a class="toctext" href="#拼接-1">拼接</a></li><li><a class="toctext" href="#类型数组初始化-1">类型数组初始化</a></li><li><a class="toctext" href="#推导式-1">推导式</a></li><li><a class="toctext" href="#生成器表达式-1">生成器表达式</a></li><li><a class="toctext" href="#man-array-indexing-1">索引</a></li><li><a class="toctext" href="#赋值-1">赋值</a></li><li><a class="toctext" href="#man-supported-index-types-1">支持的索引类型</a></li><li><a class="toctext" href="#迭代-1">迭代</a></li><li><a class="toctext" href="#数组特点-1">数组特点</a></li><li><a class="toctext" href="#数组、矢量化操作符及函数-1">数组、矢量化操作符及函数</a></li><li><a class="toctext" href="#广播-1">广播</a></li><li><a class="toctext" href="#实现-1">实现</a></li></ul></li><li><a class="toctext" href="../missing/">缺失值</a></li><li><a class="toctext" href="../networking-and-streams/">网络和流</a></li><li><a class="toctext" href="../parallel-computing/">并行计算</a></li><li><a class="toctext" href="../running-external-programs/">运行外部程序</a></li><li><a class="toctext" href="../calling-c-and-fortran-code/">调用 C 和 Fortran 代码</a></li><li><a class="toctext" href="../handling-operating-system-variation/">处理操作系统差异</a></li><li><a class="toctext" href="../environment-variables/">环境变量</a></li><li><a class="toctext" href="../embedding/">嵌入 Julia</a></li><li><a class="toctext" href="../code-loading/">代码加载</a></li><li><a class="toctext" href="../profile/">分析</a></li><li><a class="toctext" href="../stacktraces/">堆栈跟踪</a></li><li><a class="toctext" href="../performance-tips/">性能建议</a></li><li><a class="toctext" href="../workflow-tips/">工作流程建议</a></li><li><a class="toctext" href="../style-guide/">代码风格指南</a></li><li><a class="toctext" href="../faq/">常见问题</a></li><li><a class="toctext" href="../noteworthy-differences/">与其他语言的显著差异</a></li><li><a class="toctext" href="../unicode-input/">Unicode输入表</a></li></ul></li><li><span class="toctext">Base</span><ul><li><a class="toctext" href="../../base/base/">Essentials</a></li><li><a class="toctext" href="../../base/collections/">集合和数据结构</a></li><li><a class="toctext" href="../../base/math/">Mathematics</a></li><li><a class="toctext" href="../../base/numbers/">Numbers</a></li><li><a class="toctext" href="../../base/strings/">【字符串】（@id lib-strings）</a></li><li><a class="toctext" href="../../base/arrays/">Arrays</a></li><li><a class="toctext" href="../../base/parallel/">Tasks</a></li><li><a class="toctext" href="../../base/multi-threading/">多线程</a></li><li><a class="toctext" href="../../base/constants/">Constants</a></li><li><a class="toctext" href="../../base/file/">文件系统</a></li><li><a class="toctext" href="../../base/io-network/">I/O and Network</a></li><li><a class="toctext" href="../../base/punctuation/">Punctuation</a></li><li><a class="toctext" href="../../base/sort/">排序及相关函数</a></li><li><a class="toctext" href="../../base/iterators/">Iteration utilities</a></li><li><a class="toctext" href="../../base/c/">C Interface</a></li><li><a class="toctext" href="../../base/libc/">C Standard Library</a></li><li><a class="toctext" href="../../base/stacktraces/">StackTraces</a></li><li><a class="toctext" href="../../base/simd-types/">SIMD Support</a></li></ul></li><li><span class="toctext">Standard Library</span><ul><li><a class="toctext" href="../../stdlib/Base64/">Base64</a></li><li><a class="toctext" href="../../stdlib/CRC32c/">CRC32c</a></li><li><a class="toctext" href="../../stdlib/Dates/">Dates</a></li><li><a class="toctext" href="../../stdlib/DelimitedFiles/">Delimited Files</a></li><li><a class="toctext" href="../../stdlib/Distributed/">Distributed Computing</a></li><li><a class="toctext" href="../../stdlib/FileWatching/">File Events</a></li><li><a class="toctext" href="../../stdlib/InteractiveUtils/">Interactive Utilities</a></li><li><a class="toctext" href="../../stdlib/LibGit2/">LibGit2</a></li><li><a class="toctext" href="../../stdlib/Libdl/">Dynamic Linker</a></li><li><a class="toctext" href="../../stdlib/LinearAlgebra/">Linear Algebra</a></li><li><a class="toctext" href="../../stdlib/Logging/">Logging</a></li><li><a class="toctext" href="../../stdlib/Markdown/">Markdown</a></li><li><a class="toctext" href="../../stdlib/Mmap/">Memory-mapped I/O</a></li><li><a class="toctext" href="../../stdlib/Pkg/">Pkg</a></li><li><a class="toctext" href="../../stdlib/Printf/">Printf</a></li><li><a class="toctext" href="../../stdlib/Profile/">Profiling</a></li><li><a class="toctext" href="../../stdlib/REPL/">The Julia REPL</a></li><li><a class="toctext" href="../../stdlib/Random/">Random Numbers</a></li><li><a class="toctext" href="../../stdlib/SHA/">SHA</a></li><li><a class="toctext" href="../../stdlib/Serialization/">Serialization</a></li><li><a class="toctext" href="../../stdlib/SharedArrays/">Shared Arrays</a></li><li><a class="toctext" href="../../stdlib/Sockets/">Sockets</a></li><li><a class="toctext" href="../../stdlib/SparseArrays/">Sparse Arrays</a></li><li><a class="toctext" href="../../stdlib/Statistics/">Statistics</a></li><li><a class="toctext" href="../../stdlib/Test/">Unit Testing</a></li><li><a class="toctext" href="../../stdlib/UUIDs/">UUIDs</a></li><li><a class="toctext" href="../../stdlib/Unicode/">Unicode</a></li></ul></li><li><span class="toctext">Developer Documentation</span><ul><li><a class="toctext" href="../../devdocs/reflection/">Reflection and introspection</a></li><li><span class="toctext">Documentation of Julia&#39;s Internals</span><ul><li><a class="toctext" href="../../devdocs/init/">Julia 运行时的初始化</a></li><li><a class="toctext" href="../../devdocs/ast/">Julia ASTs</a></li><li><a class="toctext" href="../../devdocs/types/">More about types</a></li><li><a class="toctext" href="../../devdocs/object/">Memory layout of Julia Objects</a></li><li><a class="toctext" href="../../devdocs/eval/">Eval of Julia code</a></li><li><a class="toctext" href="../../devdocs/callconv/">Calling Conventions</a></li><li><a class="toctext" href="../../devdocs/compiler/">High-level Overview of the Native-Code Generation Process</a></li><li><a class="toctext" href="../../devdocs/functions/">Julia Functions</a></li><li><a class="toctext" href="../../devdocs/cartesian/">Base.Cartesian</a></li><li><a class="toctext" href="../../devdocs/meta/">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="toctext" href="../../devdocs/subarrays/">SubArrays</a></li><li><a class="toctext" href="../../devdocs/isbitsunionarrays/">isbits Union Optimizations</a></li><li><a class="toctext" href="../../devdocs/sysimg/">System Image Building</a></li><li><a class="toctext" href="../../devdocs/llvm/">Working with LLVM</a></li><li><a class="toctext" href="../../devdocs/stdio/">printf() and stdio in the Julia runtime</a></li><li><a class="toctext" href="../../devdocs/boundscheck/">边界检查</a></li><li><a class="toctext" href="../../devdocs/locks/">Proper maintenance and care of multi-threading locks</a></li><li><a class="toctext" href="../../devdocs/offset-arrays/">Arrays with custom indices</a></li><li><a class="toctext" href="../../devdocs/require/">Module loading</a></li><li><a class="toctext" href="../../devdocs/inference/">Inference</a></li></ul></li><li><span class="toctext">Developing/debugging Julia&#39;s C code</span><ul><li><a class="toctext" href="../../devdocs/backtraces/">Reporting and analyzing crashes (segfaults)</a></li><li><a class="toctext" href="../../devdocs/debuggingtips/">gdb debugging tips</a></li><li><a class="toctext" href="../../devdocs/valgrind/">Using Valgrind with Julia</a></li><li><a class="toctext" href="../../devdocs/sanitizers/">Sanitizer support</a></li></ul></li></ul></li><li><span class="toctext">中文文档开发</span><ul><li><a class="toctext" href="../../juliacn/style-guide/">翻译指南</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>手册</li><li><a href>多维数组</a></li></ul><a class="edit-page" href="https://github.com/JuliaCN/JuliaZH.jl/blob/master/doc/src/manual/arrays.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>多维数组</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="man-multi-dim-arrays-1" href="#man-multi-dim-arrays-1">多维数组</a></h1><p>与大多数技术计算语言一样，Julia 提供原生的数组实现。 大多数技术计算语言非常重视其数组实现，但需要付出使用其它容器的代价。Julia 用同样的方式来处理数组。就像和其它用 Julia 写的代码一样，Julia 的数组库几乎完全是用 Julia 自身实现的，它的性能源自编译器。这样一来，用户就可以通过继承 <a href="../../base/arrays/#Core.AbstractArray"><code>AbstractArray</code></a> 的方式来创建自定义数组类型。 实现自定义数组类型的更多详细信息，请参阅<a href="../interfaces/#man-interface-array-1">manual section on the AbstractArray interface</a>。</p><p>数组是存储在多维网格中对象的集合。在最一般的情况下， 数组中的对象可能是 <code>Any</code> 类型。 对于大多数计算上的需求，数组中对象的类型应该更加具体，例如 <a href="../../base/numbers/#Core.Float64"><code>Float64</code></a> 或 <a href="../../base/numbers/#Core.Int32"><code>Int32</code></a>。</p><p>一般来说，与许多其他技术计算语言不同，Julia 不希望为了性能而以向量化的方式编写程序。Julia 的编译器使用类型推断，并为标量数组索引生成优化的代码，允许以方便和可读的方式编写程序，而不牺牲性能，并且有时使用更少的内存。</p><p>在Julia中，所有函数的参数都是 <a href="https://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_sharing">passed by sharing</a> (也就是传指针)。一些科学计算语言用传值的方式传递数组，这防止了这个值的被调用者在调用函数中被意外修改，也导致无法避免不必要的数组赋值。简便起见，以一个 <code>!</code> 结束的函数名表示它会修改或者销毁它的一个或者多个参数的值（例如，<a href="../../base/sort/#Base.sort"><code>sort</code></a> 和 <a href="../../base/sort/#Base.sort!"><code>sort!</code></a>）。被调用者必须显式复制，以保证他们不会修改他们本不应该修改的输入。很多不可变的函数时在实现的时候，对输入的显式副本调用一个在结尾加上 <code>!</code> 的同名函数，并返回该副本。</p><h2><a class="nav-anchor" id="基本函数-1" href="#基本函数-1">基本函数</a></h2><table><tr><th>函数</th><th>描述</th></tr><tr><td><a href="../../base/collections/#Base.eltype"><code>eltype(A)</code></a></td><td><code>A</code>中元素的类型</td></tr><tr><td><a href="../../base/strings/#Base.length-Tuple{AbstractString}"><code>length(A)</code></a></td><td><code>A</code> 中元素的数量</td></tr><tr><td><a href="../../base/arrays/#Base.ndims"><code>ndims(A)</code></a></td><td><code>A</code> 的维数</td></tr><tr><td><a href="../../base/arrays/#Base.size"><code>size(A)</code></a></td><td>一个包含<code>A</code>的维度的元组</td></tr><tr><td><a href="../../base/arrays/#Base.size"><code>size(A,n)</code></a></td><td><code>A</code>第<code>n</code>维的大小</td></tr><tr><td><a href="../../base/arrays/#Base.axes-Tuple{Any}"><code>axes(A)</code></a></td><td>一个包含<code>A</code>有效索引的元祖</td></tr><tr><td><a href="../../base/arrays/#Base.axes-Tuple{Any}"><code>axes(A,n)</code></a></td><td>一个描述第<code>n</code>维有效索引的范围</td></tr><tr><td><a href="../../base/arrays/#Base.eachindex"><code>eachindex(A)</code></a></td><td>一个访问<code>A</code> 中每一个位置的高效迭代器</td></tr><tr><td><a href="../../base/arrays/#Base.stride"><code>stride(A,k)</code></a></td><td>在<code>k</code>维上的间隔（stride）（相邻元素间的线性索引距离）</td></tr><tr><td><a href="../../base/arrays/#Base.strides"><code>strides(A)</code></a></td><td>每一维上的间隔的元组</td></tr></table><h2><a class="nav-anchor" id="构造和初始化-1" href="#构造和初始化-1">构造和初始化</a></h2><p>Julia 提供了许多用于构造和初始化数组的函数。 在下列函数中，使用 <code>dims ...</code> 参数调用可以是一个表示维数大小的元组或一系列维数大小作为可变数量的参数传递。 大多数这些函数也接受第一个表示数组的元素类型的输入<code>T</code>。 如果类型 <code>T</code> 被省略，它将默认为[<code>Float64</code>]（@ ref）。</p><table><tr><th>函数</th><th>描述</th></tr><tr><td><a href="../../base/arrays/#Core.Array"><code>Array{T}(undef, dims...)</code></a></td><td>一个没有初始化的密集 <a href="manual/@ref"><code>数组</code></a></td></tr><tr><td><a href="../../base/arrays/#Base.zeros"><code>zeros(T, dims...)</code></a></td><td>一个全零<code>数组</code></td></tr><tr><td><a href="../../base/arrays/#Base.ones"><code>ones(T, dims...)</code></a></td><td>一个元素均为1的<code>数组</code></td></tr><tr><td><a href="../../base/arrays/#Base.trues"><code>trues(dims...)</code></a></td><td>一个每个元素都为 <code>true</code> 的 <a href="../../base/arrays/#Base.BitArray"><code>BitArray</code></a></td></tr><tr><td><a href="../../base/arrays/#Base.falses"><code>falses(dims...)</code></a></td><td>一个每个元素都为 <code>false</code> 的 <code>BitArray</code></td></tr><tr><td><a href="../../base/arrays/#Base.reshape"><code>reshape(A, dims...)</code></a></td><td>一个包含跟<code>A</code> 相同数据但维数不同的数组</td></tr><tr><td><a href="../../base/base/#Base.copy"><code>copy(A)</code></a></td><td>复制 <code>A</code></td></tr><tr><td><a href="../../base/base/#Base.deepcopy"><code>deepcopy(A)</code></a></td><td>复制 <code>A</code>，递归地复制其元素</td></tr><tr><td><a href="../../base/arrays/#Base.similar"><code>similar(A, T, dims...)</code></a></td><td>一个与<code>A</code>具有相同类型（这里指的是密集，稀疏等）的未初始化数组，但具有指定的元素类型和维数。 第二个和第三个参数都是可选的，如果省略则默认为元素类型和 <code>A</code> 的维数。</td></tr><tr><td><a href="../../base/arrays/#Base.reinterpret"><code>reinterpret(T, A)</code></a></td><td>与 <code>A</code> 具有相同二进制数据的数组，但元素类型为 <code>T</code></td></tr><tr><td><a href="../../stdlib/Random/#Base.rand"><code>rand(T, dims...)</code></a></td><td>一个随机<code>数组</code>，元素值是<span>$[0,1}$</span>半开区间中的均匀分布且服从一阶独立同分布</td></tr><tr><td><a href="../../stdlib/Random/#Base.randn"><code>randn(T, dims...)</code></a></td><td>一个随机<code>数组</code>，元素为标准正态分布，服从独立同分布</td></tr><tr><td><a href="../../base/arrays/#Base.Matrix"><code>Matrix{T}(I, m, n)</code></a></td><td><code>m</code>行<code>n</code>列的单位矩阵</td></tr><tr><td><a href="../../base/math/#Base.range"><code>range(start, stop=stop, length=n)</code></a></td><td>从<code>start</code>到<code>stop</code>的带有<code>n</code>个线性间隔元素的范围</td></tr><tr><td><a href="../../base/arrays/#Base.fill!"><code>fill!(A, x)</code></a></td><td>用值 <code>x</code> 填充数组 <code>A</code></td></tr><tr><td><a href="../../base/arrays/#Base.fill"><code>fill(x, dims...)</code></a></td><td>一个被值<code>x</code>填充的<code>数组</code></td></tr></table><div class="footnote" id="footnote-1"><a href="#footnote-1"><strong>[1]</strong></a><p><em>iid</em>，独立同分布</p></div><p>语法<code>[A，B，C，...]</code>构造其参数的1维数组（向量）。 如果所有参数有一个共同的类型提升类型<a href="../conversion-and-promotion/#conversion-and-promotion-1">promotion type</a>，然后他们会被用<a href="manual/@ ref"><code>convert</code></a>转换为该类型。</p><p>要查看各种方法，我们可以将不同维数传递给这些构造函数，请考虑以下示例：</p><pre><code class="language-julia-repl">julia&gt; zeros(Int8, 2, 2)
2×2 Array{Int8,2}:
 0  0
 0  0

julia&gt; zeros(Int8, (2, 2))
2×2 Array{Int8,2}:
 0  0
 0  0

julia&gt; zeros((2, 2))
2×2 Array{Float64,2}:
 0.0  0.0
 0.0  0.0</code></pre><p>这里的 <code>(2, 2)</code> 是一个 <a href="../../base/base/#Core.Tuple"><code>Tuple</code></a>.</p><h2><a class="nav-anchor" id="拼接-1" href="#拼接-1">拼接</a></h2><p>可以使用以下函数构造和拼接数组：</p><table><tr><th>函数</th><th>描述</th></tr><tr><td><a href="../../base/arrays/#Base.cat"><code>cat(A...; dims=k)</code></a></td><td>沿着s的第<code>k</code>拼接数组</td></tr><tr><td><a href="../../base/arrays/#Base.vcat"><code>vcat(A...)</code></a></td><td><code>cat(A...; dims=1)</code> 的简写</td></tr><tr><td><a href="../../base/arrays/#Base.hcat"><code>hcat(A...)</code></a></td><td><code>cat(A...; dims=2)</code> 的简写</td></tr></table><p>传递给这些函数的标量值会被当作1个元素的数组。 例如，</p><pre><code class="language-julia-repl">julia&gt; vcat([1, 2], 3)
3-element Array{Int64,1}:
 1
 2
 3

julia&gt; hcat([1 2], 3)
1×3 Array{Int64,2}:
 1  2  3</code></pre><p>这些拼接函数非常常用，因此它们有特殊的语法：</p><table><tr><th>表达式</th><th>调用</th></tr><tr><td><code>[A; B; C; ...]</code></td><td><a href="../../base/arrays/#Base.vcat"><code>vcat</code></a></td></tr><tr><td><code>[A B C ...]</code></td><td><a href="../../base/arrays/#Base.hcat"><code>hcat</code></a></td></tr><tr><td><code>[A B; C D; ...]</code></td><td><a href="../../base/arrays/#Base.hvcat"><code>hvcat</code></a></td></tr></table><p><a href="../../base/arrays/#Base.hvcat"><code>hvcat</code></a> 可以在第1维列数组（用分号分隔）和第2维行数组（用空格分隔）进行连接。 请考虑以下语法示例：</p><pre><code class="language-julia-repl">julia&gt; [[1; 2]; [3, 4]]
4-element Array{Int64,1}:
 1
 2
 3
 4

julia&gt; [[1 2] [3 4]]
1×4 Array{Int64,2}:
 1  2  3  4

julia&gt; [[1 2]; [3 4]]
2×2 Array{Int64,2}:
 1  2
 3  4</code></pre><h2><a class="nav-anchor" id="类型数组初始化-1" href="#类型数组初始化-1">类型数组初始化</a></h2><p>可以用 <code>T[A, B, C, ...]</code>的方式声明一个元素为某种特定类型的数组。该方法定义一个元素类型为 <code>T</code> 的一维数组并且初始化元素为 <code>A</code>, <code>B</code>, <code>C</code>,....。比如，<code>Any[x, y, z]</code> 声明一个异构数组，该数组可以包含任意类型元素。</p><p>连接语法可以类似地以类型为前缀，来指定结果的元素类型。</p><pre><code class="language-julia-repl">julia&gt; [[1 2] [3 4]]
1×4 Array{Int64,2}:
 1  2  3  4

julia&gt; Int8[[1 2] [3 4]]
1×4 Array{Int8,2}:
 1  2  3  4</code></pre><h2><a class="nav-anchor" id="推导式-1" href="#推导式-1">推导式</a></h2><p>推导提供了构造数组的通用且强大的方法。 推导语法类似于数学中的集合构造符号：</p><pre><code class="language-none">A = [ F(x,y,...) for x=rx, y=ry, ... ]</code></pre><p>这种形式的含义是<code>F(x,y,...)</code>取其给定列表中变量<code>x</code>，<code>y</code>等的每个值进行计算。 值可以指定为任何可迭代对象，但通常是<code>1：n</code>或<code>2:(n-1)</code>之类的范围，或者像<code>[1.2, 3.4, 5.7]</code>这样的显式数组值。 结果是一个N-d密集数组，其维数是变量范围<code>rx</code>，<code>ry</code>等的维数串联。每次<code>FF(x,y,...)</code>计算返回一个标量。</p><p>下面的示例计算当前元素和沿一维网格其左，右相邻元素的加权平均值：</p><pre><code class="language-julia-repl">julia&gt; x = rand(8)
8-element Array{Float64,1}:
 0.843025
 0.869052
 0.365105
 0.699456
 0.977653
 0.994953
 0.41084
 0.809411

julia&gt; [ 0.25*x[i-1] + 0.5*x[i] + 0.25*x[i+1] for i=2:length(x)-1 ]
6-element Array{Float64,1}:
 0.736559
 0.57468
 0.685417
 0.912429
 0.8446
 0.656511</code></pre><p>生成的数组类型取决于计算元素的类型。 为了明确地控制类型，可以在推导之前添加类型。 例如，我们可以要求结果为单精度类型：</p><pre><code class="language-julia">Float32[ 0.25*x[i-1] + 0.5*x[i] + 0.25*x[i+1] for i=2:length(x)-1 ]</code></pre><h2><a class="nav-anchor" id="生成器表达式-1" href="#生成器表达式-1">生成器表达式</a></h2><p>也可以在没有方括号的情况下编写推导，从而产生称为生成器的对象。 可以迭代此对象以按需生成值，而不是预先分配数组并存储它们（请参阅<a href="#迭代-1">迭代</a>）。 例如，以下表达式在不分配内存的情况下对一个序列进行求和：</p><pre><code class="language-julia-repl">julia&gt; sum(1/n^2 for n=1:1000)
1.6439345666815615</code></pre><p>在参数列表中编写具有多个维度的生成器表达式时，需要使用括号将生成器与后续参数分开：</p><pre><code class="language-julia-repl">julia&gt; map(tuple, 1/(i+j) for i=1:2, j=1:2, [1:4;])
ERROR: syntax: invalid iteration specification</code></pre><p><code>for</code>之后的所有逗号分隔的表达式都被解释为范围。 添加括号让我们可以向<a href="../../base/collections/#Base.map"><code>map</code></a>中添加第三个参数：</p><pre><code class="language-julia-repl">julia&gt; map(tuple, (1/(i+j) for i=1:2, j=1:2), [1 3; 2 4])
2×2 Array{Tuple{Float64,Int64},2}:
 (0.5, 1)       (0.333333, 3)
 (0.333333, 2)  (0.25, 4)</code></pre><p>生成器是通过内部函数实现。 与语言中内部函数的其他情况一样，封闭作用域中的变量可以在内部函数中“捕获”。 例如，<code>sum(p[i] - q[i] for i=1:n)</code> 从封闭作用域中捕获三个变量<code>p</code>，<code>q</code>和<code>n</code>。 捕获的变量可能会出现<a href="../performance-tips/#man-performance-tips-1">性能提示</a>中描述的性能问题。</p><p>通过编写多个<code>for</code>关键字，生成器和推导中的范围可以取决于之前的范围：</p><pre><code class="language-julia-repl">julia&gt; [(i,j) for i=1:3 for j=1:i]
6-element Array{Tuple{Int64,Int64},1}:
 (1, 1)
 (2, 1)
 (2, 2)
 (3, 1)
 (3, 2)
 (3, 3)</code></pre><p>在这些情况下，结果都是一维的。</p><p>可以使用<code>if</code>关键字过滤生成的值：</p><pre><code class="language-julia-repl">julia&gt; [(i,j) for i=1:3 for j=1:i if i+j == 4]
2-element Array{Tuple{Int64,Int64},1}:
 (2, 2)
 (3, 1)</code></pre><h2><a class="nav-anchor" id="man-array-indexing-1" href="#man-array-indexing-1">索引</a></h2><p>n维数组A进行索引的一般语法是：</p><pre><code class="language-none">X = A[I_1, I_2, ..., I_n]</code></pre><p>其中每个<code>I_k</code>可以是标量整数，整数数组或任何其他<a href="#man-supported-index-types-1">支持的索引类型</a>。 这包括<a href="../../base/arrays/#Base.Colon"><code>Colon</code></a> (<code>:</code>)来选择整个维度中的所有索引，形式为<code>a:c</code>或<code>a:b:c</code>的范围来选择连续或跨步的子区间，以及 布尔数组以选择索引为<code>true</code>的元素。</p><p>如果所有索引都是标量，则结果<code>X</code>是数组<code>A</code>中的单个元素。 否则，<code>X</code>是一个数组，其维数与所有索引的维数之和相同。</p><p>如果所有索引都是向量，则<code>X</code>的形状将是 <code>(length(I_1), length(I_2), ..., length(I_n))</code>，其中<code>X</code>中位置为<code>(i_1, i_2, ..., i_n)</code> 的值为<code>A[I_1[i_1], I_2[i_2], ..., I_n[i_n]]</code>。</p><p>例子：</p><pre><code class="language-julia-repl">julia&gt; A = reshape(collect(1:16), (2, 2, 2, 2))
2×2×2×2 Array{Int64,4}:
[:, :, 1, 1] =
 1  3
 2  4

[:, :, 2, 1] =
 5  7
 6  8

[:, :, 1, 2] =
  9  11
 10  12

[:, :, 2, 2] =
 13  15
 14  16

julia&gt; A[1, 2, 1, 1] # all scalar indices
3

julia&gt; A[[1, 2], [1], [1, 2], [1]] # all vector indices
2×1×2×1 Array{Int64,4}:
[:, :, 1, 1] =
 1
 2

[:, :, 2, 1] =
 5
 6

julia&gt; A[[1, 2], [1], [1, 2], 1] # a mix of index types
2×1×2 Array{Int64,3}:
[:, :, 1] =
 1
 2

[:, :, 2] =
 5
 6</code></pre><p>请注意最后两种情况下得到的数组的大小是如何不同的。</p><p>If <code>I_1</code> is changed to a two-dimensional matrix, then <code>X</code> becomes an <code>n+1</code>-dimensional array of shape <code>(size(I_1, 1), size(I_1, 2), length(I_2), ..., length(I_n))</code>. The matrix adds a dimension.</p><p>例如：</p><pre><code class="language-julia-repl">julia&gt; A = reshape(collect(1:16), (2, 2, 2, 2));

julia&gt; A[[1 2; 1 2]]
2×2 Array{Int64,2}:
 1  2
 1  2

julia&gt; A[[1 2; 1 2], 1, 2, 1]
2×2 Array{Int64,2}:
 5  6
 5  6</code></pre><p>位置<code>(i_1, i_2, i_3, ..., i_{n+1})</code>的值是<code>A[I_1[i_1, i_2], I_2[i_3], ..., I_n[i_{n+1}]]</code>。 所有使用标量索引的维度都将被删除。 例如，<code>A [2，I，3]</code>的结果是一个大小为<code>size(I)</code>的数组。 它的第i个元素由<code>A[2, I[i], 3]</code>填充。</p><p>作为此语法的特殊部分，<code>end</code>关键字可用于表示索引括号内每个维度的最后一个索引，由索引的最内层数组的大小决定。 没有<code>end</code>关键字的索引语法相当于调用<a href="../../base/collections/#Base.getindex"><code>getindex</code></a>：</p><pre><code class="language-none">X = getindex(A, I_1, I_2, ..., I_n)</code></pre><p>例如：</p><pre><code class="language-julia-repl">julia&gt; x = reshape(1:16, 4, 4)
4×4 reshape(::UnitRange{Int64}, 4, 4) with eltype Int64:
 1  5   9  13
 2  6  10  14
 3  7  11  15
 4  8  12  16

julia&gt; x[2:3, 2:end-1]
2×2 Array{Int64,2}:
 6  10
 7  11

julia&gt; x[1, [2 3; 4 1]]
2×2 Array{Int64,2}:
  5  9
 13  1</code></pre><p>形式为<code>n:n-1</code>的空范围有时用于表示<code>n-1</code>和<code>n</code>之间的索引间位置。 例如，<a href="../../base/sort/#Base.Sort.searchsorted"><code>searchsorted</code></a>函数利用这个惯例，来表示不在有序数组中的值的插入位置：</p><pre><code class="language-julia-repl">julia&gt; a = [1,2,5,6,7];

julia&gt; searchsorted(a, 3)
3:2</code></pre><h2><a class="nav-anchor" id="赋值-1" href="#赋值-1">赋值</a></h2><p>在n维数组A中赋值的一般语法是：</p><pre><code class="language-none">A[I_1, I_2, ..., I_n] = X</code></pre><p>其中每个<code>I_k</code>可以是标量整数，整数数组或任何其他<a href="#man-supported-index-types-1">支持的索引类型</a>。 这包括<a href="../../base/arrays/#Base.Colon"><code>Colon</code></a> (<code>:</code>)来选择整个维度中的所有索引，形式为<code>a:c</code>或<code>a:b:c</code>的范围来选择连续或跨步的部分元素，以及布尔数组以<code>true</code>索引选择元素。</p><p>如果<code>X</code>是一个数组，它必须具有与索引长度的乘积相同的元素数：<code>prod(length(I_1), length(I_2), ..., length(I_n))</code>。 <code>A</code>在位置<code>I_1[i_1], I_2[i_2], ..., I_n[i_n]</code>中的值被值<code>X[i_1, i_2, ..., i_n]</code>覆盖。 如果<code>X</code>不是数组，则将其值写入<code>A</code>中所有引用的位置。</p><p>就像在<a href="#man-array-indexing-1">索引</a>中一样，<code>end</code>关键字可用于表示索引括号中每个维度的最后一个索引，由被赋值的数组大小决定。 没有<code>end</code>关键字的索引赋值语法相当于调用<a href="manual/@ref"><code>setindex！</code></a>：</p><pre><code class="language-none">setindex!(A, X, I_1, I_2, ..., I_n)</code></pre><p>例如：</p><pre><code class="language-julia-repl">julia&gt; x = collect(reshape(1:9, 3, 3))
3×3 Array{Int64,2}:
 1  4  7
 2  5  8
 3  6  9

julia&gt; x[3, 3] = -9;

julia&gt; x[1:2, 1:2] = [-1 -4; -2 -5];

julia&gt; x
3×3 Array{Int64,2}:
 -1  -4   7
 -2  -5   8
  3   6  -9</code></pre><h2><a class="nav-anchor" id="man-supported-index-types-1" href="#man-supported-index-types-1">支持的索引类型</a></h2><p>In the expression <code>A[I_1, I_2, ..., I_n]</code>, each <code>I_k</code> may be a scalar index, an array of scalar indices, or an object that represents an array of scalar indices and can be converted to such by <a href="../../base/arrays/#Base.to_indices"><code>to_indices</code></a>: 在表达式<code>A[I_1, I_2, ..., I_n]</code>中，每个<code>I_k</code>可以是标量索引，标量索引数组，或者用<a href="../../base/arrays/#Base.to_indices"><code>to_indices</code></a>转换成表示标量索引数组的对象：</p><ol><li>标量索引。 默认情况下，这包括：<ul><li>非布尔的整数</li><li><a href="manual/@ref"><a href="manual/@ref"><code>CartesianIndex {N}</code></a>s，其行为类似于跨越多个维度的<code>N</code>维整数元组（详见下文）</a>s, which behave like an <code>N</code>-tuple of integers spanning multiple dimensions (see below for more details)</li></ul></li><li>标量索引数组。 这包括：<ul><li>整数向量和多维整数数组</li><li>像<code>[]</code>这样的空数组，它不选择任何元素</li><li>如<code>a:c</code>或<code>a:b:c</code>的范围，从<code>a</code>到<code>c</code>（包括）选择连续或跨步的部分元素</li><li>任何自定义标量索引数组，它是<code>AbstractArray</code>的子类型</li><li><code>CartesianIndex{N}</code>数组（详见下文）</li></ul></li><li>一个表示标量索引数组的对象，可以通过<a href="../../base/arrays/#Base.to_indices"><code>to_indices</code></a>转换为这样的对象。 默认情况下，这包括：<ul><li><a href="../../base/arrays/#Base.Colon"><code>Colon()</code></a> (<code>:</code>)，表示整个维度内或整个数组中的所有索引</li><li>布尔数组，选择其中值为<code>true</code>的索引对应的元素（更多细节见下文）</li></ul></li></ol><p>一些例子：</p><pre><code class="language-julia-repl">julia&gt; A = reshape(collect(1:2:18), (3, 3))
3×3 Array{Int64,2}:
 1   7  13
 3   9  15
 5  11  17

julia&gt; A[4]
7

julia&gt; A[[2, 5, 8]]
3-element Array{Int64,1}:
  3
  9
 15

julia&gt; A[[1 4; 3 8]]
2×2 Array{Int64,2}:
 1   7
 5  15

julia&gt; A[[]]
0-element Array{Int64,1}

julia&gt; A[1:2:5]
3-element Array{Int64,1}:
 1
 5
 9

julia&gt; A[2, :]
3-element Array{Int64,1}:
  3
  9
 15

julia&gt; A[:, 3]
3-element Array{Int64,1}:
 13
 15
 17</code></pre><h3><a class="nav-anchor" id="笛卡尔索引-1" href="#笛卡尔索引-1">笛卡尔索引</a></h3><p>特殊的<code>CartesianIndex{N}</code>对象表示一个标量索引，其行为类似于跨越多个维度的<code>N</code>维整数元组。 例如：</p><pre><code class="language-julia-repl">julia&gt; A = reshape(1:32, 4, 4, 2);

julia&gt; A[3, 2, 1]
7

julia&gt; A[CartesianIndex(3, 2, 1)] == A[3, 2, 1] == 7
true</code></pre><p>Considered alone, this may seem relatively trivial; <code>CartesianIndex</code> simply gathers multiple integers together into one object that represents a single multidimensional index. When combined with other indexing forms and iterators that yield <code>CartesianIndex</code>es, however, this can lead directly to very elegant and efficient code. See <a href="manual/@ref">Iteration</a> below, and for some more advanced examples, see <a href="https://julialang.org/blog/2016/02/iteration">this blog post on multidimensional algorithms and iteration</a>.</p><p>Arrays of <code>CartesianIndex{N}</code> are also supported. They represent a collection of scalar indices that each span <code>N</code> dimensions, enabling a form of indexing that is sometimes referred to as pointwise indexing. For example, it enables accessing the diagonal elements from the first &quot;page&quot; of <code>A</code> from above:</p><pre><code class="language-julia-repl">julia&gt; page = A[:,:,1]
4×4 Array{Int64,2}:
 1  5   9  13
 2  6  10  14
 3  7  11  15
 4  8  12  16

julia&gt; page[[CartesianIndex(1,1),
             CartesianIndex(2,2),
             CartesianIndex(3,3),
             CartesianIndex(4,4)]]
4-element Array{Int64,1}:
  1
  6
 11
 16</code></pre><p>This can be expressed much more simply with <a href="../functions/#man-vectorized-1">dot broadcasting</a> and by combining it with a normal integer index (instead of extracting the first <code>page</code> from <code>A</code> as a separate step). It can even be combined with a <code>:</code> to extract both diagonals from the two pages at the same time:</p><pre><code class="language-julia-repl">julia&gt; A[CartesianIndex.(axes(A, 1), axes(A, 2)), 1]
4-element Array{Int64,1}:
  1
  6
 11
 16

julia&gt; A[CartesianIndex.(axes(A, 1), axes(A, 2)), :]
4×2 Array{Int64,2}:
  1  17
  6  22
 11  27
 16  32</code></pre><div class="admonition warning"><div class="admonition-title">Warning</div><div class="admonition-text"><p><code>CartesianIndex</code> and arrays of <code>CartesianIndex</code> are not compatible with the <code>end</code> keyword to represent the last index of a dimension. Do not use <code>end</code> in indexing expressions that may contain either <code>CartesianIndex</code> or arrays thereof.</p></div></div><h3><a class="nav-anchor" id="Logical-indexing-1" href="#Logical-indexing-1">Logical indexing</a></h3><p>Often referred to as logical indexing or indexing with a logical mask, indexing by a boolean array selects elements at the indices where its values are <code>true</code>. Indexing by a boolean vector <code>B</code> is effectively the same as indexing by the vector of integers that is returned by <a href="../../base/arrays/#Base.findall-Tuple{Any}"><code>findall(B)</code></a>. Similarly, indexing by a <code>N</code>-dimensional boolean array is effectively the same as indexing by the vector of <code>CartesianIndex{N}</code>s where its values are <code>true</code>. A logical index must be a vector of the same length as the dimension it indexes into, or it must be the only index provided and match the size and dimensionality of the array it indexes into. It is generally more efficient to use boolean arrays as indices directly instead of first calling <a href="../../base/arrays/#Base.findall-Tuple{Any}"><code>findall</code></a>.</p><pre><code class="language-julia-repl">julia&gt; x = reshape(1:16, 4, 4)
4×4 reshape(::UnitRange{Int64}, 4, 4) with eltype Int64:
 1  5   9  13
 2  6  10  14
 3  7  11  15
 4  8  12  16

julia&gt; x[[false, true, true, false], :]
2×4 Array{Int64,2}:
 2  6  10  14
 3  7  11  15

julia&gt; mask = map(ispow2, x)
4×4 Array{Bool,2}:
  true  false  false  false
  true  false  false  false
 false  false  false  false
  true   true  false   true

julia&gt; x[mask]
5-element Array{Int64,1}:
  1
  2
  4
  8
 16</code></pre><h2><a class="nav-anchor" id="迭代-1" href="#迭代-1">迭代</a></h2><p>迭代整个数组的推荐方法是</p><pre><code class="language-julia">for a in A
    # Do something with the element a
end

for i in eachindex(A)
    # Do something with i and/or A[i]
end</code></pre><p>The first construct is used when you need the value, but not index, of each element. In the second construct, <code>i</code> will be an <code>Int</code> if <code>A</code> is an array type with fast linear indexing; otherwise, it will be a <code>CartesianIndex</code>:</p><pre><code class="language-julia-repl">julia&gt; A = rand(4,3);

julia&gt; B = view(A, 1:3, 2:3);

julia&gt; for i in eachindex(B)
           @show i
       end
i = CartesianIndex(1, 1)
i = CartesianIndex(2, 1)
i = CartesianIndex(3, 1)
i = CartesianIndex(1, 2)
i = CartesianIndex(2, 2)
i = CartesianIndex(3, 2)</code></pre><p>In contrast with <code>for i = 1:length(A)</code>, iterating with <a href="../../base/arrays/#Base.eachindex"><code>eachindex</code></a> provides an efficient way to iterate over any array type.</p><h2><a class="nav-anchor" id="数组特点-1" href="#数组特点-1">数组特点</a></h2><p>If you write a custom <a href="../../base/arrays/#Core.AbstractArray"><code>AbstractArray</code></a> type, you can specify that it has fast linear indexing using</p><pre><code class="language-julia">Base.IndexStyle(::Type{&lt;:MyArray}) = IndexLinear()</code></pre><p>This setting will cause <code>eachindex</code> iteration over a <code>MyArray</code> to use integers. If you don&#39;t specify this trait, the default value <code>IndexCartesian()</code> is used.</p><h2><a class="nav-anchor" id="数组、矢量化操作符及函数-1" href="#数组、矢量化操作符及函数-1">数组、矢量化操作符及函数</a></h2><p>以下操作符支持数组整体操作</p><ol><li>一元运算符 – <code>-</code>, <code>+</code></li><li>二元运算符 – <code>-</code>, <code>+</code>, <code>*</code>, <code>/</code>, <code>\</code>, <code>^</code></li><li>比较操作符– <code>==</code>, <code>!=</code>, <code>≈</code> (<a href="../../base/math/#Base.isapprox"><code>isapprox</code></a>), <code>≉</code></li></ol><p>Most of the binary arithmetic operators listed above also operate elementwise when one argument is scalar: <code>-</code>, <code>+</code>, and <code>*</code> when either argument is scalar, and <code>/</code> and <code>\</code> when the denominator is scalar. For example, <code>[1, 2] + 3 == [4, 5]</code> and <code>[6, 4] / 2 == [3, 2]</code>.</p><p>Additionally, to enable convenient vectorization of mathematical and other operations, Julia <a href="../functions/#man-vectorized-1">provides the dot syntax</a> <code>f.(args...)</code>, e.g. <code>sin.(x)</code> or <code>min.(x,y)</code>, for elementwise operations over arrays or mixtures of arrays and scalars (a <a href="manual/@ref">Broadcasting</a> operation); these have the additional advantage of &quot;fusing&quot; into a single loop when combined with other dot calls, e.g. <code>sin.(cos.(x))</code>.</p><p>Also, <em>every</em> binary operator supports a <a href="../mathematical-operations/#man-dot-operators-1">dot version</a> that can be applied to arrays (and combinations of arrays and scalars) in such <a href="../functions/#man-vectorized-1">fused broadcasting operations</a>, e.g. <code>z .== sin.(x .* y)</code>.</p><p>Note that comparisons such as <code>==</code> operate on whole arrays, giving a single boolean answer. Use dot operators like <code>.==</code> for elementwise comparisons. (For comparison operations like <code>&lt;</code>, <em>only</em> the elementwise <code>.&lt;</code> version is applicable to arrays.)</p><p>Also notice the difference between <code>max.(a,b)</code>, which <a href="../../base/arrays/#Base.Broadcast.broadcast"><code>broadcast</code></a>s <a href="../../base/math/#Base.max"><code>max</code></a> elementwise over <code>a</code> and <code>b</code>, and <a href="../../base/collections/#Base.maximum"><code>maximum(a)</code></a>, which finds the largest value within <code>a</code>. The same relationship holds for <code>min.(a,b)</code> and <code>minimum(a)</code>.</p><h2><a class="nav-anchor" id="广播-1" href="#广播-1">广播</a></h2><p>对于在不同大小的数组上执行逐元素的二元操作有时很有用， 例如将矩阵的每一列加一个向量。一种效率低下的方法可能会将矢量复制到矩阵的大小：</p><pre><code class="language-julia-repl">julia&gt; a = rand(2,1); A = rand(2,3);

julia&gt; repeat(a,1,3)+A
2×3 Array{Float64,2}:
 1.20813  1.82068  1.25387
 1.56851  1.86401  1.67846</code></pre><p>当维度较大的时候，这种方法将会十分浪费，所以Julia提供了广播<a href="../../base/arrays/#Base.Broadcast.broadcast"><code>broadcast</code></a>，它将会将参数中低维度的参数扩展，使得其与其他维度匹配，且不会使用额外的内存，并将所给的函数逐元素地应用。</p><pre><code class="language-julia-repl">julia&gt; broadcast(+, a, A)
2×3 Array{Float64,2}:
 1.20813  1.82068  1.25387
 1.56851  1.86401  1.67846

julia&gt; b = rand(1,2)
1×2 Array{Float64,2}:
 0.867535  0.00457906

julia&gt; broadcast(+, a, b)
2×2 Array{Float64,2}:
 1.71056  0.847604
 1.73659  0.873631</code></pre><p><a href="../mathematical-operations/#man-dot-operators-1">Dotted operators</a> such as <code>.+</code> and <code>.*</code> are equivalent to <code>broadcast</code> calls (except that they fuse, as described below). There is also a <a href="../../base/arrays/#Base.Broadcast.broadcast!"><code>broadcast!</code></a> function to specify an explicit destination (which can also be accessed in a fusing fashion by <code>.=</code> assignment). Moreover, <code>f.(args...)</code> is equivalent to <code>broadcast(f, args...)</code>, providing a convenient syntax to broadcast any function (<a href="../functions/#man-vectorized-1">dot syntax</a>). Nested &quot;dot calls&quot; <code>f.(...)</code> (including calls to <code>.+</code> etcetera) <a href="../mathematical-operations/#man-dot-operators-1">automatically fuse</a> into a single <code>broadcast</code> call.</p><p>另外，<a href="../../base/arrays/#Base.Broadcast.broadcast"><code>broadcast</code></a>并不局限于数组（参见函数文档），对于元组依然有效。对于其他非数组，元组或 引用<a href="../../base/c/#Core.Ref"><code>Ref</code></a>(除了指针 <a href="../../base/c/#Core.Ptr"><code>Ptr</code></a>)的参数，视作“scalar” </p><pre><code class="language-julia-repl">julia&gt; convert.(Float32, [1, 2])
2-element Array{Float32,1}:
 1.0
 2.0

julia&gt; ceil.((UInt8,), [1.2 3.4; 5.6 6.7])
2×2 Array{UInt8,2}:
 0x02  0x04
 0x06  0x07

julia&gt; string.(1:3, &quot;. &quot;, [&quot;First&quot;, &quot;Second&quot;, &quot;Third&quot;])
3-element Array{String,1}:
 &quot;1. First&quot;
 &quot;2. Second&quot;
 &quot;3. Third&quot;</code></pre><h2><a class="nav-anchor" id="实现-1" href="#实现-1">实现</a></h2><p>The base array type in Julia is the abstract type <a href="../../base/arrays/#Core.AbstractArray"><code>AbstractArray{T,N}</code></a>. It is parametrized by the number of dimensions <code>N</code> and the element type <code>T</code>. <a href="../../base/arrays/#Base.AbstractVector"><code>AbstractVector</code></a> and <a href="../../base/arrays/#Base.AbstractMatrix"><code>AbstractMatrix</code></a> are aliases for the 1-d and 2-d cases. Operations on <code>AbstractArray</code> objects are defined using higher level operators and functions, in a way that is independent of the underlying storage. These operations generally work correctly as a fallback for any specific array implementation.</p><p>The <code>AbstractArray</code> type includes anything vaguely array-like, and implementations of it might be quite different from conventional arrays. For example, elements might be computed on request rather than stored. However, any concrete <code>AbstractArray{T,N}</code> type should generally implement at least <a href="../../base/arrays/#Base.size"><code>size(A)</code></a> (returning an <code>Int</code> tuple), <a href="../../base/arrays/#Base.getindex-Tuple{Type,Vararg{Any,N} where N}"><code>getindex(A,i)</code></a> and <a href="../../base/collections/#Base.getindex"><code>getindex(A,i1,...,iN)</code></a>; mutable arrays should also implement <a href="../../base/collections/#Base.setindex!"><code>setindex!</code></a>. It is recommended that these operations have nearly constant time complexity, or technically Õ(1) complexity, as otherwise some array functions may be unexpectedly slow. Concrete types should also typically provide a <a href="../../base/arrays/#Base.similar"><code>similar(A,T=eltype(A),dims=size(A))</code></a> method, which is used to allocate a similar array for <a href="../../base/base/#Base.copy"><code>copy</code></a> and other out-of-place operations. No matter how an <code>AbstractArray{T,N}</code> is represented internally, <code>T</code> is the type of object returned by <em>integer</em> indexing (<code>A[1, ..., 1]</code>, when <code>A</code> is not empty) and <code>N</code> should be the length of the tuple returned by <a href="../../base/arrays/#Base.size"><code>size</code></a>. For more details on defining custom <code>AbstractArray</code> implementations, see the <a href="../interfaces/#man-interface-array-1">array interface guide in the interfaces chapter</a>.</p><p><code>DenseArray</code> is an abstract subtype of <code>AbstractArray</code> intended to include all arrays where elements are stored contiguously in column-major order (see additional notes in <a href="../performance-tips/#man-performance-tips-1">Performance Tips</a>). The <a href="../../base/arrays/#Core.Array"><code>Array</code></a> type is a specific instance of <code>DenseArray</code>  <a href="../../base/arrays/#Base.Vector"><code>Vector</code></a> and <a href="../../base/arrays/#Base.Matrix"><code>Matrix</code></a> are aliases for the 1-d and 2-d cases. Very few operations are implemented specifically for <code>Array</code> beyond those that are required for all <code>AbstractArrays</code>s; much of the array library is implemented in a generic manner that allows all custom arrays to behave similarly.</p><p><code>SubArray</code> is a specialization of <code>AbstractArray</code> that performs indexing by sharing memory with the original array rather than by copying it. A <code>SubArray</code> is created with the <a href="../../base/arrays/#Base.view"><code>view</code></a> function, which is called the same way as <a href="../../base/collections/#Base.getindex"><code>getindex</code></a> (with an array and a series of index arguments). The result of <a href="../../base/arrays/#Base.view"><code>view</code></a> looks the same as the result of <a href="../../base/collections/#Base.getindex"><code>getindex</code></a>, except the data is left in place. <a href="../../base/arrays/#Base.view"><code>view</code></a> stores the input index vectors in a <code>SubArray</code> object, which can later be used to index the original array indirectly.  By putting the <a href="../../base/arrays/#Base.@views"><code>@views</code></a> macro in front of an expression or block of code, any <code>array[...]</code> slice in that expression will be converted to create a <code>SubArray</code> view instead.</p><p><a href="../../base/arrays/#Base.BitArray"><code>BitArray</code></a>s are space-efficient &quot;packed&quot; boolean arrays, which store one bit per boolean value. They can be used similarly to <code>Array{Bool}</code> arrays (which store one byte per boolean value), and can be converted to/from the latter via <code>Array(bitarray)</code> and <code>BitArray(array)</code>, respectively.</p><p>A &quot;strided&quot; array is stored in memory with elements laid out in regular offsets such that an instance with a supported <code>isbits</code> element type can be passed to external C and Fortran functions that expect this memory layout. Strided arrays must define a <a href="../../base/arrays/#Base.strides"><code>strides(A)</code></a> method that returns a tuple of &quot;strides&quot; for each dimension; a provided <a href="../../base/arrays/#Base.stride"><code>stride(A,k)</code></a> method accesses the <code>k</code>th element within this tuple. Increasing the index of dimension <code>k</code> by <code>1</code> should increase the index <code>i</code> of <a href="../../base/arrays/#Base.getindex-Tuple{Type,Vararg{Any,N} where N}"><code>getindex(A,i)</code></a> by <a href="../../base/arrays/#Base.stride"><code>stride(A,k)</code></a>. If a pointer conversion method <a href="../../base/c/#Base.unsafe_convert"><code>Base.unsafe_convert(Ptr{T}, A)</code></a> is provided, the memory layout must correspond in the same way to these strides. <code>DenseArray</code> is a very specific example of a strided array where the elements are arranged contiguously, thus it provides its subtypes with the approporiate definition of <code>strides</code>. More concrete examples can be found within the <a href="../interfaces/#man-interface-strided-arrays-1">interface guide for strided arrays</a>. <a href="../../base/arrays/#Base.StridedVector"><code>StridedVector</code></a> and <a href="../../base/arrays/#Base.StridedMatrix"><code>StridedMatrix</code></a> are convenient aliases for many of the builtin array types that are considered strided arrays, allowing them to dispatch to select specialized implementations that call highly tuned and optimized BLAS and LAPACK functions using just the pointer and strides.</p><p>接下来的例子计算一个大数组中一小部分的QR分解，不需要引入任何临时变量。通过正确的维度大小和偏移参数调用合适的LAPACK函数。</p><pre><code class="language-julia-repl">julia&gt; a = rand(10, 10)
10×10 Array{Float64,2}:
 0.517515  0.0348206  0.749042   0.0979679  …  0.75984     0.950481   0.579513
 0.901092  0.873479   0.134533   0.0697848     0.0586695   0.193254   0.726898
 0.976808  0.0901881  0.208332   0.920358      0.288535    0.705941   0.337137
 0.657127  0.0317896  0.772837   0.534457      0.0966037   0.700694   0.675999
 0.471777  0.144969   0.0718405  0.0827916     0.527233    0.173132   0.694304
 0.160872  0.455168   0.489254   0.827851   …  0.62226     0.0995456  0.946522
 0.291857  0.769492   0.68043    0.629461      0.727558    0.910796   0.834837
 0.775774  0.700731   0.700177   0.0126213     0.00822304  0.327502   0.955181
 0.9715    0.64354    0.848441   0.241474      0.591611    0.792573   0.194357
 0.646596  0.575456   0.0995212  0.038517      0.709233    0.477657   0.0507231

julia&gt; b = view(a, 2:2:8,2:2:4)
4×2 view(::Array{Float64,2}, 2:2:8, 2:2:4) with eltype Float64:
 0.873479   0.0697848
 0.0317896  0.534457
 0.455168   0.827851
 0.700731   0.0126213

julia&gt; (q, r) = qr(b);

julia&gt; q
4×4 LinearAlgebra.QRCompactWYQ{Float64,Array{Float64,2}}:
 -0.722358    0.227524  -0.247784    -0.604181
 -0.0262896  -0.575919  -0.804227     0.144377
 -0.376419   -0.75072    0.540177    -0.0541979
 -0.579497    0.230151  -0.00552346   0.781782

julia&gt; r
2×2 Array{Float64,2}:
 -1.20921  -0.383393
  0.0      -0.910506</code></pre><footer><hr/><a class="previous" href="../metaprogramming/"><span class="direction">Previous</span><span class="title">元编程</span></a><a class="next" href="../missing/"><span class="direction">Next</span><span class="title">缺失值</span></a></footer></article></body></html>
