<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>函数 · Julia中文文档</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-89508993-1', 'auto');
ga('send', 'pageview');
</script><link rel="canonical" href="https://juliacn.github.io/JuliaZH.jl/latest/manual/functions/index.html"/><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../../assets/julia-manual.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../../index.html"><img class="logo" src="../../assets/logo.png" alt="Julia中文文档 logo"/></a><h1>Julia中文文档</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">主页</a></li><li><span class="toctext">手册</span><ul><li><a class="toctext" href="../getting-started/">入门</a></li><li><a class="toctext" href="../variables/">变量</a></li><li><a class="toctext" href="../integers-and-floating-point-numbers/">整数和浮点数</a></li><li><a class="toctext" href="../mathematical-operations/">数学运算和初等函数</a></li><li><a class="toctext" href="../complex-and-rational-numbers/">复数和分数</a></li><li><a class="toctext" href="../strings/">字符串</a></li><li class="current"><a class="toctext" href>函数</a><ul class="internal"><li><a class="toctext" href="#参数传递行为-1">参数传递行为</a></li><li><a class="toctext" href="#return关键词-1"><code>return</code>关键词</a></li><li><a class="toctext" href="#操作符也是一类函数-1">操作符也是一类函数</a></li><li><a class="toctext" href="#具有特殊名称的操作符-1">具有特殊名称的操作符</a></li><li><a class="toctext" href="#man-anonymous-functions-1">匿名函数</a></li><li><a class="toctext" href="#元组-1">元组</a></li><li><a class="toctext" href="#Named-Tuples-1">Named Tuples</a></li><li><a class="toctext" href="#多返回值-1">多返回值</a></li><li><a class="toctext" href="#Argument-destructuring-1">Argument destructuring</a></li><li><a class="toctext" href="#Varargs-Functions-1">Varargs Functions</a></li><li><a class="toctext" href="#Optional-Arguments-1">Optional Arguments</a></li><li><a class="toctext" href="#Keyword-Arguments-1">Keyword Arguments</a></li><li><a class="toctext" href="#Evaluation-Scope-of-Default-Values-1">Evaluation Scope of Default Values</a></li><li><a class="toctext" href="#Do-Block-Syntax-for-Function-Arguments-1">Do-Block Syntax for Function Arguments</a></li><li><a class="toctext" href="#man-vectorized-1">Dot Syntax for Vectorizing Functions</a></li><li><a class="toctext" href="#更多阅读-1">更多阅读</a></li></ul></li><li><a class="toctext" href="../control-flow/">流程控制</a></li><li><a class="toctext" href="../variables-and-scoping/">变量作用域</a></li><li><a class="toctext" href="../types/">类型</a></li><li><a class="toctext" href="../methods/">方法</a></li><li><a class="toctext" href="../constructors/">构造函数</a></li><li><a class="toctext" href="../conversion-and-promotion/">类型转换和类型提升</a></li><li><a class="toctext" href="../interfaces/">接口</a></li><li><a class="toctext" href="../modules/">Modules</a></li><li><a class="toctext" href="../documentation/">文档</a></li><li><a class="toctext" href="../metaprogramming/">元编程</a></li><li><a class="toctext" href="../arrays/">多维数组</a></li><li><a class="toctext" href="../missing/">缺失值</a></li><li><a class="toctext" href="../networking-and-streams/">网络和流</a></li><li><a class="toctext" href="../parallel-computing/">并行计算</a></li><li><a class="toctext" href="../running-external-programs/">运行外部程序</a></li><li><a class="toctext" href="../calling-c-and-fortran-code/">调用 C 和 Fortran 代码</a></li><li><a class="toctext" href="../handling-operating-system-variation/">处理操作系统差异</a></li><li><a class="toctext" href="../environment-variables/">环境变量</a></li><li><a class="toctext" href="../embedding/">嵌入 Julia</a></li><li><a class="toctext" href="../code-loading/">代码加载</a></li><li><a class="toctext" href="../profile/">分析</a></li><li><a class="toctext" href="../stacktraces/">堆栈跟踪</a></li><li><a class="toctext" href="../performance-tips/">性能建议</a></li><li><a class="toctext" href="../workflow-tips/">工作流程建议</a></li><li><a class="toctext" href="../style-guide/">代码风格指南</a></li><li><a class="toctext" href="../faq/">常见问题</a></li><li><a class="toctext" href="../noteworthy-differences/">与其他语言的显著差异</a></li><li><a class="toctext" href="../unicode-input/">Unicode 输入表</a></li></ul></li><li><span class="toctext">Base</span><ul><li><a class="toctext" href="../../base/base/">Essentials</a></li><li><a class="toctext" href="../../base/collections/">集合和数据结构</a></li><li><a class="toctext" href="../../base/math/">数学</a></li><li><a class="toctext" href="../../base/numbers/">Numbers</a></li><li><a class="toctext" href="../../base/strings/">字符串</a></li><li><a class="toctext" href="../../base/arrays/">Arrays</a></li><li><a class="toctext" href="../../base/parallel/">Tasks</a></li><li><a class="toctext" href="../../base/multi-threading/">多线程</a></li><li><a class="toctext" href="../../base/constants/">常量</a></li><li><a class="toctext" href="../../base/file/">文件系统</a></li><li><a class="toctext" href="../../base/io-network/">I/O and Network</a></li><li><a class="toctext" href="../../base/punctuation/">Punctuation</a></li><li><a class="toctext" href="../../base/sort/">排序及相关函数</a></li><li><a class="toctext" href="../../base/iterators/">Iteration utilities</a></li><li><a class="toctext" href="../../base/c/">C Interface</a></li><li><a class="toctext" href="../../base/libc/">C Standard Library</a></li><li><a class="toctext" href="../../base/stacktraces/">StackTraces</a></li><li><a class="toctext" href="../../base/simd-types/">SIMD Support</a></li></ul></li><li><span class="toctext">Standard Library</span><ul><li><a class="toctext" href="../../stdlib/Base64/">Base64</a></li><li><a class="toctext" href="../../stdlib/CRC32c/">CRC32c</a></li><li><a class="toctext" href="../../stdlib/Dates/">Dates</a></li><li><a class="toctext" href="../../stdlib/DelimitedFiles/">Delimited Files</a></li><li><a class="toctext" href="../../stdlib/Distributed/">Distributed Computing</a></li><li><a class="toctext" href="../../stdlib/FileWatching/">File Events</a></li><li><a class="toctext" href="../../stdlib/InteractiveUtils/">Interactive Utilities</a></li><li><a class="toctext" href="../../stdlib/LibGit2/">LibGit2</a></li><li><a class="toctext" href="../../stdlib/Libdl/">Dynamic Linker</a></li><li><a class="toctext" href="../../stdlib/LinearAlgebra/">Linear Algebra</a></li><li><a class="toctext" href="../../stdlib/Logging/">Logging</a></li><li><a class="toctext" href="../../stdlib/Markdown/">Markdown</a></li><li><a class="toctext" href="../../stdlib/Mmap/">Memory-mapped I/O</a></li><li><a class="toctext" href="../../stdlib/Pkg/">Pkg</a></li><li><a class="toctext" href="../../stdlib/Printf/">Printf</a></li><li><a class="toctext" href="../../stdlib/Profile/">Profiling</a></li><li><a class="toctext" href="../../stdlib/REPL/">The Julia REPL</a></li><li><a class="toctext" href="../../stdlib/Random/">Random Numbers</a></li><li><a class="toctext" href="../../stdlib/SHA/">SHA</a></li><li><a class="toctext" href="../../stdlib/Serialization/">Serialization</a></li><li><a class="toctext" href="../../stdlib/SharedArrays/">Shared Arrays</a></li><li><a class="toctext" href="../../stdlib/Sockets/">Sockets</a></li><li><a class="toctext" href="../../stdlib/SparseArrays/">Sparse Arrays</a></li><li><a class="toctext" href="../../stdlib/Statistics/">Statistics</a></li><li><a class="toctext" href="../../stdlib/Test/">Unit Testing</a></li><li><a class="toctext" href="../../stdlib/UUIDs/">UUIDs</a></li><li><a class="toctext" href="../../stdlib/Unicode/">Unicode</a></li></ul></li><li><span class="toctext">Developer Documentation</span><ul><li><a class="toctext" href="../../devdocs/reflection/">Reflection and introspection</a></li><li><span class="toctext">Documentation of Julia&#39;s Internals</span><ul><li><a class="toctext" href="../../devdocs/init/">Julia 运行时的初始化</a></li><li><a class="toctext" href="../../devdocs/ast/">Julia ASTs</a></li><li><a class="toctext" href="../../devdocs/types/">More about types</a></li><li><a class="toctext" href="../../devdocs/object/">Memory layout of Julia Objects</a></li><li><a class="toctext" href="../../devdocs/eval/">Eval of Julia code</a></li><li><a class="toctext" href="../../devdocs/callconv/">Calling Conventions</a></li><li><a class="toctext" href="../../devdocs/compiler/">High-level Overview of the Native-Code Generation Process</a></li><li><a class="toctext" href="../../devdocs/functions/">Julia Functions</a></li><li><a class="toctext" href="../../devdocs/cartesian/">Base.Cartesian</a></li><li><a class="toctext" href="../../devdocs/meta/">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="toctext" href="../../devdocs/subarrays/">SubArrays</a></li><li><a class="toctext" href="../../devdocs/isbitsunionarrays/">isbits Union Optimizations</a></li><li><a class="toctext" href="../../devdocs/sysimg/">System Image Building</a></li><li><a class="toctext" href="../../devdocs/llvm/">Working with LLVM</a></li><li><a class="toctext" href="../../devdocs/stdio/">printf() and stdio in the Julia runtime</a></li><li><a class="toctext" href="../../devdocs/boundscheck/">边界检查</a></li><li><a class="toctext" href="../../devdocs/locks/">Proper maintenance and care of multi-threading locks</a></li><li><a class="toctext" href="../../devdocs/offset-arrays/">Arrays with custom indices</a></li><li><a class="toctext" href="../../devdocs/require/">Module loading</a></li><li><a class="toctext" href="../../devdocs/inference/">Inference</a></li></ul></li><li><span class="toctext">Developing/debugging Julia&#39;s C code</span><ul><li><a class="toctext" href="../../devdocs/backtraces/">Reporting and analyzing crashes (segfaults)</a></li><li><a class="toctext" href="../../devdocs/debuggingtips/">gdb debugging tips</a></li><li><a class="toctext" href="../../devdocs/valgrind/">Using Valgrind with Julia</a></li><li><a class="toctext" href="../../devdocs/sanitizers/">Sanitizer support</a></li></ul></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>手册</li><li><a href>函数</a></li></ul><a class="edit-page" href="https://github.com/JuliaCN/JuliaZH.jl/blob/master/doc/src/manual/functions.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>函数</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="man-functions-1" href="#man-functions-1">函数</a></h1><p>在Julia里，函数是一个将参数值元组映射到返回值的对象。Julia的函数不是纯粹的数学函数，在某种意义上，函数可以改变并受程序的全局状态的影响。在Julia中定义函数的基本语法是：</p><pre><code class="language-julia-repl">julia&gt; function f(x,y)
           x + y
       end
f (generic function with 1 method)</code></pre><p>在Julia中定义函数还有第二种更简洁的语法。上述的传统函数声明语法等效于以下紧凑性的“赋值形式”：</p><pre><code class="language-julia-repl">julia&gt; f(x,y) = x + y
f (generic function with 1 method)</code></pre><p>尽管函数可以是复合表达式 (见 <a href="../control-flow/#man-compound-expressions-1">Compound Expressions</a>)，但在赋值形式下，函数体必须是一个一行的表达式。简短的函数定义在Julia中是很常见的。非常惯用的短函数语法大大减少了打字和视觉方面的干扰。</p><p>使用传统的括号语法调用函数：</p><pre><code class="language-julia-repl">julia&gt; f(2,3)
5</code></pre><p>没有括号时，表达式<code>f</code>指的是函数对象，可以像任何值一样被传递：</p><pre><code class="language-julia-repl">julia&gt; g = f;

julia&gt; g(2,3)
5</code></pre><p>和变量名一样，Unicode字符也可以用作函数名：</p><pre><code class="language-julia-repl">julia&gt; ∑(x,y) = x + y
∑ (generic function with 1 method)

julia&gt; ∑(2, 3)
5</code></pre><h2><a class="nav-anchor" id="参数传递行为-1" href="#参数传递行为-1">参数传递行为</a></h2><p>Julia函数参数遵循有时称为“pass-by-sharing”的约定，这意味着变量在被传递给函数时其值并不会被复制。函数参数本身充当新的变量绑定（指向变量值的新地址），它们所指向的值与所传递变量的值完全相同。调用者可以看到对函数内可变值（如数组）的修改。这与Scheme，大多数Lisps，Python，Ruby和Perl以及其他动态语言中的行为相同。</p><h2><a class="nav-anchor" id="return关键词-1" href="#return关键词-1"><code>return</code>关键词</a></h2><p>函数返回的值是最后计算的表达式的值，默认情况下，它是函数定义主体中的最后一个表达式。在示例函数中<code>f</code>，从上一节开始，这是表达式的 <code>x + y</code>值。与在C和大多数其他命令式或函数式语言中一样，<code>return</code>关键字会导致函数立即返回，从而提供返回值的表达式：</p><pre><code class="language-julia">function g(x,y)
    return x * y
    x + y
end</code></pre><p>由于函数定义可以输入到交互式会话中，因此可以很容易的比较这些定义：</p><pre><code class="language-julia-repl">julia&gt; f(x,y) = x + y
f (generic function with 1 method)

julia&gt; function g(x,y)
           return x * y
           x + y
       end
g (generic function with 1 method)

julia&gt; f(2,3)
5

julia&gt; g(2,3)
6</code></pre><p>当然，在一个单纯的线性执行的函数体内，例如 <code>g</code>，使用<code>return</code> 是没有意义的，因为表达式<code>x + y</code>永远不会被执行到，我们可以简单地把<code>x * y</code> 写为最后一个表达式从而省略掉<code>return</code>。 然而在使用其他控制流程的函数体内，<code>return</code>却是有用的。 例如，一个计算两条边长分别为<code>x</code>和<code>y</code>的三角形的斜边长度时可以避免overflow：</p><pre><code class="language-julia-repl">julia&gt; function hypot(x,y)
           x = abs(x)
           y = abs(y)
           if x &gt; y
               r = y/x
               return x*sqrt(1+r*r)
           end
           if y == 0
               return zero(x)
           end
           r = x/y
           return y*sqrt(1+r*r)
       end
hypot (generic function with 1 method)

julia&gt; hypot(3, 4)
5.0</code></pre><p>这个函数有三个可能的返回处，返回三个不同表达式的值，具体取决于<code>x</code>和<code>y</code>的值。 最后一行的<code>return</code>可以省略，因为它是最后一个表达式。</p><p>也可以使用<code>::</code>运算符在函数声明中指定返回类型。 这可以将返回值转换为指定的类型。</p><pre><code class="language-julia-repl">julia&gt; function g(x, y)::Int8
           return x * y
       end;

julia&gt; typeof(g(1, 2))
Int8</code></pre><p>这个函数将忽略<code>x</code> 和<code>y</code>的类型，返回<code>Int8</code>类型的值。有关返回类型的更多信息，请参见 <a href="manual/@ref">类型声明</a>。</p><h2><a class="nav-anchor" id="操作符也是一类函数-1" href="#操作符也是一类函数-1">操作符也是一类函数</a></h2><p>在 Julia,大多数操作符只不过是支持一些特殊语法的函数。( <code>&amp;&amp;</code> 和<code>||</code>等具有特殊评估语义的操作符例外） 这些操作符不能是函数，因为<a href="manual/@ref">Short-Circuit Evaluation</a>要求在评估整个运算符之前不评估它们的操作数。 因此，您也可以使用带括号的参数列表来应用它们，就像你任何其他功能一样：</p><pre><code class="language-julia-repl">julia&gt; 1 + 2 + 3
6

julia&gt; +(1,2,3)
6</code></pre><p>中缀形式和函数形式的使用完全等价。 事实上，前一种形式被内在地解释为函数调用。 这意味着你可以对操作符，例如 <a href="../../base/math/#Base.:+"><code>+</code></a> and <a href="../../base/strings/#Base.:*-Tuple{Union{AbstractChar, AbstractString},Vararg{Union{AbstractChar, AbstractString},N} where N}"><code>*</code></a> 进行赋值和传递，就像对其它函数值一样。</p><pre><code class="language-julia-repl">julia&gt; f = +;

julia&gt; f(1,2,3)
6</code></pre><p>然而，函数以<code>f</code>命名时并不支持中缀形式。</p><h2><a class="nav-anchor" id="具有特殊名称的操作符-1" href="#具有特殊名称的操作符-1">具有特殊名称的操作符</a></h2><p>有一些特殊的表达式调用的函数调用没有显示的函数名称，它们是：</p><table><tr><th>表达式</th><th>调用</th></tr><tr><td><code>[A B C ...]</code></td><td><a href="../../base/arrays/#Base.hcat"><code>hcat</code></a></td></tr><tr><td><code>[A; B; C; ...]</code></td><td><a href="../../base/arrays/#Base.vcat"><code>vcat</code></a></td></tr><tr><td><code>[A B; C D; ...]</code></td><td><a href="../../base/arrays/#Base.hvcat"><code>hvcat</code></a></td></tr><tr><td><code>A&#39;</code></td><td><a href="../../stdlib/LinearAlgebra/#Base.adjoint"><code>adjoint</code></a></td></tr><tr><td><code>A[i]</code></td><td><a href="../../base/collections/#Base.getindex"><code>getindex</code></a></td></tr><tr><td><code>A[i] = x</code></td><td><a href="../../base/collections/#Base.setindex!"><code>setindex!</code></a></td></tr><tr><td><code>A.n</code></td><td><a href="../../base/base/#Base.getproperty"><code>getproperty</code></a></td></tr><tr><td><code>A.n = x</code></td><td><a href="../../base/base/#Base.setproperty!"><code>setproperty!</code></a></td></tr></table><h2><a class="nav-anchor" id="man-anonymous-functions-1" href="#man-anonymous-functions-1">匿名函数</a></h2><p>函数在Julia里是<a href="https://en.wikipedia.org/wiki/First-class_citizen">一等公民</a>：可以指定给变量，和使用标准函数调用语法通过被指定的变量被调用。函数可以用作参数，也可以当作返回值。函数也可以不带函数名地匿名创建，使用如下语法：</p><pre><code class="language-julia-repl">julia&gt; x -&gt; x^2 + 2x - 1
#1 (generic function with 1 method)

julia&gt; function (x)
           x^2 + 2x - 1
       end
#3 (generic function with 1 method)</code></pre><p>这样就创建了一个接受一个参数<code>x</code>和返回当前值下多项式<code>x^2+2x-1</code>的函数。注意到结果是个泛型函数，但是带了编译器生成的连续编号的名字。</p><p>匿名函数最主要的作用是传递给接收其他函数作为参数的函数。一个经典的例子是<a href="../../base/collections/#Base.map"><code>map</code></a>, 为数组的每个值应用一个函数，然后返回一个包含结果的值的新数组：</p><pre><code class="language-julia-repl">julia&gt; map(round, [1.2,3.5,1.7])
3-element Array{Float64,1}:
 1.0
 4.0
 2.0</code></pre><p>This is fine if a named function effecting the transform already exists to pass as the first argument to <a href="../../base/collections/#Base.map"><code>map</code></a>. Often, however, a ready-to-use, named function does not exist. In these situations, the anonymous function construct allows easy creation of a single-use function object without needing a name:</p><pre><code class="language-julia-repl">julia&gt; map(x -&gt; x^2 + 2x - 1, [1,3,-1])
3-element Array{Int64,1}:
  2
 14
 -2</code></pre><p>An anonymous function accepting multiple arguments can be written using the syntax <code>(x,y,z)-&gt;2x+y-z</code>. A zero-argument anonymous function is written as <code>()-&gt;3</code>. The idea of a function with no arguments may seem strange, but is useful for &quot;delaying&quot; a computation. In this usage, a block of code is wrapped in a zero-argument function, which is later invoked by calling it as <code>f</code>.</p><h2><a class="nav-anchor" id="元组-1" href="#元组-1">元组</a></h2><p>Julia 有一个和函数参数与返回值密切相关的内置数据结构叫做元组（<em>tuple</em>）。 一个元组是一个固定长度的容器，可以容纳任何值，但不可以被修改(是<em>immutable</em>的)。 元组通过圆括号和逗号来构造，其内容可以通过索引来访问：</p><pre><code class="language-julia-repl">julia&gt; (1, 1+1)
(1, 2)

julia&gt; (1,)
(1,)

julia&gt; x = (0.0, &quot;hello&quot;, 6*7)
(0.0, &quot;hello&quot;, 42)

julia&gt; x[2]
&quot;hello&quot;</code></pre><p>注意，长度为1的元组必须使用逗号<code>(1,)</code>，而<code>(1)</code>只是一个带括号的值。<code>()</code>表示空元组（长度为0）。</p><h2><a class="nav-anchor" id="Named-Tuples-1" href="#Named-Tuples-1">Named Tuples</a></h2><p>The components of tuples can optionally be named, in which case a <em>named tuple</em> is constructed:</p><pre><code class="language-julia-repl">julia&gt; x = (a=1, b=1+1)
(a = 1, b = 2)

julia&gt; x.a
1</code></pre><p>Named tuples are very similar to tuples, except that fields can additionally be accessed by name using dot syntax (<code>x.a</code>).</p><h2><a class="nav-anchor" id="多返回值-1" href="#多返回值-1">多返回值</a></h2><p>In Julia, one returns a tuple of values to simulate returning multiple values. However, tuples can be created and destructured without needing parentheses, thereby providing an illusion that multiple values are being returned, rather than a single tuple value. For example, the following function returns a pair of values:</p><pre><code class="language-julia-repl">julia&gt; function foo(a,b)
           a+b, a*b
       end
foo (generic function with 1 method)</code></pre><p>If you call it in an interactive session without assigning the return value anywhere, you will see the tuple returned:</p><pre><code class="language-julia-repl">julia&gt; foo(2,3)
(5, 6)</code></pre><p>A typical usage of such a pair of return values, however, extracts each value into a variable. Julia supports simple tuple &quot;destructuring&quot; that facilitates this:</p><pre><code class="language-julia-repl">julia&gt; x, y = foo(2,3)
(5, 6)

julia&gt; x
5

julia&gt; y
6</code></pre><p>你也可以显式地使用 <code>return</code> 关键字来返回多个值：</p><pre><code class="language-julia">function foo(a,b)
    return a+b, a*b
end</code></pre><p>这与之前的定义的<code>foo</code>函数具有完全相同的效果。</p><h2><a class="nav-anchor" id="Argument-destructuring-1" href="#Argument-destructuring-1">Argument destructuring</a></h2><p>The destructuring feature can also be used within a function argument. If a function argument name is written as a tuple (e.g. <code>(x, y)</code>) instead of just a symbol, then an assignment <code>(x, y) = argument</code> will be inserted for you:</p><pre><code class="language-julia">julia&gt; minmax(x, y) = (y &lt; x) ? (y, x) : (x, y)

julia&gt; range((min, max)) = max - min

julia&gt; range(minmax(10, 2))
8</code></pre><p>Notice the extra set of parentheses in the definition of <code>range</code>. Without those, <code>range</code> would be a two-argument function, and this example would not work.</p><h2><a class="nav-anchor" id="Varargs-Functions-1" href="#Varargs-Functions-1">Varargs Functions</a></h2><p>It is often convenient to be able to write functions taking an arbitrary number of arguments. Such functions are traditionally known as &quot;varargs&quot; functions, which is short for &quot;variable number of arguments&quot;. You can define a varargs function by following the last argument with an ellipsis:</p><pre><code class="language-julia-repl">julia&gt; bar(a,b,x...) = (a,b,x)
bar (generic function with 1 method)</code></pre><p>The variables <code>a</code> and <code>b</code> are bound to the first two argument values as usual, and the variable <code>x</code> is bound to an iterable collection of the zero or more values passed to <code>bar</code> after its first two arguments:</p><pre><code class="language-julia-repl">julia&gt; bar(1,2)
(1, 2, ())

julia&gt; bar(1,2,3)
(1, 2, (3,))

julia&gt; bar(1, 2, 3, 4)
(1, 2, (3, 4))

julia&gt; bar(1,2,3,4,5,6)
(1, 2, (3, 4, 5, 6))</code></pre><p>In all these cases, <code>x</code> is bound to a tuple of the trailing values passed to <code>bar</code>.</p><p>It is possible to constrain the number of values passed as a variable argument; this will be discussed later in <a href="../methods/#Parametrically-constrained-Varargs-methods-1">Parametrically-constrained Varargs methods</a>.</p><p>On the flip side, it is often handy to &quot;splat&quot; the values contained in an iterable collection into a function call as individual arguments. To do this, one also uses <code>...</code> but in the function call instead:</p><pre><code class="language-julia-repl">julia&gt; x = (3, 4)
(3, 4)

julia&gt; bar(1,2,x...)
(1, 2, (3, 4))</code></pre><p>In this case a tuple of values is spliced into a varargs call precisely where the variable number of arguments go. This need not be the case, however:</p><pre><code class="language-julia-repl">julia&gt; x = (2, 3, 4)
(2, 3, 4)

julia&gt; bar(1,x...)
(1, 2, (3, 4))

julia&gt; x = (1, 2, 3, 4)
(1, 2, 3, 4)

julia&gt; bar(x...)
(1, 2, (3, 4))</code></pre><p>Furthermore, the iterable object splatted into a function call need not be a tuple:</p><pre><code class="language-julia-repl">julia&gt; x = [3,4]
2-element Array{Int64,1}:
 3
 4

julia&gt; bar(1,2,x...)
(1, 2, (3, 4))

julia&gt; x = [1,2,3,4]
4-element Array{Int64,1}:
 1
 2
 3
 4

julia&gt; bar(x...)
(1, 2, (3, 4))</code></pre><p>Also, the function that arguments are splatted into need not be a varargs function (although it often is):</p><pre><code class="language-julia-repl">julia&gt; baz(a,b) = a + b;

julia&gt; args = [1,2]
2-element Array{Int64,1}:
 1
 2

julia&gt; baz(args...)
3

julia&gt; args = [1,2,3]
3-element Array{Int64,1}:
 1
 2
 3

julia&gt; baz(args...)
ERROR: MethodError: no method matching baz(::Int64, ::Int64, ::Int64)
Closest candidates are:
  baz(::Any, ::Any) at none:1</code></pre><p>As you can see, if the wrong number of elements are in the splatted container, then the function call will fail, just as it would if too many arguments were given explicitly.</p><h2><a class="nav-anchor" id="Optional-Arguments-1" href="#Optional-Arguments-1">Optional Arguments</a></h2><p>In many cases, function arguments have sensible default values and therefore might not need to be passed explicitly in every call. For example, the function <a href="../../stdlib/Dates/#Dates.Date"><code>Date(y, [m, d])</code></a> from <code>Dates</code> module constructs a <code>Date</code> type for a given year <code>y</code>, month <code>m</code> and day <code>d</code>. However, <code>m</code> and <code>d</code> arguments are optional and their default value is <code>1</code>. This behavior can be expressed concisely as:</p><pre><code class="language-julia">function Date(y::Int64, m::Int64=1, d::Int64=1)
    err = validargs(Date, y, m, d)
    err === nothing || throw(err)
    return Date(UTD(totaldays(y, m, d)))
end</code></pre><p>Observe, that this definition calls another method of <code>Date</code> function that takes one argument of <code>UTInstant{Day}</code> type.</p><p>With this definition, the function can be called with either one, two or three arguments, and <code>1</code> is automatically passed when any of the arguments is not specified:</p><pre><code class="language-julia-repl">julia&gt; using Dates

julia&gt; Date(2000, 12, 12)
2000-12-12

julia&gt; Date(2000, 12)
2000-12-01

julia&gt; Date(2000)
2000-01-01</code></pre><p>Optional arguments are actually just a convenient syntax for writing multiple method definitions with different numbers of arguments (see <a href="../methods/#Note-on-Optional-and-keyword-Arguments-1">Note on Optional and keyword Arguments</a>). This can be checked for our <code>Date</code> function example by calling <code>methods</code> function.</p><h2><a class="nav-anchor" id="Keyword-Arguments-1" href="#Keyword-Arguments-1">Keyword Arguments</a></h2><p>Some functions need a large number of arguments, or have a large number of behaviors. Remembering how to call such functions can be difficult. Keyword arguments can make these complex interfaces easier to use and extend by allowing arguments to be identified by name instead of only by position.</p><p>For example, consider a function <code>plot</code> that plots a line. This function might have many options, for controlling line style, width, color, and so on. If it accepts keyword arguments, a possible call might look like <code>plot(x, y, width=2)</code>, where we have chosen to specify only line width. Notice that this serves two purposes. The call is easier to read, since we can label an argument with its meaning. It also becomes possible to pass any subset of a large number of arguments, in any order.</p><p>Functions with keyword arguments are defined using a semicolon in the signature:</p><pre><code class="language-julia">function plot(x, y; style=&quot;solid&quot;, width=1, color=&quot;black&quot;)
    ###
end</code></pre><p>When the function is called, the semicolon is optional: one can either call <code>plot(x, y, width=2)</code> or <code>plot(x, y; width=2)</code>, but the former style is more common. An explicit semicolon is required only for passing varargs or computed keywords as described below.</p><p>Keyword argument default values are evaluated only when necessary (when a corresponding keyword argument is not passed), and in left-to-right order. Therefore default expressions may refer to prior keyword arguments.</p><p>The types of keyword arguments can be made explicit as follows:</p><pre><code class="language-julia">function f(;x::Int=1)
    ###
end</code></pre><p>Extra keyword arguments can be collected using <code>...</code>, as in varargs functions:</p><pre><code class="language-julia">function f(x; y=0, kwargs...)
    ###
end</code></pre><p>If a keyword argument is not assigned a default value in the method definition, then it is <em>required</em>: an <a href="../../base/base/#Core.UndefKeywordError"><code>UndefKeywordError</code></a> exception will be thrown if the caller does not assign it a value:</p><pre><code class="language-julia">function f(x; y)
    ###
end
f(3, y=5) # ok, y is assigned
f(3)      # throws UndefKeywordError(:y)</code></pre><p>Inside <code>f</code>, <code>kwargs</code> will be a named tuple. Named tuples (as well as dictionaries) can be passed as keyword arguments using a semicolon in a call, e.g. <code>f(x, z=1; kwargs...)</code>.</p><p>One can also pass <code>key =&gt; value</code> expressions after a semicolon. For example, <code>plot(x, y; :width =&gt; 2)</code> is equivalent to <code>plot(x, y, width=2)</code>. This is useful in situations where the keyword name is computed at runtime.</p><p>The nature of keyword arguments makes it possible to specify the same argument more than once. For example, in the call <code>plot(x, y; options..., width=2)</code> it is possible that the <code>options</code> structure also contains a value for <code>width</code>. In such a case the rightmost occurrence takes precedence; in this example, <code>width</code> is certain to have the value <code>2</code>. However, explicitly specifying the same keyword argument multiple times, for example <code>plot(x, y, width=2, width=3)</code>, is not allowed and results in a syntax error.</p><h2><a class="nav-anchor" id="Evaluation-Scope-of-Default-Values-1" href="#Evaluation-Scope-of-Default-Values-1">Evaluation Scope of Default Values</a></h2><p>When optional and keyword argument default expressions are evaluated, only <em>previous</em> arguments are in scope. For example, given this definition:</p><pre><code class="language-julia">function f(x, a=b, b=1)
    ###
end</code></pre><p>the <code>b</code> in <code>a=b</code> refers to a <code>b</code> in an outer scope, not the subsequent argument <code>b</code>.</p><h2><a class="nav-anchor" id="Do-Block-Syntax-for-Function-Arguments-1" href="#Do-Block-Syntax-for-Function-Arguments-1">Do-Block Syntax for Function Arguments</a></h2><p>Passing functions as arguments to other functions is a powerful technique, but the syntax for it is not always convenient. Such calls are especially awkward to write when the function argument requires multiple lines. As an example, consider calling <a href="../../base/collections/#Base.map"><code>map</code></a> on a function with several cases:</p><pre><code class="language-julia">map(x-&gt;begin
           if x &lt; 0 &amp;&amp; iseven(x)
               return 0
           elseif x == 0
               return 1
           else
               return x
           end
       end,
    [A, B, C])</code></pre><p>Julia provides a reserved word <code>do</code> for rewriting this code more clearly:</p><pre><code class="language-julia">map([A, B, C]) do x
    if x &lt; 0 &amp;&amp; iseven(x)
        return 0
    elseif x == 0
        return 1
    else
        return x
    end
end</code></pre><p>The <code>do x</code> syntax creates an anonymous function with argument <code>x</code> and passes it as the first argument to <a href="../../base/collections/#Base.map"><code>map</code></a>. Similarly, <code>do a,b</code> would create a two-argument anonymous function, and a plain <code>do</code> would declare that what follows is an anonymous function of the form <code>() -&gt; ...</code>.</p><p>How these arguments are initialized depends on the &quot;outer&quot; function; here, <a href="../../base/collections/#Base.map"><code>map</code></a> will sequentially set <code>x</code> to <code>A</code>, <code>B</code>, <code>C</code>, calling the anonymous function on each, just as would happen in the syntax <code>map(func, [A, B, C])</code>.</p><p>This syntax makes it easier to use functions to effectively extend the language, since calls look like normal code blocks. There are many possible uses quite different from <a href="../../base/collections/#Base.map"><code>map</code></a>, such as managing system state. For example, there is a version of <a href="../../base/io-network/#Base.open"><code>open</code></a> that runs code ensuring that the opened file is eventually closed:</p><pre><code class="language-julia">open(&quot;outfile&quot;, &quot;w&quot;) do io
    write(io, data)
end</code></pre><p>This is accomplished by the following definition:</p><pre><code class="language-julia">function open(f::Function, args...)
    io = open(args...)
    try
        f(io)
    finally
        close(io)
    end
end</code></pre><p>Here, <a href="../../base/io-network/#Base.open"><code>open</code></a> first opens the file for writing and then passes the resulting output stream to the anonymous function you defined in the <code>do ... end</code> block. After your function exits, <a href="../../base/io-network/#Base.open"><code>open</code></a> will make sure that the stream is properly closed, regardless of whether your function exited normally or threw an exception. (The <code>try/finally</code> construct will be described in <a href="manual/@ref">Control Flow</a>.)</p><p>With the <code>do</code> block syntax, it helps to check the documentation or implementation to know how the arguments of the user function are initialized.</p><p>A <code>do</code> block, like any other inner function, can &quot;capture&quot; variables from its enclosing scope. For example, the variable <code>data</code> in the above example of <code>open...do</code> is captured from the outer scope. Captured variables can create performance challenges as discussed in <a href="../performance-tips/#man-performance-tips-1">performance tips</a>.</p><h2><a class="nav-anchor" id="man-vectorized-1" href="#man-vectorized-1">Dot Syntax for Vectorizing Functions</a></h2><p>In technical-computing languages, it is common to have &quot;vectorized&quot; versions of functions, which simply apply a given function <code>f(x)</code> to each element of an array <code>A</code> to yield a new array via <code>f(A)</code>. This kind of syntax is convenient for data processing, but in other languages vectorization is also often required for performance: if loops are slow, the &quot;vectorized&quot; version of a function can call fast library code written in a low-level language. In Julia, vectorized functions are <em>not</em> required for performance, and indeed it is often beneficial to write your own loops (see <a href="../performance-tips/#man-performance-tips-1">Performance Tips</a>), but they can still be convenient. Therefore, <em>any</em> Julia function <code>f</code> can be applied elementwise to any array (or other collection) with the syntax <code>f.(A)</code>. For example <code>sin</code> can be applied to all elements in the vector <code>A</code>, like so:</p><pre><code class="language-julia-repl">julia&gt; A = [1.0, 2.0, 3.0]
3-element Array{Float64,1}:
 1.0
 2.0
 3.0

julia&gt; sin.(A)
3-element Array{Float64,1}:
 0.8414709848078965
 0.9092974268256817
 0.1411200080598672</code></pre><p>Of course, you can omit the dot if you write a specialized &quot;vector&quot; method of <code>f</code>, e.g. via <code>f(A::AbstractArray) = map(f, A)</code>, and this is just as efficient as <code>f.(A)</code>. But that approach requires you to decide in advance which functions you want to vectorize.</p><p>More generally, <code>f.(args...)</code> is actually equivalent to <code>broadcast(f, args...)</code>, which allows you to operate on multiple arrays (even of different shapes), or a mix of arrays and scalars (see <a href="manual/@ref">Broadcasting</a>). For example, if you have <code>f(x,y) = 3x + 4y</code>, then <code>f.(pi,A)</code> will return a new array consisting of <code>f(pi,a)</code> for each <code>a</code> in <code>A</code>, and <code>f.(vector1,vector2)</code> will return a new vector consisting of <code>f(vector1[i],vector2[i])</code> for each index <code>i</code> (throwing an exception if the vectors have different length).</p><pre><code class="language-julia-repl">julia&gt; f(x,y) = 3x + 4y;

julia&gt; A = [1.0, 2.0, 3.0];

julia&gt; B = [4.0, 5.0, 6.0];

julia&gt; f.(pi, A)
3-element Array{Float64,1}:
 13.42477796076938
 17.42477796076938
 21.42477796076938

julia&gt; f.(A, B)
3-element Array{Float64,1}:
 19.0
 26.0
 33.0</code></pre><p>Moreover, <em>nested</em> <code>f.(args...)</code> calls are <em>fused</em> into a single <code>broadcast</code> loop. For example, <code>sin.(cos.(X))</code> is equivalent to <code>broadcast(x -&gt; sin(cos(x)), X)</code>, similar to <code>[sin(cos(x)) for x in X]</code>: there is only a single loop over <code>X</code>, and a single array is allocated for the result. [In contrast, <code>sin(cos(X))</code> in a typical &quot;vectorized&quot; language would first allocate one temporary array for <code>tmp=cos(X)</code>, and then compute <code>sin(tmp)</code> in a separate loop, allocating a second array.] This loop fusion is not a compiler optimization that may or may not occur, it is a <em>syntactic guarantee</em> whenever nested <code>f.(args...)</code> calls are encountered. Technically, the fusion stops as soon as a &quot;non-dot&quot; function call is encountered; for example, in <code>sin.(sort(cos.(X)))</code> the <code>sin</code> and <code>cos</code> loops cannot be merged because of the intervening <code>sort</code> function.</p><p>Finally, the maximum efficiency is typically achieved when the output array of a vectorized operation is <em>pre-allocated</em>, so that repeated calls do not allocate new arrays over and over again for the results (see <a href="../performance-tips/#Pre-allocating-outputs-1">Pre-allocating outputs</a>). A convenient syntax for this is <code>X .= ...</code>, which is equivalent to <code>broadcast!(identity, X, ...)</code> except that, as above, the <code>broadcast!</code> loop is fused with any nested &quot;dot&quot; calls. For example, <code>X .= sin.(Y)</code> is equivalent to <code>broadcast!(sin, X, Y)</code>, overwriting <code>X</code> with <code>sin.(Y)</code> in-place. If the left-hand side is an array-indexing expression, e.g. <code>X[2:end] .= sin.(Y)</code>, then it translates to <code>broadcast!</code> on a <code>view</code>, e.g. <code>broadcast!(sin, view(X, 2:lastindex(X)), Y)</code>, so that the left-hand side is updated in-place.</p><p>Since adding dots to many operations and function calls in an expression can be tedious and lead to code that is difficult to read, the macro <a href="../../base/arrays/#Base.Broadcast.@__dot__"><code>@.</code></a> is provided to convert <em>every</em> function call, operation, and assignment in an expression into the &quot;dotted&quot; version.</p><pre><code class="language-julia-repl">julia&gt; Y = [1.0, 2.0, 3.0, 4.0];

julia&gt; X = similar(Y); # pre-allocate output array

julia&gt; @. X = sin(cos(Y)) # equivalent to X .= sin.(cos.(Y))
4-element Array{Float64,1}:
  0.5143952585235492
 -0.4042391538522658
 -0.8360218615377305
 -0.6080830096407656</code></pre><p>Binary (or unary) operators like <code>.+</code> are handled with the same mechanism: they are equivalent to <code>broadcast</code> calls and are fused with other nested &quot;dot&quot; calls.  <code>X .+= Y</code> etcetera is equivalent to <code>X .= X .+ Y</code> and results in a fused in-place assignment;  see also <a href="../mathematical-operations/#man-dot-operators-1">dot operators</a>.</p><p>You can also combine dot operations with function chaining using <a href="../../base/base/#Base.:|&gt;"><code>|&gt;</code></a>, as in this example:</p><pre><code class="language-julia-repl">julia&gt; [1:5;] .|&gt; [x-&gt;x^2, inv, x-&gt;2*x, -, isodd]
5-element Array{Real,1}:
    1
    0.5
    6
   -4
 true</code></pre><h2><a class="nav-anchor" id="更多阅读-1" href="#更多阅读-1">更多阅读</a></h2><p>We should mention here that this is far from a complete picture of defining functions. Julia has a sophisticated type system and allows multiple dispatch on argument types. None of the examples given here provide any type annotations on their arguments, meaning that they are applicable to all types of arguments. The type system is described in <a href="../types/#man-types-1">Types</a> and defining a function in terms of methods chosen by multiple dispatch on run-time argument types is described in <a href="manual/@ref">Methods</a>.</p><footer><hr/><a class="previous" href="../strings/"><span class="direction">Previous</span><span class="title">字符串</span></a><a class="next" href="../control-flow/"><span class="direction">Next</span><span class="title">流程控制</span></a></footer></article></body></html>
