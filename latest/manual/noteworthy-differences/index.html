<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>与其他语言的显著差异 · Julia中文文档</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-89508993-1', 'auto');
ga('send', 'pageview');
</script><link rel="canonical" href="https://juliacn.github.io/JuliaZH.jl/latest/manual/noteworthy-differences/index.html"/><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../../assets/julia-manual.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../../index.html"><img class="logo" src="../../assets/logo.png" alt="Julia中文文档 logo"/></a><h1>Julia中文文档</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">主页</a></li><li><span class="toctext">手册</span><ul><li><a class="toctext" href="../getting-started/">入门</a></li><li><a class="toctext" href="../variables/">变量</a></li><li><a class="toctext" href="../integers-and-floating-point-numbers/">整数和浮点数</a></li><li><a class="toctext" href="../mathematical-operations/">数学运算和初等函数</a></li><li><a class="toctext" href="../complex-and-rational-numbers/">复数和分数</a></li><li><a class="toctext" href="../strings/">字符串</a></li><li><a class="toctext" href="../functions/">函数</a></li><li><a class="toctext" href="../control-flow/">流程控制</a></li><li><a class="toctext" href="../variables-and-scoping/">变量作用域</a></li><li><a class="toctext" href="../types/">类型</a></li><li><a class="toctext" href="../methods/">方法</a></li><li><a class="toctext" href="../constructors/">构造函数</a></li><li><a class="toctext" href="../conversion-and-promotion/">类型转换和类型提升</a></li><li><a class="toctext" href="../interfaces/">接口</a></li><li><a class="toctext" href="../modules/">模块</a></li><li><a class="toctext" href="../documentation/">文档</a></li><li><a class="toctext" href="../metaprogramming/">Metaprogramming</a></li><li><a class="toctext" href="../arrays/">多维数组</a></li><li><a class="toctext" href="../missing/">缺失值</a></li><li><a class="toctext" href="../networking-and-streams/">网络和流</a></li><li><a class="toctext" href="../parallel-computing/">并行计算</a></li><li><a class="toctext" href="../running-external-programs/">运行外部程序</a></li><li><a class="toctext" href="../calling-c-and-fortran-code/">调用 C 和 Fortran 代码</a></li><li><a class="toctext" href="../handling-operating-system-variation/">处理操作系统差异</a></li><li><a class="toctext" href="../environment-variables/">环境变量</a></li><li><a class="toctext" href="../embedding/">嵌入 Julia</a></li><li><a class="toctext" href="../code-loading/">代码加载</a></li><li><a class="toctext" href="../profile/">分析</a></li><li><a class="toctext" href="../stacktraces/">堆栈跟踪</a></li><li><a class="toctext" href="../performance-tips/">性能建议</a></li><li><a class="toctext" href="../workflow-tips/">工作流程建议</a></li><li><a class="toctext" href="../style-guide/">代码风格指南</a></li><li><a class="toctext" href="../faq/">常见问题</a></li><li class="current"><a class="toctext" href>与其他语言的显著差异</a><ul class="internal"><li><a class="toctext" href="#与-MATLAB-的显著差异-1">与 MATLAB 的显著差异</a></li><li><a class="toctext" href="#与-R-的显著差异-1">与 R 的显著差异</a></li><li><a class="toctext" href="#与-Python-的显著差异-1">与 Python 的显著差异</a></li><li><a class="toctext" href="#与-C/C-的显著差异-1">与 C/C++ 的显著差异</a></li></ul></li><li><a class="toctext" href="../unicode-input/">Unicode 输入表</a></li></ul></li><li><span class="toctext">Base</span><ul><li><a class="toctext" href="../../base/base/">基本功能</a></li><li><a class="toctext" href="../../base/collections/">集合和数据结构</a></li><li><a class="toctext" href="../../base/math/">数学相关</a></li><li><a class="toctext" href="../../base/numbers/">Numbers</a></li><li><a class="toctext" href="../../base/strings/">字符串</a></li><li><a class="toctext" href="../../base/arrays/">Arrays</a></li><li><a class="toctext" href="../../base/parallel/">Tasks</a></li><li><a class="toctext" href="../../base/multi-threading/">多线程</a></li><li><a class="toctext" href="../../base/constants/">常量</a></li><li><a class="toctext" href="../../base/file/">文件系统</a></li><li><a class="toctext" href="../../base/io-network/">I/O 与网络</a></li><li><a class="toctext" href="../../base/punctuation/">标点符号</a></li><li><a class="toctext" href="../../base/sort/">排序及相关函数</a></li><li><a class="toctext" href="../../base/iterators/">迭代相关</a></li><li><a class="toctext" href="../../base/c/">C 接口</a></li><li><a class="toctext" href="../../base/libc/">C 标准库</a></li><li><a class="toctext" href="../../base/stacktraces/">StackTraces</a></li><li><a class="toctext" href="../../base/simd-types/">SIMD 支持</a></li></ul></li><li><span class="toctext">Standard Library</span><ul><li><a class="toctext" href="../../stdlib/Base64/">Base64</a></li><li><a class="toctext" href="../../stdlib/CRC32c/">CRC32c</a></li><li><a class="toctext" href="../../stdlib/Dates/">Dates</a></li><li><a class="toctext" href="../../stdlib/DelimitedFiles/">Delimited Files</a></li><li><a class="toctext" href="../../stdlib/Distributed/">Distributed Computing</a></li><li><a class="toctext" href="../../stdlib/FileWatching/">File Events</a></li><li><a class="toctext" href="../../stdlib/InteractiveUtils/">Interactive Utilities</a></li><li><a class="toctext" href="../../stdlib/LibGit2/">LibGit2</a></li><li><a class="toctext" href="../../stdlib/Libdl/">Dynamic Linker</a></li><li><a class="toctext" href="../../stdlib/LinearAlgebra/">Linear Algebra</a></li><li><a class="toctext" href="../../stdlib/Logging/">Logging</a></li><li><a class="toctext" href="../../stdlib/Markdown/">Markdown</a></li><li><a class="toctext" href="../../stdlib/Mmap/">Memory-mapped I/O</a></li><li><a class="toctext" href="../../stdlib/Pkg/">Pkg</a></li><li><a class="toctext" href="../../stdlib/Printf/">Printf</a></li><li><a class="toctext" href="../../stdlib/Profile/">Profiling</a></li><li><a class="toctext" href="../../stdlib/REPL/">The Julia REPL</a></li><li><a class="toctext" href="../../stdlib/Random/">Random Numbers</a></li><li><a class="toctext" href="../../stdlib/SHA/">SHA</a></li><li><a class="toctext" href="../../stdlib/Serialization/">Serialization</a></li><li><a class="toctext" href="../../stdlib/SharedArrays/">Shared Arrays</a></li><li><a class="toctext" href="../../stdlib/Sockets/">Sockets</a></li><li><a class="toctext" href="../../stdlib/SparseArrays/">Sparse Arrays</a></li><li><a class="toctext" href="../../stdlib/Statistics/">Statistics</a></li><li><a class="toctext" href="../../stdlib/Test/">Unit Testing</a></li><li><a class="toctext" href="../../stdlib/UUIDs/">UUIDs</a></li><li><a class="toctext" href="../../stdlib/Unicode/">Unicode</a></li></ul></li><li><span class="toctext">Developer Documentation</span><ul><li><a class="toctext" href="../../devdocs/reflection/">反射 与 自我检查</a></li><li><span class="toctext">Documentation of Julia&#39;s Internals</span><ul><li><a class="toctext" href="../../devdocs/init/">Julia 运行时的初始化</a></li><li><a class="toctext" href="../../devdocs/ast/">Julia 的 AST</a></li><li><a class="toctext" href="../../devdocs/types/">More about types</a></li><li><a class="toctext" href="../../devdocs/object/">Memory layout of Julia Objects</a></li><li><a class="toctext" href="../../devdocs/eval/">Eval of Julia code</a></li><li><a class="toctext" href="../../devdocs/callconv/">Calling Conventions</a></li><li><a class="toctext" href="../../devdocs/compiler/">High-level Overview of the Native-Code Generation Process</a></li><li><a class="toctext" href="../../devdocs/functions/">Julia的相关函数</a></li><li><a class="toctext" href="../../devdocs/cartesian/">Base.Cartesian</a></li><li><a class="toctext" href="../../devdocs/meta/">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="toctext" href="../../devdocs/subarrays/">SubArrays</a></li><li><a class="toctext" href="../../devdocs/isbitsunionarrays/">isbits Union Optimizations</a></li><li><a class="toctext" href="../../devdocs/sysimg/">System Image Building</a></li><li><a class="toctext" href="../../devdocs/llvm/">Working with LLVM</a></li><li><a class="toctext" href="../../devdocs/stdio/">printf() and stdio in the Julia runtime</a></li><li><a class="toctext" href="../../devdocs/boundscheck/">边界检查</a></li><li><a class="toctext" href="../../devdocs/locks/">Proper maintenance and care of multi-threading locks</a></li><li><a class="toctext" href="../../devdocs/offset-arrays/">Arrays with custom indices</a></li><li><a class="toctext" href="../../devdocs/require/">Module loading</a></li><li><a class="toctext" href="../../devdocs/inference/">Inference</a></li></ul></li><li><span class="toctext">Developing/debugging Julia&#39;s C code</span><ul><li><a class="toctext" href="../../devdocs/backtraces/">Reporting and analyzing crashes (segfaults)</a></li><li><a class="toctext" href="../../devdocs/debuggingtips/">gdb 调试提示</a></li><li><a class="toctext" href="../../devdocs/valgrind/">Using Valgrind with Julia</a></li><li><a class="toctext" href="../../devdocs/sanitizers/">Sanitizer support</a></li></ul></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>手册</li><li><a href>与其他语言的显著差异</a></li></ul><a class="edit-page" href="https://github.com/JuliaCN/JuliaZH.jl/blob/master/doc/src/manual/noteworthy-differences.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>与其他语言的显著差异</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="与其他语言的显著差异-1" href="#与其他语言的显著差异-1">与其他语言的显著差异</a></h1><h2><a class="nav-anchor" id="与-MATLAB-的显著差异-1" href="#与-MATLAB-的显著差异-1">与 MATLAB 的显著差异</a></h2><p>虽然 MATLAB 用户可能会发现 Julia 的语法很熟悉，但 Julia 不是 MATLAB 的克隆。 它们之间存在重大的语法和功能差异。 以下是一些可能会使习惯于 MATLAB 的Julia用户感到困扰的显著差异：</p><ul><li>Julia 数组使用方括号 <code>A[i,j]</code> 进行索引。</li><li>Julia 的数组在赋值给另一个变量时不发生复制。执行 <code>A = B</code> 后，改变 <code>B</code> 中元素也会修改 <code>A</code>。 as well.</li><li>Julia 的值在向函数传递时不发生复制。如果某个函数修改了数组，这一修改 对调用者是可见的。</li><li>Julia 不会在赋值语句中自动增长数组。 而在 MATLAB 中 <code>a(4) = 3.2</code> 可以创建数组 <code>a = [0 0 0 3.2]</code> 和 <code>a(5) = 7</code> 可以将它增长为 <code>a = [0 0 0 3.2 7]</code>。 如果 <code>a</code> 的长度小于 5 或者这个语句是第一次使用标识符 <code>a</code>，则相应的 Julia 语句 <code>a[5] = 7</code> 会抛出错误。 Julia 使用 <a href="../../base/collections/#Base.push!"><code>push!</code></a> 和 <a href="../../base/collections/#Base.append!"><code>append!</code></a> 实现比 MATLAB 的 <code>a(end+1) = val</code> 更高效地增长 <code>Vector</code>。 which grow <code>Vector</code>s much more efficiently than MATLAB&#39;s <code>a(end+1) = val</code>.</li><li>虚数单位 <code>sqrt(-1)</code> 在Julia中表示为 <a href="../../base/numbers/#Base.im"><code>im</code></a>，而不是在 MATLAB 中的 <code>i</code> 或 <code>j</code>。</li><li>在 Julia 中，没有小数点的字面数字（例如 <code>42</code>）会创建整数而不是浮点数。 也支持任意大整数。 因此，某些操作（如 <code>2^-1</code>）将抛出domain error，因为结果不是整数（有关详细信息，请参阅 <a href="../faq/#faq-domain-errors-1">the FAQ entry on domain errors</a>）。 for details).</li><li>在 Julia 中，能返回多个值并将其赋值为元组，例如 <code>(a, b) = (1, 2)</code> 或 <code>a, b = 1, 2</code>。 在 Julia 中不存在 MATLAB 的 <code>nargout</code>，它通常在 MATLAB 中用于根据返回值的数量执行可选工作。 取而代之的是，用户可以使用可选参数（optional arguments）和关键字参数（keyword arguments）来实现类似的功能。 similar capabilities.</li><li>Julia 拥有真正的一维数组。 列向量的大小为 <code>N</code>，而不是 <code>Nx1</code>。 例如，<a href="../../stdlib/Random/#Base.rand"><code>rand(N)</code></a> 创建一个一维数组。</li><li>在 Julia 中，<code>[x,y,z]</code> 将始终构造一个包含<code>x</code>，<code>y</code> 和 <code>z</code> 的3元素数组。<ul><li>要在第一个维度（“垂直列”）中连接元素，请使用 <a href="../../base/arrays/#Base.vcat"><code>vcat(x,y,z)</code></a> 或用分号分隔（<code>[x; y; z]</code>）。 with semicolons (<code>[x; y; z]</code>).</li><li>要在第二个维度（“水平行”）中连接元素，请使用 <a href="../../base/arrays/#Base.hcat"><code>hcat(x,y,z)</code></a> 或用空格分隔（<code>[x y z]</code>）。 with spaces (<code>[x y z]</code>).</li><li>要构造块矩阵（在前两个维度中连接元素），请使用 <a href="../../base/arrays/#Base.hvcat"><code>hvcat</code></a>或组合空格和分号（<code>[a b; c d]</code>）。 or combine spaces and semicolons (<code>[a b; c d]</code>).</li></ul></li><li>在 Julia 中，<code>a:b</code> 和 <code>a:b:c</code> 构造 <code>AbstractRange</code> 对象。使用 <a href="../../base/collections/#Base.collect-Tuple{Any}"><code>collect(a:b)</code></a> 构造一个类似 MATLAB 中完整的向量。 通常，不需要调用 <code>collect</code>。 在大多数情况下，<code>AbstractRange</code> 对象将像普通数组一样运行，但效率更高，因为它是懒惰求值。 这种创建专用对象而不是完整数组的模式经常被使用，并且 也可以在诸如 <a href="../../base/math/#Base.range"><code>range</code></a> 之类的函数中看到，或者在诸如 <code>enumerate</code> 和 <code>zip</code> 之类的迭代器中看到。 特殊对象大多可以像正常数组一样使用。</li><li>Julia 中的函数返回其最后一个表达式或 <code>return</code> 关键字的值而无需 在函数定义中列出要返回的变量的名称（有关详细信息，请参阅 <a href="manual/@ref">The return Keyword</a>）。 for details).</li><li>Julia 脚本可以包含任意数量的函数，并且在加载文件时，所有定义都将在外部可见。 可以从当前工作目录之外的文件加载函数定义。 directory.</li><li>In Julia, reductions such as <a href="../../base/collections/#Base.sum"><code>sum</code></a>, <a href="../../base/collections/#Base.prod"><code>prod</code></a>, and <a href="../../base/math/#Base.max"><code>max</code></a> are performed over every element of an array when called with a single argument, as in <code>sum(A)</code>, even if <code>A</code> has more than one dimension.</li><li>In Julia, parentheses must be used to call a function with zero arguments, like in <a href="../../stdlib/Random/#Base.rand"><code>rand()</code></a>.</li><li>Julia discourages the used of semicolons to end statements. The results of statements are not automatically printed (except at the interactive prompt), and lines of code do not need to end with semicolons. <a href="../../base/io-network/#Base.println"><code>println</code></a> or <a href="../../stdlib/Printf/#Printf.@printf"><code>@printf</code></a> can be used to print specific output.</li><li>In Julia, if <code>A</code> and <code>B</code> are arrays, logical comparison operations like <code>A == B</code> do not return an array of booleans. Instead, use <code>A .== B</code>, and similarly for the other boolean operators like <a href="../../base/math/#Base.:&lt;"><code>&lt;</code></a>, <a href="../../base/math/#Base.:&gt;"><code>&gt;</code></a> and <code>=</code>.</li><li>In Julia, the operators <a href="../../base/math/#Base.:&amp;"><code>&amp;</code></a>, <a href="../../base/math/#Base.:|"><code>|</code></a>, and <a href="../../base/math/#Base.xor"><code>⊻</code></a> (<a href="../../base/math/#Base.xor"><code>xor</code></a>) perform the bitwise operations equivalent to <code>and</code>, <code>or</code>, and <code>xor</code> respectively in MATLAB, and have precedence similar to Python&#39;s bitwise operators (unlike C). They can operate on scalars or element-wise across arrays and can be used to combine logical arrays, but note the difference in order of operations: parentheses may be required (e.g., to select elements of <code>A</code> equal to 1 or 2 use <code>(A .== 1) .| (A .== 2)</code>).</li><li>In Julia, the elements of a collection can be passed as arguments to a function using the splat operator <code>...</code>, as in <code>xs=[1,2]; f(xs...)</code>.</li><li>Julia&#39;s <a href="../../stdlib/LinearAlgebra/#LinearAlgebra.svd"><code>svd</code></a> returns singular values as a vector instead of as a dense diagonal matrix.</li><li>In Julia, <code>...</code> is not used to continue lines of code. Instead, incomplete expressions automatically continue onto the next line.</li><li>In both Julia and MATLAB, the variable <code>ans</code> is set to the value of the last expression issued in an interactive session. In Julia, unlike MATLAB, <code>ans</code> is not set when Julia code is run in non-interactive mode.</li><li>Julia&#39;s <code>struct</code>s do not support dynamically adding fields at runtime, unlike MATLAB&#39;s <code>class</code>es. Instead, use a <a href="../../base/collections/#Base.Dict"><code>Dict</code></a>.</li><li>In Julia each module has its own global scope/namespace, whereas in MATLAB there is just one global scope.</li><li>In MATLAB, an idiomatic way to remove unwanted values is to use logical indexing, like in the expression <code>x(x&gt;3)</code> or in the statement <code>x(x&gt;3) = []</code> to modify <code>x</code> in-place. In contrast, Julia provides the higher order functions <a href="../../base/collections/#Base.filter"><code>filter</code></a> and <a href="../../base/collections/#Base.filter!"><code>filter!</code></a>, allowing users to write <code>filter(z-&gt;z&gt;3, x)</code> and <code>filter!(z-&gt;z&gt;3, x)</code> as alternatives to the corresponding transliterations <code>x[x.&gt;3]</code> and <code>x = x[x.&gt;3]</code>. Using <a href="../../base/collections/#Base.filter!"><code>filter!</code></a> reduces the use of temporary arrays.</li><li>The analogue of extracting (or &quot;dereferencing&quot;) all elements of a cell array, e.g. in <code>vertcat(A{:})</code> in MATLAB, is written using the splat operator in Julia, e.g. as <code>vcat(A...)</code>.</li></ul><h2><a class="nav-anchor" id="与-R-的显著差异-1" href="#与-R-的显著差异-1">与 R 的显著差异</a></h2><p>One of Julia&#39;s goals is to provide an effective language for data analysis and statistical programming. For users coming to Julia from R, these are some noteworthy differences:</p><ul><li><p>Julia&#39;s single quotes enclose characters, not strings.</p></li><li><p>Julia can create substrings by indexing into strings. In R, strings must be converted into character vectors before creating substrings.</p></li><li><p>In Julia, like Python but unlike R, strings can be created with triple quotes <code>&quot;&quot;&quot; ... &quot;&quot;&quot;</code>. This syntax is convenient for constructing strings that contain line breaks.</p></li><li><p>In Julia, varargs are specified using the splat operator <code>...</code>, which always follows the name of a specific variable, unlike R, for which <code>...</code> can occur in isolation.</p></li><li><p>In Julia, modulus is <code>mod(a, b)</code>, not <code>a %% b</code>. <code>%</code> in Julia is the remainder operator.</p></li><li><p>In Julia, not all data structures support logical indexing. Furthermore, logical indexing in Julia is supported only with vectors of length equal to the object being indexed. For example:</p><ul><li>In R, <code>c(1, 2, 3, 4)[c(TRUE, FALSE)]</code> is equivalent to <code>c(1, 3)</code>.</li><li>In R, <code>c(1, 2, 3, 4)[c(TRUE, FALSE, TRUE, FALSE)]</code> is equivalent to <code>c(1, 3)</code>.</li><li>In Julia, <code>[1, 2, 3, 4][[true, false]]</code> throws a <a href="../../base/base/#Core.BoundsError"><code>BoundsError</code></a>.</li><li>In Julia, <code>[1, 2, 3, 4][[true, false, true, false]]</code> produces <code>[1, 3]</code>.</li></ul></li><li><p>Like many languages, Julia does not always allow operations on vectors of different lengths, unlike R where the vectors only need to share a common index range.  For example, <code>c(1, 2, 3, 4) + c(1, 2)</code> is valid R but the equivalent <code>[1, 2, 3, 4] + [1, 2]</code> will throw an error in Julia.</p></li><li><p>Julia allows an optional trailing comma when that comma does not change the meaning of code. This can cause confusion among R users when indexing into arrays. For example, <code>x[1,]</code> in R would return the first row of a matrix; in Julia, however, the comma is ignored, so <code>x[1,] == x[1]</code>, and will return the first element. To extract a row, be sure to use <code>:</code>, as in <code>x[1,:]</code>.</p></li><li><p>Julia&#39;s <a href="../../base/collections/#Base.map"><code>map</code></a> takes the function first, then its arguments, unlike <code>lapply(&lt;structure&gt;, function, ...)</code> in R. Similarly Julia&#39;s equivalent of <code>apply(X, MARGIN, FUN, ...)</code> in R is <a href="../../base/arrays/#Base.mapslices"><code>mapslices</code></a> where the function is the first argument.</p></li><li><p>Multivariate apply in R, e.g. <code>mapply(choose, 11:13, 1:3)</code>, can be written as <code>broadcast(binomial, 11:13, 1:3)</code> in Julia. Equivalently Julia offers a shorter dot syntax for vectorizing functions <code>binomial.(11:13, 1:3)</code>.</p></li><li><p>Julia uses <code>end</code> to denote the end of conditional blocks, like <code>if</code>, loop blocks, like <code>while</code>/ <code>for</code>, and functions. In lieu of the one-line <code>if ( cond ) statement</code>, Julia allows statements of the form <code>if cond; statement; end</code>, <code>cond &amp;&amp; statement</code> and <code>!cond || statement</code>. Assignment statements in the latter two syntaxes must be explicitly wrapped in parentheses, e.g. <code>cond &amp;&amp; (x = value)</code>.</p></li><li><p>In Julia, <code>&lt;-</code>, <code>&lt;&lt;-</code> and <code>-&gt;</code> are not assignment operators.</p></li><li><p>Julia&#39;s <code>-&gt;</code> creates an anonymous function.</p></li><li><p>Julia constructs vectors using brackets. Julia&#39;s <code>[1, 2, 3]</code> is the equivalent of R&#39;s <code>c(1, 2, 3)</code>.</p></li><li><p>Julia&#39;s <a href="../../base/strings/#Base.:*-Tuple{Union{AbstractChar, AbstractString},Vararg{Union{AbstractChar, AbstractString},N} where N}"><code>*</code></a> operator can perform matrix multiplication, unlike in R. If <code>A</code> and <code>B</code> are matrices, then <code>A * B</code> denotes a matrix multiplication in Julia, equivalent to R&#39;s <code>A %*% B</code>. In R, this same notation would perform an element-wise (Hadamard) product. To get the element-wise multiplication operation, you need to write <code>A .* B</code> in Julia.</p></li><li><p>Julia performs matrix transposition using the <code>transpose</code> function and conjugated transposition using the <code>&#39;</code> operator or the <code>adjoint</code> function. Julia&#39;s <code>transpose(A)</code> is therefore equivalent to R&#39;s <code>t(A)</code>. Additionally a non-recursive transpose in Julia is provided by the <code>permutedims</code> function.</p></li><li><p>Julia does not require parentheses when writing <code>if</code> statements or <code>for</code>/<code>while</code> loops: use <code>for i in [1, 2, 3]</code> instead of <code>for (i in c(1, 2, 3))</code> and <code>if i == 1</code> instead of <code>if (i == 1)</code>.</p></li><li><p>Julia does not treat the numbers <code>0</code> and <code>1</code> as Booleans. You cannot write <code>if (1)</code> in Julia, because <code>if</code> statements accept only booleans. Instead, you can write <code>if true</code>, <code>if Bool(1)</code>, or <code>if 1==1</code>.</p></li><li><p>Julia does not provide <code>nrow</code> and <code>ncol</code>. Instead, use <code>size(M, 1)</code> for <code>nrow(M)</code> and <code>size(M, 2)</code> for <code>ncol(M)</code>.</p></li><li><p>Julia is careful to distinguish scalars, vectors and matrices.  In R, <code>1</code> and <code>c(1)</code> are the same. In Julia, they cannot be used interchangeably.</p></li><li><p>Julia&#39;s <a href="../../stdlib/LinearAlgebra/#LinearAlgebra.diag"><code>diag</code></a> and <a href="../../stdlib/LinearAlgebra/#LinearAlgebra.diagm"><code>diagm</code></a> are not like R&#39;s.</p></li><li><p>Julia cannot assign to the results of function calls on the left hand side of an assignment operation: you cannot write <code>diag(M) = fill(1, n)</code>.</p></li><li><p>Julia discourages populating the main namespace with functions. Most statistical functionality for Julia is found in <a href="https://pkg.julialang.org/">packages</a> under the <a href="https://github.com/JuliaStats">JuliaStats organization</a>. 例如：</p><ul><li>Functions pertaining to probability distributions are provided by the <a href="https://github.com/JuliaStats/Distributions.jl">Distributions package</a>.</li><li>The <a href="https://github.com/JuliaStats/DataFrames.jl">DataFrames package</a> provides data frames.</li><li>Generalized linear models are provided by the <a href="https://github.com/JuliaStats/GLM.jl">GLM package</a>.</li></ul></li><li><p>Julia provides tuples and real hash tables, but not R-style lists. When returning multiple items, you should typically use a tuple or a named tuple: instead of <code>list(a = 1, b = 2)</code>, use <code>(1, 2)</code> or <code>(a=1, b=2)</code>.</p></li><li><p>Julia encourages users to write their own types, which are easier to use than S3 or S4 objects in R. Julia&#39;s multiple dispatch system means that <code>table(x::TypeA)</code> and <code>table(x::TypeB)</code> act like R&#39;s <code>table.TypeA(x)</code> and <code>table.TypeB(x)</code>.</p></li><li><p>In Julia, values are not copied when assigned or passed to a function. If a function modifies an array, the changes will be visible in the caller. This is very different from R and allows new functions to operate on large data structures much more efficiently.</p></li><li><p>In Julia, vectors and matrices are concatenated using <a href="../../base/arrays/#Base.hcat"><code>hcat</code></a>, <a href="../../base/arrays/#Base.vcat"><code>vcat</code></a> and <a href="../../base/arrays/#Base.hvcat"><code>hvcat</code></a>, not <code>c</code>, <code>rbind</code> and <code>cbind</code> like in R.</p></li><li><p>In Julia, a range like <code>a:b</code> is not shorthand for a vector like in R, but is a specialized <code>AbstractRange</code> object that is used for iteration without high memory overhead. To convert a range into a vector, use <a href="../../base/collections/#Base.collect-Tuple{Any}"><code>collect(a:b)</code></a>.</p></li><li><p>Julia&#39;s <a href="../../base/math/#Base.max"><code>max</code></a> and <a href="../../base/math/#Base.min"><code>min</code></a> are the equivalent of <code>pmax</code> and <code>pmin</code> respectively in R, but both arguments need to have the same dimensions.  While <a href="../../base/collections/#Base.maximum"><code>maximum</code></a> and <a href="../../base/collections/#Base.minimum"><code>minimum</code></a> replace <code>max</code> and <code>min</code> in R, there are important differences.</p></li><li><p>Julia&#39;s <a href="../../base/collections/#Base.sum"><code>sum</code></a>, <a href="../../base/collections/#Base.prod"><code>prod</code></a>, <a href="../../base/collections/#Base.maximum"><code>maximum</code></a>, and <a href="../../base/collections/#Base.minimum"><code>minimum</code></a> are different from their counterparts in R. They all accept one or two arguments. The first argument is an iterable collection such as an array.  If there is a second argument, then this argument indicates the dimensions, over which the operation is carried out.  For instance, let <code>A = [1 2; 3 4]</code> in Julia and <code>B &lt;- rbind(c(1,2),c(3,4))</code> be the same matrix in R.  Then <code>sum(A)</code> gives the same result as <code>sum(B)</code>, but <code>sum(A, dims=1)</code> is a row vector containing the sum over each column and <code>sum(A, dims=2)</code> is a column vector containing the sum over each row. This contrasts to the behavior of R, where separate <code>colSums(B)</code> and <code>rowSums(B)</code> functions provide these functionalities. If the <code>dims</code> keyword argument is a vector, then it specifies all the dimensions over which the sum is performed, while retaining the dimensions of the summed array, e.g. <code>sum(A, dims=(1,2)) == hcat(10)</code>. It should be noted that there is no error checking regarding the second argument.</p></li><li><p>Julia has several functions that can mutate their arguments. For example, it has both <a href="../../base/sort/#Base.sort"><code>sort</code></a> and <a href="../../base/sort/#Base.sort!"><code>sort!</code></a>.</p></li><li><p>In R, performance requires vectorization. In Julia, almost the opposite is true: the best performing code is often achieved by using devectorized loops.</p></li><li><p>Julia is eagerly evaluated and does not support R-style lazy evaluation. For most users, this means that there are very few unquoted expressions or column names.</p></li><li><p>Julia does not support the <code>NULL</code> type. The closest equivalent is <a href="../../base/constants/#Core.nothing"><code>nothing</code></a>, but it behaves like a scalar value rather than like a list. Use <code>x == nothing</code> instead of <code>is.null(x)</code>.</p></li><li><p>In Julia, missing values are represented by the <a href="../../base/base/#Base.missing"><code>missing</code></a> object rather than by <code>NA</code>. Use <a href="../../base/base/#Base.ismissing"><code>ismissing(x)</code></a> instead of <code>isna(x)</code>. The <a href="../../base/base/#Base.skipmissing"><code>skipmissing</code></a> function is generally used instead of <code>na.rm=TRUE</code> (though in some particular cases functions take a <code>skipmissing</code> argument).</p></li><li><p>Julia lacks the equivalent of R&#39;s <code>assign</code> or <code>get</code>.</p></li><li><p>In Julia, <code>return</code> does not require parentheses.</p></li><li><p>In R, an idiomatic way to remove unwanted values is to use logical indexing, like in the expression <code>x[x&gt;3]</code> or in the statement <code>x = x[x&gt;3]</code> to modify <code>x</code> in-place. In contrast, Julia provides the higher order functions <a href="../../base/collections/#Base.filter"><code>filter</code></a> and <a href="../../base/collections/#Base.filter!"><code>filter!</code></a>, allowing users to write <code>filter(z-&gt;z&gt;3, x)</code> and <code>filter!(z-&gt;z&gt;3, x)</code> as alternatives to the corresponding transliterations <code>x[x.&gt;3]</code> and <code>x = x[x.&gt;3]</code>. Using <a href="../../base/collections/#Base.filter!"><code>filter!</code></a> reduces the use of temporary arrays.</p></li></ul><h2><a class="nav-anchor" id="与-Python-的显著差异-1" href="#与-Python-的显著差异-1">与 Python 的显著差异</a></h2><ul><li>Julia 需要用 <code>end</code> 来结束代码块。与 Python 不同，Julia 没有 <code>pass</code> 关键字。</li><li>在 Julia 中，数组、字符串等的索引从 1 开始，而不是从 0 开始。</li><li>Julia 的切片索引包含最后一个元素，这与 Python 不同。Julia 中的 <code>a[2:3]</code> 就是 Python 中的 <code>a[1:3]</code> 。</li><li>Julia 不支持负数索引。特别地，列表或数组的最后一个元素 在 Julia 中使用 <code>end</code> 索引，而不像在 Python 中使用 <code>-1</code>。</li><li>Julia 的 <code>for</code>、<code>if</code>、<code>while</code>等代码块由<code>end</code>关键字终止。缩进级别 并不像在 Python 中那么重要。</li><li>Julia 没有用来续行的语法：如果在行的末尾，到目前为止的输入是一个完整的 表达式，则认为已经结束；否则，认为输入继续。强制表达式继续的一种方式是 将其包含在括号中。</li><li>默认情况下，Julia 数组是 column major (Fortran ordered)，而 NumPy 数组是 ow major (C-ordered)。 为了在循环数组时获得最佳性能，循环顺序应该 在 Julia 中相对于 NumPy 反转（请参阅 <a href="../performance-tips/#man-performance-tips-1">Performance Tips</a> 中的对应章节）。</li><li>Julia 的更新运算符（例如 <code>+=</code>，<code>-=</code>，···）是 <em>not in-place</em>，而 Numpy 的是。这 意味着 <code>A = [1, 1]; B = A; B += [3, 3]</code> 不会改变 <code>A</code> 中的值，而将名称 <code>B</code> 重新绑定 到右侧表达式 <code>B = B + 3</code> 的结果，这是一个新的数组。对于 in-place 操作，使用 <code>B .+= 3</code> （另请参阅 <a href="../mathematical-operations/#man-dot-operators-1">dot operators</a>），显式的循环，或者 <code>InplaceOps.jl</code>。</li><li>每次调用方法时，Julia 都会计算函数参数的默认值，不像 在 Python 中，默认值只会在函数定义时被计算一次。例如， 每次无输入参数调用时，函数<code>f(x=rand()) = x</code>都返回一个新的随机数 在另一方面，函数 <code>g(x=[1,2]) = push!(x,3)</code> 在每次以 <code>g()</code> 调用时返回 <code>[1,2,3]</code> 。</li><li>在 Julia 中，<code>%</code> 是余数运算符，而在 Python 中是模运算符。</li></ul><h2><a class="nav-anchor" id="与-C/C-的显著差异-1" href="#与-C/C-的显著差异-1">与 C/C++ 的显著差异</a></h2><ul><li>Julia 的数组由方括号索引，方括号中可以包含不止一个维度 <code>A[i,j]</code>。 这样的语法不仅仅是像 C/C++ 中那样对指针或者地址引用的语法糖，参见 Julia 文档数组构造的语法（依版本不同有所变动）。</li><li>在 Julia 中，数组、字符串等的索引从 1 开始，而不是从 0 开始。</li><li>Julia 的数组在赋值给另一个变量时不发生复制。执行 <code>A = B</code> 后，改变 <code>B</code> 中元素也会修改 <code>A</code>。像 <code>+=</code> 这样的更新运算符不会以 in-place 的方式执行，而是相当于 <code>A = A + B</code>，将左侧绑定到右侧表达式的计算结果上。 as well. Updating operators like <code>+=</code> do not operate in-place, they are equivalent to <code>A = A + B</code> which rebinds the left-hand side to the result of the right-hand side expression.</li><li>Julia 的数组是行优先的（Fortran 顺序），而 C/C++ 的数组默认是列优先的。要使数组上的循环性能最优，在 Julia 中循环的顺序应该与 C/C++ 相反（参见 <a href="../performance-tips/#man-performance-tips-1">性能建议</a>）。 default. To get optimal performance when looping over arrays, the order of the loops should be reversed in Julia relative to C/C++ (see relevant section of <a href="../performance-tips/#man-performance-tips-1">Performance Tips</a>).</li><li>Julia 的值在赋值或向函数传递时不发生复制。如果某个函数修改了数组，这一修改 对调用者是可见的。</li><li>在 Julia 中，空格是有意义的，这与 C/C++ 不同，所以向 Julia 程序中添加或删除空格时必须谨慎。 whitespace from a Julia program.</li><li>在 Julia 中，没有小数点的数值字面量（如 <code>42</code>）生成有符号整数，类型为 <code>Int</code>，但如果字面量太长，超过了机器字长，则会被自动提升为容量更大的类型，例如 <code>Int64</code>（如果 <code>Int</code> 是 <code>Int32</code>）、<code>Int128</code>，或者任意精度的 <code>BigInt</code> 类型。不存在诸如 <code>L</code>, <code>LL</code>, <code>U</code>, <code>UL</code>, <code>ULL</code> 这样的数值字面量后缀指示无符号和/或有符号与无符号。十进制字面量始终是有符号的，十六进制字面量（像 C/C++ 一样由 <code>0x</code> 开头）是无符号的。另外，十六进制字面量与 C/C++/Java 不同， <code>Int</code>, but literals too large to fit in the machine word size will automatically be promoted to a larger size type, such as <code>Int64</code> (if <code>Int</code> is <code>Int32</code>), <code>Int128</code>, or the arbitrarily large 也与 Julia 中的十进制字面量不同，它们的类型取决于字面量的<strong>长度</strong>，包括开头的 0。例如，<code>0x0</code> 和 <code>0x00</code> 的类型是 <a href="../../base/numbers/#Core.UInt8"><code>UInt8</code></a>，<code>0x000</code> 和 <code>0x0000</code> 的类型是 <a href="../../base/numbers/#Core.UInt16"><code>UInt16</code></a>。同理，字面量的长度在 5-8 之间，类型为 <code>UInt32</code>；在 9-16 之间，类型为 <code>UInt64</code>；在 17-32 之间，类型为 <code>UInt128</code>。当定义十六进制掩码时，就需要将这一问题考虑在内，比如 <code>~0xf == 0xf0</code> 与 <code>~0x000f == 0xfff0</code> 完全不同。 unsigned and/or signed vs. unsigned. Decimal literals are always signed, and hexadecimal literals (which start with <code>0x</code> like C/C++), are unsigned. Hexadecimal literals also, unlike C/C++/Java and unlike decimal literals in Julia, have a type based on the <em>length</em> of the literal, including leading 0s. For example, <code>0x0</code> and <code>0x00</code> have type <a href="../../base/numbers/#Core.UInt8"><code>UInt8</code></a>, <code>0x000</code> and <code>0x0000</code> have type <a href="../../base/numbers/#Core.UInt16"><code>UInt16</code></a>, then literals with 5 to 8 hex digits have type <code>UInt32</code>, 9 to 16 hex digits type <code>UInt64</code> and 17 to 32 hex digits type <code>UInt128</code>. This needs to be taken into account when defining hexadecimal masks, for example <code>~0xf == 0xf0</code> is very different from <code>~0x000f == 0xfff0</code>. 64 bit <code>Float64</code> and 32 bit <a href="../../base/numbers/#Core.Float32"><code>Float32</code></a> bit literals are expressed as <code>1.0</code> and <code>1.0f0</code> respectively. Floating point literals are rounded (and not promoted to the <code>BigFloat</code> type) if they can not be exactly represented.  Floating point literals are closer in behavior to C/C++. Octal (prefixed with <code>0o</code>) and binary (prefixed with <code>0b</code>) literals are also treated as unsigned.</li><li>String literals can be delimited with either <code>&quot;</code>  or <code>&quot;&quot;&quot;</code>, <code>&quot;&quot;&quot;</code> delimited literals can contain <code>&quot;</code> characters without quoting it like <code>&quot;\&quot;&quot;</code> String literals can have values of other variables or expressions interpolated into them, indicated by <code>$variablename</code> or <code>$(expression)</code>, which evaluates the variable name or the expression in the context of the function.</li><li><code>//</code> indicates a <a href="../../base/numbers/#Base.Rational"><code>Rational</code></a> number, and not a single-line comment (which is <code>#</code> in Julia)</li><li><code>#=</code> indicates the start of a multiline comment, and <code>=#</code> ends it.</li><li>Functions in Julia return values from their last expression(s) or the <code>return</code> keyword.  Multiple values can be returned from functions and assigned as tuples, e.g. <code>(a, b) = myfunction()</code> or <code>a, b = myfunction()</code>, instead of having to pass pointers to values as one would have to do in C/C++ (i.e. <code>a = myfunction(&amp;b)</code>.</li><li>Julia does not require the use of semicolons to end statements. The results of expressions are not automatically printed (except at the interactive prompt, i.e. the REPL), and lines of code do not need to end with semicolons. <a href="../../base/io-network/#Base.println"><code>println</code></a> or <a href="../../stdlib/Printf/#Printf.@printf"><code>@printf</code></a> can be used to print specific output. In the REPL, <code>;</code> can be used to suppress output. <code>;</code> also has a different meaning within <code>[ ]</code>, something to watch out for. <code>;</code> can be used to separate expressions on a single line, but are not strictly necessary in many cases, and are more an aid to readability.</li><li>In Julia, the operator <a href="../../base/math/#Base.xor"><code>⊻</code></a> (<a href="../../base/math/#Base.xor"><code>xor</code></a>) performs the bitwise XOR operation, i.e. <a href="../../base/strings/#Base.:^-Tuple{AbstractString,Integer}"><code>^</code></a> in C/C++.  Also, the bitwise operators do not have the same precedence as C/++, so parenthesis may be required.</li><li>Julia&#39;s <a href="../../base/strings/#Base.:^-Tuple{AbstractString,Integer}"><code>^</code></a> is exponentiation (pow), not bitwise XOR as in C/C++ (use <a href="../../base/math/#Base.xor"><code>⊻</code></a>, or <a href="../../base/math/#Base.xor"><code>xor</code></a>, in Julia)</li><li>Julia has two right-shift operators, <code>&gt;&gt;</code> and <code>&gt;&gt;&gt;</code>.  <code>&gt;&gt;&gt;</code> performs an arithmetic shift, <code>&gt;&gt;</code> always performs a logical shift, unlike C/C++, where the meaning of <code>&gt;&gt;</code> depends on the type of the value being shifted.</li><li>Julia&#39;s <code>-&gt;</code> creates an anonymous function, it does not access a member via a pointer.</li><li>Julia does not require parentheses when writing <code>if</code> statements or <code>for</code>/<code>while</code> loops: use <code>for i in [1, 2, 3]</code> instead of <code>for (int i=1; i &lt;= 3; i++)</code> and <code>if i == 1</code> instead of <code>if (i == 1)</code>.</li><li>Julia does not treat the numbers <code>0</code> and <code>1</code> as Booleans. You cannot write <code>if (1)</code> in Julia, because <code>if</code> statements accept only booleans. Instead, you can write <code>if true</code>, <code>if Bool(1)</code>, or <code>if 1==1</code>.</li><li>Julia uses <code>end</code> to denote the end of conditional blocks, like <code>if</code>, loop blocks, like <code>while</code>/ <code>for</code>, and functions. In lieu of the one-line <code>if ( cond ) statement</code>, Julia allows statements of the form <code>if cond; statement; end</code>, <code>cond &amp;&amp; statement</code> and <code>!cond || statement</code>. Assignment statements in the latter two syntaxes must be explicitly wrapped in parentheses, e.g. <code>cond &amp;&amp; (x = value)</code>, because of the operator precedence.</li><li>Julia 没有用来续行的语法：如果在行的末尾，到目前为止的输入是一个完整的 表达式，则认为已经结束；否则，认为输入继续。强制表达式继续的一种方式是 将其包含在括号中。</li><li>Julia macros operate on parsed expressions, rather than the text of the program, which allows them to perform sophisticated transformations of Julia code. Macro names start with the <code>@</code> character, and have both a function-like syntax, <code>@mymacro(arg1, arg2, arg3)</code>, and a statement-like syntax, <code>@mymacro arg1 arg2 arg3</code>. The forms are interchangeable; the function-like form is particularly useful if the macro appears within another expression, and is often clearest. The statement-like form is often used to annotate blocks, as in the distributed <code>for</code> construct: <code>@distributed for i in 1:n; #= body =#; end</code>. Where the end of the macro construct may be unclear, use the function-like form.</li><li>Julia now has an enumeration type, expressed using the macro <code>@enum(name, value1, value2, ...)</code> For example: <code>@enum(Fruit, banana=1, apple, pear)</code></li><li>By convention, functions that modify their arguments have a <code>!</code> at the end of the name, for example <code>push!</code>.</li><li>In C++, by default, you have static dispatch, i.e. you need to annotate a function as virtual, in order to have dynamic dispatch. On the other hand, in Julia every method is &quot;virtual&quot; (although it&#39;s more general than that since methods are dispatched on every argument type, not only <code>this</code>, using the most-specific-declaration rule).</li></ul><footer><hr/><a class="previous" href="../faq/"><span class="direction">Previous</span><span class="title">常见问题</span></a><a class="next" href="../unicode-input/"><span class="direction">Next</span><span class="title">Unicode 输入表</span></a></footer></article></body></html>
