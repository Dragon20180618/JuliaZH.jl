<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>主页 · Julia中文文档</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-89508993-1', 'auto');
ga('send', 'pageview');
</script><link rel="canonical" href="https://juliacn.github.io/JuliaZH.jl/latest/index.html"/><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/><link href="assets/julia-manual.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="index.html"><img class="logo" src="assets/logo.png" alt="Julia中文文档 logo"/></a><h1>Julia中文文档</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>主页</a><ul class="internal"></ul></li><li><span class="toctext">手册</span><ul><li><a class="toctext" href="manual/getting-started/">入门</a></li><li><a class="toctext" href="manual/variables/">变量</a></li><li><a class="toctext" href="manual/integers-and-floating-point-numbers/">整数和浮点数</a></li><li><a class="toctext" href="manual/mathematical-operations/">数学运算和初等函数</a></li><li><a class="toctext" href="manual/complex-and-rational-numbers/">复数和分数</a></li><li><a class="toctext" href="manual/strings/">字符串</a></li><li><a class="toctext" href="manual/functions/">函数</a></li><li><a class="toctext" href="manual/control-flow/">流程控制</a></li><li><a class="toctext" href="manual/variables-and-scoping/">变量作用域</a></li><li><a class="toctext" href="manual/types/">类型</a></li><li><a class="toctext" href="manual/methods/">方法</a></li><li><a class="toctext" href="manual/constructors/">构造函数</a></li><li><a class="toctext" href="manual/conversion-and-promotion/">类型转换和类型提升</a></li><li><a class="toctext" href="manual/interfaces/">接口</a></li><li><a class="toctext" href="manual/modules/">模块</a></li><li><a class="toctext" href="manual/documentation/">文档</a></li><li><a class="toctext" href="manual/metaprogramming/">Metaprogramming</a></li><li><a class="toctext" href="manual/arrays/">多维数组</a></li><li><a class="toctext" href="manual/missing/">缺失值</a></li><li><a class="toctext" href="manual/networking-and-streams/">网络和流</a></li><li><a class="toctext" href="manual/parallel-computing/">并行计算</a></li><li><a class="toctext" href="manual/running-external-programs/">运行外部程序</a></li><li><a class="toctext" href="manual/calling-c-and-fortran-code/">调用 C 和 Fortran 代码</a></li><li><a class="toctext" href="manual/handling-operating-system-variation/">处理操作系统差异</a></li><li><a class="toctext" href="manual/environment-variables/">环境变量</a></li><li><a class="toctext" href="manual/embedding/">嵌入 Julia</a></li><li><a class="toctext" href="manual/code-loading/">代码加载</a></li><li><a class="toctext" href="manual/profile/">分析</a></li><li><a class="toctext" href="manual/stacktraces/">堆栈跟踪</a></li><li><a class="toctext" href="manual/performance-tips/">性能建议</a></li><li><a class="toctext" href="manual/workflow-tips/">工作流程建议</a></li><li><a class="toctext" href="manual/style-guide/">代码风格指南</a></li><li><a class="toctext" href="manual/faq/">常见问题</a></li><li><a class="toctext" href="manual/noteworthy-differences/">与其他语言的显著差异</a></li><li><a class="toctext" href="manual/unicode-input/">Unicode 输入表</a></li></ul></li><li><span class="toctext">Base</span><ul><li><a class="toctext" href="base/base/">基本功能</a></li><li><a class="toctext" href="base/collections/">集合和数据结构</a></li><li><a class="toctext" href="base/math/">数学相关</a></li><li><a class="toctext" href="base/numbers/">Numbers</a></li><li><a class="toctext" href="base/strings/">字符串</a></li><li><a class="toctext" href="base/arrays/">Arrays</a></li><li><a class="toctext" href="base/parallel/">Tasks</a></li><li><a class="toctext" href="base/multi-threading/">多线程</a></li><li><a class="toctext" href="base/constants/">常量</a></li><li><a class="toctext" href="base/file/">文件系统</a></li><li><a class="toctext" href="base/io-network/">I/O 与网络</a></li><li><a class="toctext" href="base/punctuation/">标点符号</a></li><li><a class="toctext" href="base/sort/">排序及相关函数</a></li><li><a class="toctext" href="base/iterators/">迭代相关</a></li><li><a class="toctext" href="base/c/">C 接口</a></li><li><a class="toctext" href="base/libc/">C 标准库</a></li><li><a class="toctext" href="base/stacktraces/">StackTraces</a></li><li><a class="toctext" href="base/simd-types/">SIMD 支持</a></li></ul></li><li><span class="toctext">Standard Library</span><ul><li><a class="toctext" href="stdlib/Base64/">Base64</a></li><li><a class="toctext" href="stdlib/CRC32c/">CRC32c</a></li><li><a class="toctext" href="stdlib/Dates/">Dates</a></li><li><a class="toctext" href="stdlib/DelimitedFiles/">Delimited Files</a></li><li><a class="toctext" href="stdlib/Distributed/">Distributed Computing</a></li><li><a class="toctext" href="stdlib/FileWatching/">File Events</a></li><li><a class="toctext" href="stdlib/InteractiveUtils/">Interactive Utilities</a></li><li><a class="toctext" href="stdlib/LibGit2/">LibGit2</a></li><li><a class="toctext" href="stdlib/Libdl/">Dynamic Linker</a></li><li><a class="toctext" href="stdlib/LinearAlgebra/">Linear Algebra</a></li><li><a class="toctext" href="stdlib/Logging/">Logging</a></li><li><a class="toctext" href="stdlib/Markdown/">Markdown</a></li><li><a class="toctext" href="stdlib/Mmap/">Memory-mapped I/O</a></li><li><a class="toctext" href="stdlib/Pkg/">Pkg</a></li><li><a class="toctext" href="stdlib/Printf/">Printf</a></li><li><a class="toctext" href="stdlib/Profile/">Profiling</a></li><li><a class="toctext" href="stdlib/REPL/">The Julia REPL</a></li><li><a class="toctext" href="stdlib/Random/">Random Numbers</a></li><li><a class="toctext" href="stdlib/SHA/">SHA</a></li><li><a class="toctext" href="stdlib/Serialization/">Serialization</a></li><li><a class="toctext" href="stdlib/SharedArrays/">Shared Arrays</a></li><li><a class="toctext" href="stdlib/Sockets/">Sockets</a></li><li><a class="toctext" href="stdlib/SparseArrays/">Sparse Arrays</a></li><li><a class="toctext" href="stdlib/Statistics/">Statistics</a></li><li><a class="toctext" href="stdlib/Test/">Unit Testing</a></li><li><a class="toctext" href="stdlib/UUIDs/">UUIDs</a></li><li><a class="toctext" href="stdlib/Unicode/">Unicode</a></li></ul></li><li><span class="toctext">Developer Documentation</span><ul><li><a class="toctext" href="devdocs/reflection/">反射 与 自我检查</a></li><li><span class="toctext">Documentation of Julia&#39;s Internals</span><ul><li><a class="toctext" href="devdocs/init/">Julia 运行时的初始化</a></li><li><a class="toctext" href="devdocs/ast/">Julia 的 AST</a></li><li><a class="toctext" href="devdocs/types/">More about types</a></li><li><a class="toctext" href="devdocs/object/">Memory layout of Julia Objects</a></li><li><a class="toctext" href="devdocs/eval/">Eval of Julia code</a></li><li><a class="toctext" href="devdocs/callconv/">Calling Conventions</a></li><li><a class="toctext" href="devdocs/compiler/">High-level Overview of the Native-Code Generation Process</a></li><li><a class="toctext" href="devdocs/functions/">Julia的相关函数</a></li><li><a class="toctext" href="devdocs/cartesian/">Base.Cartesian</a></li><li><a class="toctext" href="devdocs/meta/">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="toctext" href="devdocs/subarrays/">SubArrays</a></li><li><a class="toctext" href="devdocs/isbitsunionarrays/">isbits Union Optimizations</a></li><li><a class="toctext" href="devdocs/sysimg/">System Image Building</a></li><li><a class="toctext" href="devdocs/llvm/">Working with LLVM</a></li><li><a class="toctext" href="devdocs/stdio/">printf() and stdio in the Julia runtime</a></li><li><a class="toctext" href="devdocs/boundscheck/">边界检查</a></li><li><a class="toctext" href="devdocs/locks/">Proper maintenance and care of multi-threading locks</a></li><li><a class="toctext" href="devdocs/offset-arrays/">Arrays with custom indices</a></li><li><a class="toctext" href="devdocs/require/">Module loading</a></li><li><a class="toctext" href="devdocs/inference/">Inference</a></li></ul></li><li><span class="toctext">Developing/debugging Julia&#39;s C code</span><ul><li><a class="toctext" href="devdocs/backtraces/">Reporting and analyzing crashes (segfaults)</a></li><li><a class="toctext" href="devdocs/debuggingtips/">gdb 调试提示</a></li><li><a class="toctext" href="devdocs/valgrind/">Using Valgrind with Julia</a></li><li><a class="toctext" href="devdocs/sanitizers/">Sanitizer support</a></li></ul></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>主页</a></li></ul><a class="edit-page" href="https://github.com/JuliaCN/JuliaZH.jl/blob/master/doc/src/index.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>主页</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Julia-1.0-中文文档-1" href="#Julia-1.0-中文文档-1">Julia 1.0 中文文档</a></h1><p>欢迎来到 Julia 1.0 中文文档。</p><div class="admonition note"><div class="admonition-title">关于中文文档</div><div class="admonition-text"><p>Julia 语言相关的本地化工作是一个由社区驱动的开源项目<a href="https://github.com/JuliaCN/JuliaZH.jl">JuliaZH.jl</a>，旨在方便 Julia 的中文用户。我们目前使用 <a href="https://www.transifex.com">Transifex</a> 作为翻译平台。翻译工作正在进行，有任何疑问或建议请到<a href="http://discourse.juliacn.com/c/community/document">社区论坛文档区</a>反馈。若有意参与翻译工作，请参考<a href="http://discourse.juliacn.com/t/topic/277">翻译指南</a>。</p></div></div><h3><a class="nav-anchor" id="man-introduction-1" href="#man-introduction-1">简介</a></h3><p>科学计算对性能一直有着最高的需求， 但现在这个领域的专家开始大量使用比较慢的动态语言来完成日常工作。 我们相信有很多使用动态语言的理由， 所以我们不会舍弃这样的特性。幸运的是，现代语言设计和编译器技术使得为原型设计提供单一的高效开发环境， 并且配置高性能的应用成为可能。Julia 语言在这其中扮演了这样一个角色：作为灵活的动态语言，适合科学和数值计算，性能可与传统静态类型语言媲美。</p><p>由于 Julia 的编译器和其它语言比如 Python 或 R 有所不同，一开始您或许会觉得 Julia 中什么样的代码运行效率高，什么样的代码运行效率低似乎并不很直观。 如果您发现 Julia 变慢了，我们非常建议您在尝试其它功能前读一下<a href="manual/performance-tips/#man-performance-tips-1">提高性能的窍门</a> 。只要您理解 Julia 的工作方式， 就会很容易地写出运行效率甚至可以和 C 相媲美的代码。</p><p>Julia 具有通过类型推倒和<a href="https://en.wikipedia.org/wiki/Just-in-time_compilation">即时编译（JIT）</a>在 <a href="https://en.wikipedia.org/wiki/Low_Level_Virtual_Machine">LLVM</a> 上实现的可选类型标注，多重派发，良好的性能。它是一个支持过程式，函数式 面向对象编程的多范式语言。它提供了简易和简洁的高等数值计算，它类似于 R 、 MATLAB 和 Python ，支持一般用途的编程。为了达到这个目的 Julia 在数学编程语言的基础上，参考了不少流行动态语言，例如 <a href="https://en.wikipedia.org/wiki/Lisp_(programming_language)">Lisp</a>, <a href="https://en.wikipedia.org/wiki/Perl_(programming_language)">Perl</a>, <a href="https://en.wikipedia.org/wiki/Python_(programming_language)">Python</a>, <a href="https://en.wikipedia.org/wiki/Lua_(programming_language)">Lua</a>, 和 <a href="https://en.wikipedia.org/wiki/Ruby_(programming_language)">Ruby</a>。</p><p>Julia 与传统动态语言最大的区别是：</p><ul><li>核心语言很小；标准库是用 Julia 本身写的，如整数运算在内的基础运算</li><li>完善的类型，方便构造对象和做类型声明</li><li>基于<a href="https://en.wikipedia.org/wiki/Multiple_dispatch">多重派发</a>通过很多不同的参数类型来定义函数行为的能力</li><li>为不同类型自动生成高效，专用的代码</li><li>接近 C 语言的，良好的性能</li></ul><p>尽管，一些人有时说动态语言是“无类型的”，但实际上他们并不是这样：每一个对象，无论是基础的还是用户自己定义的，都有一个类型。 在大多数动态语言中都缺乏类型声明，而这往往意味着无法指示编译器值的类型，也就无法显示地讨论类型。另一方面，静态语言中，虽然可以标记类型 （往往也必须这么做），但是类型只在编译时期才存在，而无法在运行时进行操作和表达。在 Julia 里，类型是它们自己的动态对象，也可以 被用来给编译器提供相应的信息。</p><p>类型系统和多重派发是 Julia 语言最主要的特征（尽管类型和多重派发并不必要被显式使用）：函数通过函数名称和不同类型变量的组合进行定义，然后在调用时会派发 最接近（most specific）的定义上去。这样的编程模型非常适合数学化的编程，尤其是在传统的面向对象派发中，一些函数的第一个变量理论上并不“拥有”这样一个操作时。 而在Julia中运算符只是函数的一个特殊标记——例如，为用户定义的新类型添加加法运算，你只要为 <code>+</code> 函数定义一个新的方法就可以了。 已有的代码就可以无缝接入这个新的类型。</p><p>一部分是因为动态类型推导（可以被可选的类型标注增强），另一部分是因为在这个语言建立之初就对性能非常看重，Julia 的计算性能超过了其它的 动态语言，甚至能够与静态编译语言竞争。对于大型数值问题，速度一直都是，也一直会是一个重要的关注点：这些年以来，被处理的数据量的增长有着Moore定律。</p><p>Julia 的目标是创建一个前所未有的集易用、强大、高效于一体的语言。除此之外，Julia 的优势还在于：</p><ul><li>免费开源（<a href="https://github.com/JuliaLang/julia/blob/master/LICENSE.md">MIT 许可证</a>）</li><li>用户定义的类型和内建类型一样快和兼容</li><li>无需特意编写向量化的代码；非向量化的代码就很快</li><li>为并行计算和分布式计算设计</li><li>轻量级的“绿色”线程 (<a href="https://en.wikipedia.org/wiki/Coroutine">协程</a>)</li><li>低调又牛逼的类型系统</li><li>优雅、可扩展的类型转换</li><li>高效支持 <a href="https://en.wikipedia.org/wiki/Unicode">Unicode</a>，包括但不限于 <a href="https://en.wikipedia.org/wiki/UTF-8">UTF-8</a></li><li>直接调用 C 函数（不需封装或调用特别的 API）</li><li>像 Shell 一样强大的管理其他进程的能力</li><li>像 Lisp 一样的宏和其他元编程工具</li></ul><footer><hr/><a class="next" href="manual/getting-started/"><span class="direction">Next</span><span class="title">入门</span></a></footer></article></body></html>
