<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Bounds checking · Julia中文文档</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-89508993-1', 'auto');
ga('send', 'pageview');
</script><link rel="canonical" href="https://juliacn.github.io/JuliaZH.jl/latest/devdocs/boundscheck/index.html"/><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../../assets/julia-manual.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../../index.html"><img class="logo" src="../../assets/logo.png" alt="Julia中文文档 logo"/></a><h1>Julia中文文档</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">主页</a></li><li><span class="toctext">手册</span><ul><li><a class="toctext" href="../../manual/getting-started/">起步</a></li><li><a class="toctext" href="../../manual/variables/">变量</a></li><li><a class="toctext" href="../../manual/integers-and-floating-point-numbers/">整数和浮点数</a></li><li><a class="toctext" href="../../manual/mathematical-operations/">数学运算和初等函数</a></li><li><a class="toctext" href="../../manual/complex-and-rational-numbers/">复数和分数</a></li><li><a class="toctext" href="../../manual/strings/">字符串</a></li><li><a class="toctext" href="../../manual/functions/">函数</a></li><li><a class="toctext" href="../../manual/control-flow/">流程控制</a></li><li><a class="toctext" href="../../manual/variables-and-scoping/">Scope of Variables</a></li><li><a class="toctext" href="../../manual/types/">类型</a></li><li><a class="toctext" href="../../manual/methods/">方法</a></li><li><a class="toctext" href="../../manual/constructors/">构造函数</a></li><li><a class="toctext" href="../../manual/conversion-and-promotion/">类型转换和类型提升</a></li><li><a class="toctext" href="../../manual/interfaces/">Interfaces</a></li><li><a class="toctext" href="../../manual/modules/">Modules</a></li><li><a class="toctext" href="../../manual/documentation/">文档</a></li><li><a class="toctext" href="../../manual/metaprogramming/">元编程</a></li><li><a class="toctext" href="../../manual/arrays/">多维数组</a></li><li><a class="toctext" href="../../manual/missing/">缺失值</a></li><li><a class="toctext" href="../../manual/networking-and-streams/">Networking and Streams</a></li><li><a class="toctext" href="../../manual/parallel-computing/">并行计算</a></li><li><a class="toctext" href="../../manual/running-external-programs/">运行外部程序</a></li><li><a class="toctext" href="../../manual/calling-c-and-fortran-code/">调用C和Fortran代码</a></li><li><a class="toctext" href="../../manual/handling-operating-system-variation/">处理操作系统差异</a></li><li><a class="toctext" href="../../manual/environment-variables/">环境变量</a></li><li><a class="toctext" href="../../manual/embedding/">嵌入 Julia</a></li><li><a class="toctext" href="../../manual/code-loading/">Code Loading</a></li><li><a class="toctext" href="../../manual/profile/">Profiling</a></li><li><a class="toctext" href="../../manual/stacktraces/">Stack Traces</a></li><li><a class="toctext" href="../../manual/performance-tips/">性能建议</a></li><li><a class="toctext" href="../../manual/workflow-tips/">工作流程建议</a></li><li><a class="toctext" href="../../manual/style-guide/">代码风格指南</a></li><li><a class="toctext" href="../../manual/faq/">常见问题</a></li><li><a class="toctext" href="../../manual/noteworthy-differences/">Noteworthy Differences from other Languages</a></li><li><a class="toctext" href="../../manual/unicode-input/">Unicode 输入表</a></li></ul></li><li><span class="toctext">Base</span><ul><li><a class="toctext" href="../../base/base/">Essentials</a></li><li><a class="toctext" href="../../base/collections/">Collections and Data Structures</a></li><li><a class="toctext" href="../../base/math/">Mathematics</a></li><li><a class="toctext" href="../../base/numbers/">Numbers</a></li><li><a class="toctext" href="../../base/strings/">【字符串】（@id lib-strings）</a></li><li><a class="toctext" href="../../base/arrays/">Arrays</a></li><li><a class="toctext" href="../../base/parallel/">Tasks</a></li><li><a class="toctext" href="../../base/multi-threading/">多线程</a></li><li><a class="toctext" href="../../base/constants/">Constants</a></li><li><a class="toctext" href="../../base/file/">文件系统</a></li><li><a class="toctext" href="../../base/io-network/">I/O and Network</a></li><li><a class="toctext" href="../../base/punctuation/">Punctuation</a></li><li><a class="toctext" href="../../base/sort/">排序及相关函数</a></li><li><a class="toctext" href="../../base/iterators/">Iteration utilities</a></li><li><a class="toctext" href="../../base/c/">C Interface</a></li><li><a class="toctext" href="../../base/libc/">C Standard Library</a></li><li><a class="toctext" href="../../base/stacktraces/">StackTraces</a></li><li><a class="toctext" href="../../base/simd-types/">SIMD Support</a></li></ul></li><li><span class="toctext">Developer Documentation</span><ul><li><a class="toctext" href="../reflection/">Reflection and introspection</a></li><li><span class="toctext">Documentation of Julia&#39;s Internals</span><ul><li><a class="toctext" href="../init/">Initialization of the Julia runtime</a></li><li><a class="toctext" href="../ast/">Julia ASTs</a></li><li><a class="toctext" href="../types/">More about types</a></li><li><a class="toctext" href="../object/">Memory layout of Julia Objects</a></li><li><a class="toctext" href="../eval/">Eval of Julia code</a></li><li><a class="toctext" href="../callconv/">Calling Conventions</a></li><li><a class="toctext" href="../compiler/">High-level Overview of the Native-Code Generation Process</a></li><li><a class="toctext" href="../functions/">Julia Functions</a></li><li><a class="toctext" href="../cartesian/">Base.Cartesian</a></li><li><a class="toctext" href="../meta/">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="toctext" href="../subarrays/">SubArrays</a></li><li><a class="toctext" href="../isbitsunionarrays/">isbits Union Optimizations</a></li><li><a class="toctext" href="../sysimg/">System Image Building</a></li><li><a class="toctext" href="../llvm/">Working with LLVM</a></li><li><a class="toctext" href="../stdio/">printf() and stdio in the Julia runtime</a></li><li class="current"><a class="toctext" href>Bounds checking</a><ul class="internal"><li><a class="toctext" href="#Eliding-bounds-checks-1">Eliding bounds checks</a></li><li><a class="toctext" href="#Propagating-inbounds-1">Propagating inbounds</a></li><li><a class="toctext" href="#The-bounds-checking-call-hierarchy-1">The bounds checking call hierarchy</a></li></ul></li><li><a class="toctext" href="../locks/">Proper maintenance and care of multi-threading locks</a></li><li><a class="toctext" href="../offset-arrays/">Arrays with custom indices</a></li><li><a class="toctext" href="../require/">Module loading</a></li><li><a class="toctext" href="../inference/">Inference</a></li></ul></li><li><span class="toctext">Developing/debugging Julia&#39;s C code</span><ul><li><a class="toctext" href="../backtraces/">Reporting and analyzing crashes (segfaults)</a></li><li><a class="toctext" href="../debuggingtips/">gdb debugging tips</a></li><li><a class="toctext" href="../valgrind/">Using Valgrind with Julia</a></li><li><a class="toctext" href="../sanitizers/">Sanitizer support</a></li></ul></li></ul></li><li><span class="toctext">中文文档开发</span><ul><li><a class="toctext" href="../../juliacn/style-guide/">翻译格式指引</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Developer Documentation</li><li>Documentation of Julia&#39;s Internals</li><li><a href>Bounds checking</a></li></ul><a class="edit-page" href="https://github.com/JuliaCN/JuliaZH.jl/blob/master/doc/src/devdocs/boundscheck.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Bounds checking</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Bounds-checking-1" href="#Bounds-checking-1">Bounds checking</a></h1><p>Like many modern programming languages, Julia uses bounds checking to ensure program safety when accessing arrays. In tight inner loops or other performance critical situations, you may wish to skip these bounds checks to improve runtime performance. For instance, in order to emit vectorized (SIMD) instructions, your loop body cannot contain branches, and thus cannot contain bounds checks. Consequently, Julia includes an <code>@inbounds(...)</code> macro to tell the compiler to skip such bounds checks within the given block. User-defined array types can use the <code>@boundscheck(...)</code> macro to achieve context-sensitive code selection.</p><h2><a class="nav-anchor" id="Eliding-bounds-checks-1" href="#Eliding-bounds-checks-1">Eliding bounds checks</a></h2><p>The <code>@boundscheck(...)</code> macro marks blocks of code that perform bounds checking. When such blocks are inlined into an <code>@inbounds(...)</code> block, the compiler may remove these blocks. The compiler removes the <code>@boundscheck</code> block <em>only if it is inlined</em> into the calling function. For example, you might write the method <code>sum</code> as:</p><pre><code class="language-julia">function sum(A::AbstractArray)
    r = zero(eltype(A))
    for i = 1:length(A)
        @inbounds r += A[i]
    end
    return r
end</code></pre><p>With a custom array-like type <code>MyArray</code> having:</p><pre><code class="language-julia">@inline getindex(A::MyArray, i::Real) = (@boundscheck checkbounds(A,i); A.data[to_index(i)])</code></pre><p>Then when <code>getindex</code> is inlined into <code>sum</code>, the call to <code>checkbounds(A,i)</code> will be elided. If your function contains multiple layers of inlining, only <code>@boundscheck</code> blocks at most one level of inlining deeper are eliminated. The rule prevents unintended changes in program behavior from code further up the stack.</p><h2><a class="nav-anchor" id="Propagating-inbounds-1" href="#Propagating-inbounds-1">Propagating inbounds</a></h2><p>There may be certain scenarios where for code-organization reasons you want more than one layer between the <code>@inbounds</code> and <code>@boundscheck</code> declarations. For instance, the default <code>getindex</code> methods have the chain <code>getindex(A::AbstractArray, i::Real)</code> calls <code>getindex(IndexStyle(A), A, i)</code> calls <code>_getindex(::IndexLinear, A, i)</code>.</p><p>To override the &quot;one layer of inlining&quot; rule, a function may be marked with <code>@propagate_inbounds</code> to propagate an inbounds context (or out of bounds context) through one additional layer of inlining.</p><h2><a class="nav-anchor" id="The-bounds-checking-call-hierarchy-1" href="#The-bounds-checking-call-hierarchy-1">The bounds checking call hierarchy</a></h2><p>The overall hierarchy is:</p><ul><li><p><code>checkbounds(A, I...)</code> which calls</p><ul><li><p><code>checkbounds(Bool, A, I...)</code> which calls</p><ul><li><p><code>checkbounds_indices(Bool, axes(A), I)</code> which recursively calls</p><ul><li><code>checkindex</code> for each dimension</li></ul></li></ul></li></ul></li></ul><p>Here <code>A</code> is the array, and <code>I</code> contains the &quot;requested&quot; indices. <code>axes(A)</code> returns a tuple of &quot;permitted&quot; indices of <code>A</code>.</p><p><code>checkbounds(A, I...)</code> throws an error if the indices are invalid, whereas <code>checkbounds(Bool, A, I...)</code> returns <code>false</code> in that circumstance.  <code>checkbounds_indices</code> discards any information about the array other than its <code>axes</code> tuple, and performs a pure indices-vs-indices comparison: this allows relatively few compiled methods to serve a huge variety of array types. Indices are specified as tuples, and are usually compared in a 1-1 fashion with individual dimensions handled by calling another important function, <code>checkindex</code>: typically,</p><pre><code class="language-julia">checkbounds_indices(Bool, (IA1, IA...), (I1, I...)) = checkindex(Bool, IA1, I1) &amp;
                                                      checkbounds_indices(Bool, IA, I)</code></pre><p>so <code>checkindex</code> checks a single dimension.  All of these functions, including the unexported <code>checkbounds_indices</code> have docstrings accessible with <code>?</code> .</p><p>If you have to customize bounds checking for a specific array type, you should specialize <code>checkbounds(Bool, A, I...)</code>. However, in most cases you should be able to rely on <code>checkbounds_indices</code> as long as you supply useful <code>axes</code> for your array type.</p><p>If you have novel index types, first consider specializing <code>checkindex</code>, which handles a single index for a particular dimension of an array.  If you have a custom multidimensional index type (similar to <code>CartesianIndex</code>), then you may have to consider specializing <code>checkbounds_indices</code>.</p><p>Note this hierarchy has been designed to reduce the likelihood of method ambiguities.  We try to make <code>checkbounds</code> the place to specialize on array type, and try to avoid specializations on index types; conversely, <code>checkindex</code> is intended to be specialized only on index type (especially, the last argument).</p><footer><hr/><a class="previous" href="../stdio/"><span class="direction">Previous</span><span class="title">printf() and stdio in the Julia runtime</span></a><a class="next" href="../locks/"><span class="direction">Next</span><span class="title">Proper maintenance and care of multi-threading locks</span></a></footer></article></body></html>
